<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/1.png"><link rel="icon" href="/img/1.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#6a598c"><meta name="author" content="even zhang"><meta name="keywords" content=""><meta name="description" content="学习 go 写的笔记，后续整理一下 go 变量声明 go 语言变量声明特点：  变量类型是在后面 即使没有显式初始化，Go 语言也会给变量赋予初始零值  编程原则：  让变量的作用域最小化 良好的函数 &#x2F; 方法设计都讲究“单一职责”，所以每个函数 &#x2F; 方法规模都不大变量声明原则：   就近原则：尽可能在靠近第一次使用变量的位置声明这个变量。 就近原则实际上也是对变量的作用域最小"><meta property="og:type" content="article"><meta property="og:title" content="【Go基础】未整理合集"><meta property="og:url" content="https://zyweven.github.io/2023/03/17/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E6%9C%AA%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86/index.html"><meta property="og:site_name" content="Even"><meta property="og:description" content="学习 go 写的笔记，后续整理一下 go 变量声明 go 语言变量声明特点：  变量类型是在后面 即使没有显式初始化，Go 语言也会给变量赋予初始零值  编程原则：  让变量的作用域最小化 良好的函数 &#x2F; 方法设计都讲究“单一职责”，所以每个函数 &#x2F; 方法规模都不大变量声明原则：   就近原则：尽可能在靠近第一次使用变量的位置声明这个变量。 就近原则实际上也是对变量的作用域最小"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zyweven.github.io/2023/03/17/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E6%9C%AA%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86/image-20230317155751372.png"><meta property="article:published_time" content="2023-03-17T07:55:00.000Z"><meta property="article:modified_time" content="2023-03-17T08:03:10.556Z"><meta property="article:author" content="even zhang"><meta property="article:tag" content="Go"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://zyweven.github.io/2023/03/17/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E6%9C%AA%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86/image-20230317155751372.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>【Go基础】未整理合集 - Even</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"zyweven.github.io",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"|",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null},gtag:null,woyaola:null,cnzz:null},search_path:"/local-search.xml",include_content_in_search:!0});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:50vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Even</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/backgroud3.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">【Go基础】未整理合集</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-03-17 15:55" pubdate>2023年3月17日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 53k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 443 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">【Go基础】未整理合集</h1><div class="markdown-body"><p>学习 go 写的笔记，后续整理一下</p><h2 id="go-变量声明"><a href="#go-变量声明" class="headerlink" title="go 变量声明"></a>go 变量声明</h2><p><img src="/2023/03/17/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E6%9C%AA%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86/image-20230317155751372.png" srcset="/img/loading.gif" lazyload></p><p>go 语言变量声明特点：</p><ul><li>变量类型是在后面</li><li>即使没有显式初始化，Go 语言也会给变量赋予初始零值</li></ul><p>编程原则：</p><ul><li>让变量的作用域最小化</li><li>良好的函数 &#x2F; 方法设计都讲究“单一职责”，所以每个函数 &#x2F; 方法规模都不大<br>变量声明原则：</li></ul><ol><li>就近原则：尽可能在靠近第一次使用变量的位置声明这个变量。<ul><li>就近原则实际上也是对变量的作用域最小化的一种实现手段。</li><li>如果一个包级变量在包内部被多处使用，那么这个变量还是放在源文件头部声明比较适合的。</li></ul></li></ol><h2 id="go-包管理"><a href="#go-包管理" class="headerlink" title="go 包管理"></a>go 包管理</h2><h4 id="Go-构建模式的演化"><a href="#Go-构建模式的演化" class="headerlink" title="Go 构建模式的演化"></a>Go 构建模式的演化</h4><p>Go 程序的构建过程就是确定包版本、编译包以及将编译后得到的目标文件链接在一起的过程。<br>演变过程：<strong>GOPATH</strong> -&gt; <strong>Vendor</strong> -&gt; <strong>GO Module</strong></p><h5 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h5><p>Go 编译器可以在本地 GOPATH 环境变量配置的路径下，搜寻 Go 程序依赖的第三方包。如果存在，就使用这个本地包进行编译；如果不存在，就会报编译错误。</p><p><strong>GOPATH 如何使用？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">如果当前的 GOPATH 为：<br>export GOPATH=/usr/local/goprojects:/home/tonybai/go<br><br>那么Go 编译器在编译 Go 程序时，就会在下面两个路径下搜索第三方依赖包是否存在：<br>/usr/local/goprojects/src/github.com/user/repo<br>/home/tonybai/go/src/github.com/user/repo<br><br>如果没有找到的话，就需要程序员使用go get来将本地缺失的第三方依赖包下载到本地<br>如：<br><span class="hljs-meta prompt_">$</span><span class="language-bash">go get github.com/sirupsen/logrus</span><br>这里的 go get 命令，不仅能将 logrus 包下载到 GOPATH 环境变量配置的目录下，它还会检查 logrus 的依赖包在本地是否存在，如果不存在，go get 也会一并将它们下载到本地。<br>但是，go get 下载的包只是那个时刻各个依赖包的最新主线版本。而依赖包是会持续演进的，这就不能保证程序的可重现的构建（Reproduceable Build）。<br></code></pre></td></tr></table></figure><h6 id="GOPATH-的问题"><a href="#GOPATH-的问题" class="headerlink" title="GOPATH 的问题"></a>GOPATH 的问题</h6><p>在 GOPATH 构建模式下，&#x3D;&#x3D;Go 编译器实质上并没有关注 Go 项目所依赖的第三方包的版本。&#x3D;&#x3D;<br>但 Go 开发者希望自己的 Go 项目所依赖的第三方包版本能受到自己的控制，而不是随意变化。于是 Go 核心开发团队引入了 Vendor 机制试图解决上面的问题。</p><h5 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h5><p>Go 在 1.5 版本中引入 vendor 机制。vendor 机制本质上就是在 Go 项目的某个特定目录下，将项目的所有依赖包缓存起来，这个特定目录名就是 vendor。<br>Go 编译器会优先感知和使用 <strong>vendor 目录</strong>下缓存的第三方包版本，而不是 GOPATH 环境变量所配置的路径下的第三方包版本。这样，无论第三方依赖包自己如何变化，无论 GOPATH 环境变量所配置的路径下的第三方包是否存在、版本是什么，都不会影响到 Go 程序的构建。<br>这样，只要将 vendor 目录和项目源码一样提交到代码仓库，那么其他开发者下载你的项目后，就可以实现可重现的构建。因此，如果使用 vendor 机制管理第三方依赖包，最佳实践就是将 vendor 一并提交到代码仓库中。<br>不过，要想开启 vendor 机制，你的 <strong>Go 项目必须位于 GOPATH 环境变量配置的某个路径的 src 目录下面</strong>。如果不满足这一路径要求，那么 Go 编译器是不会理会 Go 项目目录下的 vendor 目录的</p><h6 id="vendor-的问题"><a href="#vendor-的问题" class="headerlink" title="vendor 的问题"></a>vendor 的问题</h6><p>一方面，Go 项目必须放在 GOPATH 环境变量配置的路径下，庞大的 vendor 目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度，而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响。（感觉就像是把 vue 项目里面的 module 给一起上传到 GitHub 一样）<br>另一方面，还需要手工管理 vendor 下面的 Go 依赖包，包括项目依赖包的分析、版本的记录、依赖包获取和存放，等等。</p><h5 id="⭐Go-Module"><a href="#⭐Go-Module" class="headerlink" title="⭐Go Module"></a>⭐Go Module</h5><p>从 Go 1.11 版本开始有 Go Module<br>一个 Go Module 是一个 Go 包的集合。module 是有版本的，所以 module 下的包也就有了版本属性。这个 module 与这些包会组成一个独立的版本单元，它们一起打版本、发布和分发。<br>在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。一个 Go Module 的顶层目录下会放置一个 go. mod 文件，每个 go. mod 文件会定义唯一一个 module，它们是一一对应的关系。<br>go. mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。</p><h6 id="如何创建一个-Go-module"><a href="#如何创建一个-Go-module" class="headerlink" title="如何创建一个 Go module"></a>如何创建一个 Go module</h6><p>第一步，通过 go mod init 创建 go. mod 文件，将当前项目变为一个 Go Module；<br>第二步，通过 go mod tidy 命令自动更新当前 module 的依赖信息；<br>第三步，执行 go build，执行新 module 的构建。</p><p><font color=" #2DC26B ">指令解析：</font><br><font color=" #4f81bd ">go mod init</font><br>go mod init 会在当前项目目录下创建了一个 go. mod 文件。</p><p><font color=" #4f81bd ">go mod tidy</font><br>go mod tidy 命令会扫描 Go 源码，并自动找出项目依赖的外部 Go Module 以及版本，下载这些依赖并更新本地的 go. mod 文件。<br>执行完 go mod tidy 后，当前项目除了 go. mod 文件外，还多了一个新文件 go. sum，它同样是由 go mod 相关命令维护的一个文件，它存放了特定版本 module 内容的哈希值，它可以确保项目所依赖的 module 内容，不会被恶意或意外篡改。<br>由 go mod tidy 下载的依赖 module 会被放置在本地的 module 缓存路径下，默认值为 $GOPATH[0]&#x2F;pkg&#x2F;mod，Go 1.15 及以后版本可以通过 GOMODCACHE 环境变量，自定义本地 module 的缓存路径。</p><p><font color=" #4f81bd ">go build</font><br>go build 命令会读取 go. mod 中的依赖及版本信息，并在本地 module 缓存路径下找到对应版本的依赖 module，执行编译和链接。如果顺利的话，我们会在当前目录下看到一个新生成的可执行文件 module-mode，执行这个文件我们就能得到正确结果了。</p><h6 id="Go-Module-构建模式的特点"><a href="#Go-Module-构建模式的特点" class="headerlink" title="Go Module 构建模式的特点"></a>Go Module 构建模式的特点</h6><p>####### <strong>一、 语义导入版本”机制</strong><br>![[【Go基础】未整理合集&#x2F;Pasted image 20230209170742.png|750]]<br>如上图，语义版本号分成 3 部分：主版本号 (major)、次版本号 (minor) 和补丁版本号 (patch)。例如 logrus module 的版本号是 v1.8.1，这就表示它的主版本号为 1，次版本号为 8，补丁版本号为 1。<br>按照语义版本规范，主版本号不同的两个版本是相互不兼容的。而且，在主版本号相同的情况下，次版本号大都是向后兼容次版本号小的版本。补丁版本号也不影响兼容性。<br><strong>Go Module 规定：如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的。</strong><br>那么如果之前我们一直使用的是 logrus v1 的版本，而 logrus 发布了和 v1 不兼容的 v2 版本时我们应该使用什么方式导入 logrus v2.0.0 版本呢？<br>Go Module 创新性地给出了一个方法：<strong>将包主版本号引入到包导入路径中。</strong> 这就是 Go 的“语义导入版本”机制，也就是说<strong>通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本，这样一来我们甚至可以同时依赖一个包的两个不兼容版本</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/sirupsen/logrus&quot;</span> <span class="hljs-comment">//导入 v1</span><br>    logv2 <span class="hljs-string">&quot;github.com/sirupsen/logrus/v2&quot;</span> <span class="hljs-comment">//导入 v2</span><br>)<br></code></pre></td></tr></table></figure><p><strong>二、 最小版本选择原则</strong><br>![[【Go基础】未整理合集&#x2F;Pasted image 20230209172101.png|1000]]</p><p>在这张图中，myproject 有两个直接依赖 A 和 B，A 和 B 有一个共同的依赖包 C，但 A 依赖 C 的 v1.1.0 版本，而 B 依赖的是 C 的 v1.3.0 版本，并且此时 C 包的最新发布版为 C v1.7.0 。那么我们应该使用 C 的哪个版本？<br>对于一些其他依赖管理工具可能会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 v1.7.0。<br>而对于 <strong>Go</strong> 会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本”。<br>这个例子中，C v1.3.0 是符合项目整体要求的版本集合中的版本最小的那个，于是 <strong>Go 命令选择了 C v1.3.0</strong>，而不是最新最大的 C v1.7.0。并且，<br>Go 团队认为“最小版本选择”为 Go 程序实现持久的和可重现的构建提供了最佳的方案。<br>注意：Go Module 将 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径。</p><h6 id="Go-各版本构建模式机制和切换"><a href="#Go-各版本构建模式机制和切换" class="headerlink" title="Go 各版本构建模式机制和切换"></a>Go 各版本构建模式机制和切换</h6><p>可以通过设置 GO111MODULE 的值来进行切换。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230209172602.png|1450]]</p><h4 id="包管理实践"><a href="#包管理实践" class="headerlink" title="包管理实践"></a>包管理实践</h4><h5 id="为当前-module-添加一个依赖"><a href="#为当前-module-添加一个依赖" class="headerlink" title="为当前 module 添加一个依赖"></a>为当前 module 添加一个依赖</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">方法一<br><span class="hljs-meta prompt_">$</span><span class="language-bash">go get github.com/google/uuid  //手动添加</span><br>go: downloading github.com/google/uuid v1.3.0<br>go get: added github.com/google/uuid v1.3.0<br>方法二<br><span class="hljs-meta prompt_">$</span><span class="language-bash">go mod tidy  //自动检测</span><br>go: finding module for package github.com/google/uuid<br>go: found github.com/google/uuid in github.com/google/uuid v1.3.0<br></code></pre></td></tr></table></figure><p>手工执行 go get 新增依赖项，和执行 go mod tidy 自动分析和下载依赖项的最终效果，是等价的。但对于复杂的项目变更而言，逐一手工添加依赖项显然很没有效率，go mod tidy 是更佳的选择。</p><h5 id="升级-降级依赖的版本"><a href="#升级-降级依赖的版本" class="headerlink" title="升级 &#x2F; 降级依赖的版本"></a>升级 &#x2F; 降级依赖的版本</h5><p>以 logrus 为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">//使用一下指令可以查询logrus的多个发布版本<br><span class="hljs-meta prompt_">$</span><span class="language-bash">go list -m -versions github.com/sirupsen/logrus</span><br><br>github.com/sirupsen/logrus v0.1.0 v0.1.1 v0.2.0 v0.3.0 v0.4.0 v0.4.1 v0.5.0 v0.5.1 v0.6.0 v0.6.1 v0.6.2 v0.6.3 v0.6.4 v0.6.5 v0.6.6 v0.7.0 v0.7.1 v0.7.2 ...<br></code></pre></td></tr></table></figure><p>如果我们想从 v1.8.1 降到 v1.7.0，可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go get github.com/sirupsen/logrus@v1.7.0</span><br><br>go: downloading github.com/sirupsen/logrus v1.7.0<br>go get: downgraded github.com/sirupsen/logrus v1.8.1 =&gt; v1.7.0<br></code></pre></td></tr></table></figure><p>或者使用 go mod tidy 也可以，但是要先编辑 go mod 明确告知我们要依赖 v1.7.0 版本，而不是 v1.8.1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go mod edit -require=github.com/sirupsen/logrus@v1.7.0</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">go mod tidy</span>       <br><br>go: downloading github.com/sirupsen/logrus v1.7.0<br></code></pre></td></tr></table></figure><h5 id="添加一个主版本号大于-1-的依赖"><a href="#添加一个主版本号大于-1-的依赖" class="headerlink" title="添加一个主版本号大于 1 的依赖"></a>添加一个主版本号大于 1 的依赖</h5><p>语义导入版本机制有一个原则：如果新旧版本的包使用相同的导入路径，那么新包与旧包是兼容的。也就是说，<strong>如果新旧两个包不兼容，那么我们就应该采用不同的导入路径。</strong><br>如果我们要为 Go 项目添加主版本号大于 1 的依赖，我们就需要使用“语义导入版本”机制，在声明它的导入路径的基础上，加上版本号信息。<br>比如 redis 的导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>  _ <span class="hljs-string">&quot;github.com/go-redis/redis/v7&quot;</span> <span class="hljs-comment">// “_”为空导入</span><br>  <span class="hljs-string">&quot;github.com/google/uuid&quot;</span><br>  <span class="hljs-string">&quot;github.com/sirupsen/logrus&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  logrus.Println(<span class="hljs-string">&quot;hello, go module mode&quot;</span>)<br>  logrus.Println(uuid.NewString())<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go get github.com/go-redis/redis/v7</span><br><br>go: downloading github.com/go-redis/redis/v7 v7.4.1<br>go: downloading github.com/go-redis/redis v6.15.9+incompatible<br>go get: added github.com/go-redis/redis/v7 v7.4.1<br></code></pre></td></tr></table></figure><h5 id="升级依赖版本到一个不兼容版本"><a href="#升级依赖版本到一个不兼容版本" class="headerlink" title="升级依赖版本到一个不兼容版本"></a>升级依赖版本到一个不兼容版本</h5><p>假如我们想把 redis v7 升级到 v8<br>首先在代码中把 v7 改成 v8</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>  _ <span class="hljs-string">&quot;github. com/go-redis/redis/v8&quot;</span><br>  <span class="hljs-string">&quot;github. com/google/uuid&quot;</span><br>  <span class="hljs-string">&quot;github.com/sirupsen/logrus&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go get github.com/go-redis/redis/v8</span><br>go: downloading github.com/go-redis/redis/v8 v8.11.1<br>go: downloading github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f<br>go: downloading github.com/cespare/xxhash/v2 v2.1.1<br>go get: added github.com/go-redis/redis/v8 v8.11.1<br></code></pre></td></tr></table></figure><p>就可以了</p><h5 id="移除一个依赖"><a href="#移除一个依赖" class="headerlink" title="移除一个依赖"></a>移除一个依赖</h5><p>要想彻底从项目中移除 go. mod 中的依赖项，仅从源码中删除对依赖项的导入语句还不够。这是因为如果源码满足成功构建的条件，go build 命令是不会“多管闲事”地清理 go. mod 中多余的依赖项的。<br>那正确的做法是怎样的呢？我们还得用 go mod tidy 命令，将这个依赖项彻底从 Go Module 构建上下文中清除掉。go mod tidy 会自动分析源码依赖，而且将不再使用的依赖从 go. mod 和 go. sum 中移除。<br>也就是使用 go build 无效 而要用一次 go mod tidy 才行。</p><h5 id="特殊情况：使用-vendor"><a href="#特殊情况：使用-vendor" class="headerlink" title="特殊情况：使用 vendor"></a>特殊情况：使用 vendor</h5><p>在 Go Module 构建模式下，vendor 依旧被保留了下来，并且成为了 Go Module 构建机制的一个很好的补充。<br>特别是在一些不方便访问外部网络，并且对 Go 应用构建性能敏感的环境，比如在一些内部的持续集成或持续交付环境（CI&#x2F;CD）中，使用 vendor 机制可以实现与 Go Module 等价的构建。<br>和 GOPATH 构建模式不同，Go Module 构建模式下，我们再也无需手动维护 vendor 目录下的依赖包了，Go 提供了可以快速建立和更新 vendor 的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go mod vendor  //使用该指令</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -LF 2 vendor</span><br>vendor<br>├── github.com/<br>│   ├── google/<br>│   ├── magefile/<br>│   └── sirupsen/<br>├── golang.org/<br>│   └── x/<br>└── modules.txt<br></code></pre></td></tr></table></figure><p>go mod vendor 命令在 vendor 目录下，创建了一份这个项目的依赖包的副本，并且通过 vendor&#x2F;modules. txt 记录了 vendor 下的 module 以及版本。<br>如果我们要基于 vendor 构建，而不是基于本地缓存的 Go Module 构建，我们需要在 go build 后面加上 -mod&#x3D;vendor 参数。<br>在 Go 1.14 及以后版本中，如果 Go 项目的顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非你给 go build 传入 -mod&#x3D;mod 的参数。</p><h2 id="Go-语言的设计哲学"><a href="#Go-语言的设计哲学" class="headerlink" title="Go 语言的设计哲学"></a>Go 语言的设计哲学</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>简单是指 Go 语言特性始终保持在少且足够的水平，不走语言特性融合的道路，但又不乏生产力。简单是 Go 生产力的源泉，也是 Go 对开发者的最大吸引力；</p><h3 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h3><p>显式是指任何代码行为都需开发者明确知晓，不存在因“暗箱操作”而导致可维护性降低和不安全的结果；</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合是构建 Go 程序骨架的主要方式，它可以大幅降低程序元素间的耦合，提高程序的可扩展性和灵活性；</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发是 Go 敏锐地把握了 CPU 向多核方向发展这一趋势的结果，可以让开发人员在多核时代更容易写出充分利用系统资源、支持性能随 CPU 核数增加而自然提升的应用程序；</p><h3 id="面向工程"><a href="#面向工程" class="headerlink" title="面向工程"></a>面向工程</h3><p>面向工程是 Go 语言在语言设计上的一个重大创新，它将语言要解决的问题域扩展到那些原本并不是由编程语言去解决的领域，从而覆盖了更多开发者在开发过程遇到的“痛点”，为开发者提供了更好的使用体验。</p><h2 id="Go-程序认知"><a href="#Go-程序认知" class="headerlink" title="Go 程序认知"></a>Go 程序认知</h2><p>Go 源文件总是用<strong>全小写字母形式的短小单词命名</strong>，并且以. go 扩展名结尾。<br>如果要在源文件的名字中使用多个单词，我们通常直接是将多个单词连接起来作为源文件名，而不是使用其他分隔符，比如下划线。也就是说，我们通常使用 <strong>helloworld. go</strong> 作为文件名而不是 hello_world. go。这是因为下划线这种分隔符，在 Go 源文件命名中有特殊作用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;hello, world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个 main，main 包在 Go 中是一个特殊的包，整个 Go 程序中仅允许存在一个名为 main 的包。<br>包是 Go 语言的基本组成单元，通常使用单个的小写单词命名，一个 Go 程序本质上就是一组包的集合。<br>Go 语言内置了一套 Go 社区约定俗称的代码风格，并随安装包提供了一个名为 Gofmt 的工具，这个工具可以帮助你将代码自动格式化为约定的风格。作为 Go 开发人员，请在提交你的代码前使用 Gofmt 格式化你的 Go 源码。<br><strong>注意：</strong></p><ul><li>import “fmt” 一行中“fmt”代表的是<strong>包的导入路径</strong>（Import），它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包；通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的“fmt”指的是包名，其实并不是这样的。</li><li>fmt. Println 函数调用一行中的“fmt”代表的则是包名。<br>main 包是不可以像标准库 fmt 包那样被导入（Import）<br>Go 源码文件本身采用的是 Unicode 字符集，而且用的是 UTF-8 标准的字符编码方式，这与编译后的程序所运行的环境所使用的字符集和字符编码方式是一致的。</li></ul><p>Go 是一种编译型语言，这意味着只有你编译完 Go 程序之后，才可以将生成的可执行文件交付于其他人，并运行在没有安装 Go 的环境中。<br>而如果你交付给其他人的是一份. rb、. py 或. js 的动态语言的源文件，那么他们的目标环境中就必须要拥有对应的 Ruby、Python 或 JavaScript 实现才能解释执行这些源文件。</p><h2 id="Go-项目布局"><a href="#Go-项目布局" class="headerlink" title="Go 项目布局"></a>Go 项目布局</h2><h3 id="Go-语言项目自身的最初源码结构布局"><a href="#Go-语言项目自身的最初源码结构布局" class="headerlink" title="Go 语言项目自身的最初源码结构布局"></a>Go 语言项目自身的最初源码结构布局</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">cd</span> go // 进入 Go 语言项目根目录</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">git checkout go1.3 // 切换到go 1.3版本</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -LF 1 ./src // 查看src目录下的结构布局</span><br>./src<br>├── all.bash*<br>├── clean.bash*<br>├── cmd/<br>├── make.bash*<br>├── Make.dist<br>├── pkg/<br>├── race. bash*<br>├── run.bash*<br>... ...<br>└── sudo.bash*<br></code></pre></td></tr></table></figure><p>src 目录下面的结构有这三个特点。<br>首先，你可以看到，以 all. bash 为代表的代码构建的脚本源文件放在了 src 下面的顶层目录下。<br>第二，src 下的二级目录 cmd 下面存放着 Go 相关可执行文件的相关目录。<br>第三个特点， src 下的二级目录 pkg 下面存放着运行时实现、标准库包实现，这些包既可以被上面 cmd 下各程序所导入，也可以被 Go 语言项目之外的 Go 程序依赖并导入。<br>如今，这个布局经过了很多演进。<br><strong>演进一：Go 1.4 版本删除 pkg 这一中间层目录并引入 internal 目录</strong><br><strong>演进二：Go1.6 版本增加 vendor 目录</strong><br><strong>演进三：Go 1.13 版本引入 go. mod 和 go. sum</strong></p><h3 id="现在的-Go-项目的典型结构布局"><a href="#现在的-Go-项目的典型结构布局" class="headerlink" title="现在的 Go 项目的典型结构布局"></a>现在的 Go 项目的典型结构布局</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -F exe-layout</span> <br>exe-layout<br>├── cmd/<br>│   ├── app1/<br>│   │   └── main.go<br>│   └── app2/<br>│       └── main.go<br>├── go.mod<br>├── go.sum<br>├── internal/<br>│   ├── pkga/<br>│   │   └── pkg_a.go<br>│   └── pkgb/<br>│       └── pkg_b.go<br>├── pkg1/<br>│   └── pkg1.go<br>├── pkg2/<br>│   └── pkg2.go<br>└── vendor/<br></code></pre></td></tr></table></figure><h4 id="cmd-目录"><a href="#cmd-目录" class="headerlink" title="cmd 目录"></a><strong>cmd 目录</strong></h4><p>cmd 目录存放项目要编译构建的可执行文件对应的 main 包的源文件。如果你的项目中有多个可执行文件需要构建，每个可执行文件的 main 包单独放在一个子目录中，比如图中的 app1、app2，cmd 目录下的各 app 的 main 包将整个项目的依赖连接在一起。<br>通常来说，main 包应该很简洁。我们在 main 包中会做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象。另外，也有一些 Go 项目将 cmd 这个名字改为 app 或其他名字，但它的功能其实并没有变。</p><h4 id="pkgN-目录"><a href="#pkgN-目录" class="headerlink" title="pkgN 目录"></a><strong>pkgN 目录</strong></h4><p>pkgN 目录，这是一个存放项目自身要使用、同样也是可执行文件对应 main 包所要依赖的库文件，同时这些目录下的包还可以被外部项目引用。</p><h4 id="internal-目录"><a href="#internal-目录" class="headerlink" title="internal 目录"></a><strong>internal 目录</strong></h4><p>internal 目录下的 Go 包，只可以被本项目内部的包导入。项目外部是无法导入这个 internal 目录下面的包。</p><h4 id="go-mod-和-go-sum"><a href="#go-mod-和-go-sum" class="headerlink" title="go. mod 和 go. sum"></a><strong>go. mod 和 go. sum</strong></h4><p>们是 Go 语言包依赖管理使用的配置文件。</p><h4 id="vendor-目录"><a href="#vendor-目录" class="headerlink" title="vendor 目录"></a><strong>vendor 目录</strong></h4><p>vendor 目录可以视为一个可选目录。因为大多数项目使用 Go Module 构建。</p><h2 id="多-module-的目录"><a href="#多-module-的目录" class="headerlink" title="多 module 的目录"></a>多 module 的目录</h2><p>如果非要在一个代码仓库中存放多个 module，可以用如下的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree multi-modules</span><br>multi-modules<br>├── go.mod // mainmodule<br>├── module1<br>│   └── go.mod // module1<br>└── module2<br>    └── go.mod // module2<br></code></pre></td></tr></table></figure><h3 id="Go-可执行程序项目的典型布局-和早期布局"><a href="#Go-可执行程序项目的典型布局-和早期布局" class="headerlink" title="Go 可执行程序项目的典型布局 和早期布局"></a>Go 可执行程序项目的典型布局 和早期布局</h3><p>如果 Go 可执行程序项目有一个且只有一个可执行程序要构建:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -F -L 1 single-exe-layout</span><br>single-exe-layout<br>├── go.mod<br>├── internal/<br>├── main.go<br>├── pkg1/<br>├── pkg2/<br>└── vendor/<br></code></pre></td></tr></table></figure><p>早期布局:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -L 3 -F early-project-layout</span><br>early-project-layout<br>└── exe-layout/<br>    ├── cmd/<br>    │   ├── app1/<br>    │   └── app2/<br>    ├── go.mod<br>    ├── internal/<br>    │   ├── pkga/<br>    │   └── pkgb/<br>    ├── pkg/<br>    │   ├── pkg1/<br>    │   └── pkg2/<br>    └── vendor/<br></code></pre></td></tr></table></figure><p>原本放在项目顶层目录下的 pkg1 和 pkg2 公共包被统一聚合到 pkg 目录下了。而且，这种早期 Go 可执行程序项目的典型布局在 Go 社区内部也不乏受众，很多新建的 Go 项目依然采用这样的项目布局。</p><h3 id="Go-库项目的典型结构布局"><a href="#Go-库项目的典型结构布局" class="headerlink" title="Go 库项目的典型结构布局"></a>Go 库项目的典型结构布局</h3><p>Go 库项目仅对外暴露 Go 包，这类项目的典型布局形式是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -F lib-layout</span> <br>lib-layout<br>├── go.mod<br>├── internal/<br>│   ├── pkga/<br>│   │   └── pkg_a.go<br>│   └── pkgb/<br>│       └── pkg_b.go<br>├── pkg1/<br>│   └── pkg1.go<br>└── pkg2/<br>    └── pkg2.go<br></code></pre></td></tr></table></figure><p>库类型项目相比于 Go 可执行程序项目的布局要简单一些。因为这类项目不需要构建可执行程序，所以去除了 cmd 目录。<br>而且，在这里，vendor 也不再是可选目录了。对于库类型项目而言，我们并不推荐在项目中放置 vendor 目录去缓存库自身的第三方依赖，库项目仅通过 go. mod 文件明确表述出该项目依赖的 module 或包以及版本要求就可以了。<br>Go 库项目的初衷是为了对外部（开源或组织内部公开）暴露 API，对于仅限项目内部使用而不想暴露到外部的包，可以放在项目顶层的 internal 目录下面。当然 internal 也可以有多个并存在于项目结构中的任一目录层级中，关键是项目结构设计人员要明确各级 internal 包的应用层次和范围。</p><p>对于有一个且仅有一个包的 Go 库项目来说，可以将上面的布局做进一步简化，简化的布局如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -L 1 -F single-pkg-lib-layout</span><br>single-pkg-lib-layout<br>├── feature1. go<br>├── feature2. go<br>├── go.mod<br>└── internal/<br></code></pre></td></tr></table></figure><p>简化后，我们将这唯一包的所有源文件放置在项目的顶层目录下（比如上面的 feature1. go 和 feature2. go），其他布局元素位置和功用不变。</p><h2 id="Go-程序执行次序"><a href="#Go-程序执行次序" class="headerlink" title="Go 程序执行次序"></a>Go 程序执行次序</h2><p>在一个 go 文件内，按照“常量 -&gt; 变量 -&gt; init 函数-&gt; main 函数”的顺序进行初始化。<br>如果有其他包的话，就是“其他 pkg 包-&gt; 常量 -&gt; 变量 -&gt; init 函数-&gt; main 函数”。</p><h3 id="main-main-函数：Go-应用的入口函数"><a href="#main-main-函数：Go-应用的入口函数" class="headerlink" title="main. main 函数：Go 应用的入口函数"></a>main. main 函数：Go 应用的入口函数</h3><p>Go 语言中有一个特殊的函数：main 包中的 main 函数，也就是 main. main，它是所有 Go 可执行程序的用户层执行逻辑的入口函数。Go 程序在用户层面的执行逻辑，会在这个函数内按照它的调用顺序展开。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 用户层执行逻辑</span><br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>可执行程序的 main 包必须定义 main 函数，否则 Go 编译器会报错。在启动了多个 Goroutine（Go 语言的轻量级用户线程）的 Go 应用中，main. main 函数将在 Go 应用的主 Goroutine 中执行。<br>在多 Goroutine 的 Go 应用中，相较于 main. main 作为 Go 应用的入口，main. main 函数返回的意义其实更大，因为 main 函数返回就意味着整个 Go 程序的终结，而且你也不用管这个时候是否还有其他子 Goroutine 正在执行。<br>除了 main 包外，<strong>其他包也可以拥有自己的名为 main 的函数或方法</strong>。但按照 Go 的可见性规则（小写字母开头的标识符为非导出标识符），非 main 包中自定义的 main 函数仅限于包内使用。</p><h3 id="init-函数：Go-包的初始化函数"><a href="#init-函数：Go-包的初始化函数" class="headerlink" title="init 函数：Go 包的初始化函数"></a>init 函数：Go 包的初始化函数</h3><p>init 函数：进行包的初始化。<br>和 main. main 函数一样，init 函数也是一个无参数无返回值的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 包初始化逻辑</span><br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>main 函数不一定是用户层第一个被执行的函数，因为，如果 main 包依赖的包中定义了 init 函数，或者是 main 包自身定义了 init 函数，那么 Go 程序在这个包初始化的时候，就会自动调用它的 init 函数，因此这些 init 函数的执行就都会发生在 main 函数之前。<br>并且在 Go 程序中我们不能手工显式地调用 init，否则就会收到编译错误，init 函数会在运行时自动执行。<br>Go 包可以拥有不止一个 init 函数，每个组成 Go 包的 Go 源文件中，也可以定义多个 init 函数。<br>在初始化 Go 包时，Go 会按照一定的次序，逐一、顺序地调用这个包的 init 函数。一般来说，先传递给 Go 编译器的源文件中的 init 函数，会先被执行；而同一个源文件中的多个 init 函数，会按声明顺序依次执行。当我们要在 main. main 函数执行之前，执行一些函数或语句的时候，我们只需要将它放入 init 函数中就可以了。</p><h3 id="Go-包的初始化次序"><a href="#Go-包的初始化次序" class="headerlink" title="Go 包的初始化次序"></a>Go 包的初始化次序</h3><p>Go 包是程序逻辑封装的基本单元，每个包都可以理解为是一个“自治”的、封装良好的、对外部暴露有限接口的基本单元。一个 Go 程序就是由一组包组成的，程序的初始化就是这些包的初始化。每个 Go 包还会有自己的依赖包、常量、变量、init 函数（其中 main 包有 main 函数）等。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230209214825.png]]<br>上图程序的初始化步骤：<br>首先，main 包依赖 pkg1 和 pkg4 两个包，所以第一步，<strong>Go 会根据包导入的顺序</strong>，先去初始化 main 包的第一个依赖包 pkg1。<br>第二步，Go 在进行包初始化的过程中，会采用“深度优先”的原则，递归初始化各个包的依赖包。在上图里，pkg1 包依赖 pkg2 包，pkg2 包依赖 pkg3 包，pkg3 没有依赖包，于是 Go 在 pkg3 包中按照“常量 -&gt; 变量 -&gt; init 函数”的顺序先对 pkg3 包进行初始化；<br>在 pkg3 包初始化完毕后，Go 会回到 pkg2 包并对 pkg2 包进行初始化，接下来再回到 pkg1 包并对 pkg1 包进行初始化。在调用完 pkg1 包的 init 函数后，Go 就完成了 main 包的第一个依赖包 pkg1 的初始化。<br>接下来，Go 会初始化 main 包的第二个依赖包 pkg4，pkg4 包的初始化过程与 pkg1 包类似，也是先初始化它的依赖包 pkg5，然后再初始化自身；<br>然后，当 Go 初始化完 pkg4 包后也就完成了对 main 包所有依赖包的初始化，接下来初始化 main 包自身。<br>最后，在 main 包中，Go 同样会按照“常量 -&gt; 变量 -&gt; init 函数”的顺序进行初始化，执行完这些初始化工作后才正式进入程序的入口函数 main 函数。</p><p>另外一个例子：</p><ul><li>main 包依赖 pkg1 包和 pkg2 包；</li><li>pkg1 包和 pkg2 包都依赖 pkg3 包。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go run main.go</span><br>//首先初始化最深层的pkg3 包<br>pkg3: const c has been initialized  //初始化常量<br>pkg3: var v has been initialized    //初始化变量<br>pkg3: init func invoked             //初始化init函数<br>//然后按顺序依次初始化 pkg1 包和 pkg2 包<br>pkg1: const c has been initialized  //初始化常量<br>pkg1: var v has been initialized<br>pkg1: init func invoked<br>pkg2: const c has been initialized<br>pkg2: var v has been initialized<br>pkg2: init func invoked<br>//然后开始初始化这个程序<br>main: const c1 has been initialized<br>main: const c2 has been initialized<br>main: var v1 has been initialized<br>main: var v2 has been initialized<br>main: first init func invoked<br>main: second init func invoked<br></code></pre></td></tr></table></figure><p>pkg1 包和 pkg2 包都依赖 pkg3 包，但根据 Go 语言规范，<strong>一个被多个包依赖的包仅会初化一次</strong>，因此这里的 pkg3 包仅会被初始化了一次。</p><p>同一个包内有多个源文件的话，go 会先按文件传入顺序，分别初始化常量与变量，然后在分别调用各个文件中的 init 函数。比如说如果一个 pkg1 有两个文件 file1. go 和 file2. go，那么初始化顺序是：file1 中的常量 -&gt; file1 中的变量 -&gt; file2 中常量 -&gt; file2 中变量 -&gt; file1 中 init 函数 -&gt; file2 中 init 函数。</p><p>&#x3D;&#x3D;<strong>简而言之，就这三点：</strong>&#x3D;&#x3D;</p><ul><li>依赖包按“深度优先”的次序进行初始化；</li><li>每个包内按以“包级常量 -&gt; 包级变量 -&gt; init 函数”的顺序进行初始化；</li><li>包内的多个 init 函数按出现次序进行自动调用。</li><li></li></ul><h3 id="init-函数的用途"><a href="#init-函数的用途" class="headerlink" title="init 函数的用途"></a>init 函数的用途</h3><p>Go 包初始化时，init 函数的初始化次序在变量之后，这给了开发人员在 init 函数中对包级变量进行进一步检查与操作的机会。</p><h4 id="常用用途-1：重置包级变量值"><a href="#常用用途-1：重置包级变量值" class="headerlink" title="常用用途 1：重置包级变量值"></a>常用用途 1：重置包级变量值</h4><p>init 函数就好比 Go 包真正投入使用之前唯一的“质检员”，负责对包内部以及暴露到外部的包级数据（主要是包级变量）的初始状态进行检查。<br>？这部分不是太明白</p><h4 id="常用用途-2：实现对包级变量的复杂初始化"><a href="#常用用途-2：实现对包级变量的复杂初始化" class="headerlink" title="常用用途 2：实现对包级变量的复杂初始化"></a>常用用途 2：实现对包级变量的复杂初始化</h4><p>有些包级变量需要一个比较复杂的初始化过程，有些时候，使用它的类型零值（每个 Go 类型都具有一个零值定义）或通过简单初始化表达式不能满足业务逻辑要求，而 init 函数则非常适合完成此项工作，标准库 http 包中就有这样一个典型示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    http2VerboseLogs    <span class="hljs-type">bool</span> <span class="hljs-comment">// 初始化时默认值为false</span><br>    http2logFrameWrites <span class="hljs-type">bool</span> <span class="hljs-comment">// 初始化时默认值为false</span><br>    http2logFrameReads  <span class="hljs-type">bool</span> <span class="hljs-comment">// 初始化时默认值为false</span><br>    http2inTests        <span class="hljs-type">bool</span> <span class="hljs-comment">// 初始化时默认值为false</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    e := os.Getenv(<span class="hljs-string">&quot;GODEBUG&quot;</span>)<br>    <span class="hljs-keyword">if</span> strings.Contains(e, <span class="hljs-string">&quot;http2debug=1&quot;</span>) &#123;<br>        http2VerboseLogs = <span class="hljs-literal">true</span> <span class="hljs-comment">//在init中对http2VerboseLogs的值进行重置</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> strings.Contains(e, <span class="hljs-string">&quot;http2debug=2&quot;</span>) &#123;<br>        http2VerboseLogs = <span class="hljs-literal">true</span> <span class="hljs-comment">//在init中对http2VerboseLogs的值进行重置</span><br>        http2logFrameWrites = <span class="hljs-literal">true</span> <span class="hljs-comment">//在 init 中对 http2logFrameWrites 的值进行重置</span><br>        http2logFrameReads = <span class="hljs-literal">true</span> <span class="hljs-comment">//在init中对http2logFrameReads的值进行重置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>标准库 http 包 (也就是上面这段代码) 定义了一系列布尔类型的特性开关变量，它们默认处于关闭状态（即值为 false），但我们可以通过 GODEBUG 环境变量的值，开启相关特性开关。<br>可是这样一来，简单地将这些变量初始化为类型零值，就不能满足要求了，所以 http 包在 init 函数中，就根据环境变量 GODEBUG 的值，对这些包级开关变量进行了复杂的初始化，从而保证了这些开关变量在 http 包完成初始化后，可以处于合理状态。</p><h4 id="常用用途-3-在-init-函数中实现“注册模式”"><a href="#常用用途-3-在-init-函数中实现“注册模式”" class="headerlink" title="常用用途 3 在 init 函数中实现“注册模式”"></a>常用用途 3 在 init 函数中实现“注册模式”</h4><p>注册器模式是一种基础常见的设计模式，它的主要意思是把多个类的实例注册到一个注册器类中去，然后需要哪个类，由这个注册器类统一调取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;image&quot;</span><br>    _ <span class="hljs-string">&quot;image/gif&quot;</span> <span class="hljs-comment">// 以空导入方式注入gif图片格式驱动</span><br>    _ <span class="hljs-string">&quot;image/jpeg&quot;</span> <span class="hljs-comment">// 以空导入方式注入jpeg图片格式驱动</span><br>    _ <span class="hljs-string">&quot;image/png&quot;</span> <span class="hljs-comment">// 以空导入方式注入png图片格式驱动</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 支持png, jpeg, gif</span><br>    width, height, err := imageSize(os.Args[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 获取传入的图片文件的宽与高</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;get image size error:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;image size: [%d, %d]\n&quot;</span>, width, height)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">imageSize</span><span class="hljs-params">(imageFile <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    f, _ := os.Open(imageFile) <span class="hljs-comment">// 打开图文文件</span><br>    <span class="hljs-keyword">defer</span> f.Close()<br><br>    img, _, err := image.Decode(f) <span class="hljs-comment">// 对文件进行解码，得到图片实例</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, err<br>    &#125;<br><br>    b := img.Bounds() <span class="hljs-comment">// 返回图片区域</span><br>    <span class="hljs-keyword">return</span> b.Max.X, b.Max.Y, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个示例程序支持 png、jpeg、gif 三种格式的图片，而达成这一目标的原因，正是 image&#x2F;png、image&#x2F;jpeg 和 image&#x2F;gif 包都在各自的 init 函数中，将自己“注册”到 image 的支持格式列表中了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// $GOROOT/src/image/png/reader.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    image.RegisterFormat(<span class="hljs-string">&quot;png&quot;</span>, pngHeader, Decode, DecodeConfig)<br>&#125;<br><br><span class="hljs-comment">// $GOROOT/src/image/jpeg/reader.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    image.RegisterFormat(<span class="hljs-string">&quot;jpeg&quot;</span>, <span class="hljs-string">&quot;\xff\xd8&quot;</span>, Decode, DecodeConfig)<br>&#125;<br><br><span class="hljs-comment">// $GOROOT/src/image/gif/reader.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span> <span class="hljs-params">()</span></span> &#123;<br>    image.RegisterFormat(<span class="hljs-string">&quot;gif&quot;</span>, <span class="hljs-string">&quot;GIF8?a&quot;</span>, Decode, DecodeConfig)<br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="当-init-函数在检查包数据初始状态时遇到失败或错误的情况，我们该如何处理呢？"><a href="#当-init-函数在检查包数据初始状态时遇到失败或错误的情况，我们该如何处理呢？" class="headerlink" title="当 init 函数在检查包数据初始状态时遇到失败或错误的情况，我们该如何处理呢？"></a>当 init 函数在检查包数据初始状态时遇到失败或错误的情况，我们该如何处理呢？</h3><p>要分情况而定</p><ol><li>初始化失败的是必要的数据 panic 处理 结束进程</li><li>初始化失败的是对业务没影响，可成功可失败的 输出 warn 或 error 日志 方便定位</li></ol><h2 id="Go-变量声明"><a href="#Go-变量声明" class="headerlink" title="Go 变量声明"></a>Go 变量声明</h2><p>在编程语言中，为了方便操作内存特定位置的数据，我们用一个特定的名字与位于特定位置的内存块绑定在一起，这个名字被称为<strong>变量</strong>。而变量所绑定的内存区域是要有一个<strong>明确的边界</strong>的。</p><p><font color=" #9bbb59 ">编程语言的编译器或解释器是如何知道一个变量所能引用的内存区域边界呢？</font><br><strong>动态语言</strong>和<strong>静态语言</strong>有不同的处理方式。<br>动态语言（比如 Python、Ruby 等）的解释器可以在运行时通过对变量赋值的分析，自动确定变量的边界。并且在动态语言中，一个变量可以在运行时被赋予大小不同的边界。<br>而静态编程语言在这方面的“体验略差”。静态类型语言编译器必须明确知道一个变量的边界才允许使用这个变量，但静态语言编译器又没能力自动提供这个信息，这个边界信息必须由这门语言的使用者提供，于是就有了“<strong>变量声明</strong>”。通过变量声明，语言使用者可以显式告知编译器一个变量的边界信息。在具体实现层面呢，这个边界信息由变量的<strong>类型属性</strong>赋予。<br>作为身处静态编程语言阵营的 Go 语言，它沿袭了静态语言的这一要求：使用变量之前需要先进行变量声明。<br>也就是对于静态语言，用户想要使用一个变量，需要使用<strong>变量声明</strong>来告知编译器变量所能引用的内存区域边界，而变量的边界信息又是由<strong>类型属性</strong>提供。</p><h3 id="Go-语言的变量声明方法"><a href="#Go-语言的变量声明方法" class="headerlink" title="Go 语言的变量声明方法"></a>Go 语言的变量声明方法</h3><p>![[【Go基础】未整理合集&#x2F;Pasted image 20230210131449.png|800]]<br>这个变量声明分为四个部分：</p><ul><li>var 是修饰变量声明的关键字；</li><li>a 为变量名；</li><li>int 为该变量的类型；</li><li>10 是变量的初值。<br>在 Go 语言中，无论什么类型的变量，都可以使用这种形式进行变量声明。如果没有显式的为变量赋予初值，<strong>Go 编译器会自动为变量赋予这个类型的零值，也就是这个类型的默认值</strong>。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230210131732.png]]<br>另外，像数组、结构体这样复合类型变量的零值就是它们组成元素都为零值时的结果。</li></ul><p>Go 语言还提供了变量声明块（block）的语法形式，可以用一个 var 关键字将多个变量声明放在一起:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    a <span class="hljs-type">int</span> = <span class="hljs-number">128</span><br>    b <span class="hljs-type">int8</span> = <span class="hljs-number">6</span><br>    s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello&quot;</span><br>    c <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;A&#x27;</span><br>    t <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br>)<br></code></pre></td></tr></table></figure><p>Go 语言还支持在一行变量声明中同时声明多个变量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b, c <span class="hljs-type">int</span> = <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>上面两种声明方式也可以组合到一起</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    a, b, c <span class="hljs-type">int</span> = <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span><br>    c, d, e <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span><br>) <br></code></pre></td></tr></table></figure><h3 id="Go-的两种变量声明语法糖"><a href="#Go-的两种变量声明语法糖" class="headerlink" title="Go 的两种变量声明语法糖"></a>Go 的两种变量声明语法糖</h3><h4 id="1-省略类型信息的声明"><a href="#1-省略类型信息的声明" class="headerlink" title="1. 省略类型信息的声明"></a>1. 省略类型信息的声明</h4><p>在通用的变量声明的基础上，Go 编译器允许我们省略变量声明中的类型信息，它的标准范式是<br>“<strong>var varName &#x3D; initExpression</strong>”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = <span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><p><strong>Go 编译器在遇到这样的变量声明后是如何确定变量的类型信息呢？</strong><br>Go 编译器会根据右侧变量初值自动推导出变量的类型，并给这个变量赋予初值所对应的默认类型。比如，整型值的默认类型 int，浮点值的默认类型为 float64，复数值的默认类型为 complex128，布尔值的默认类型只能是 bool，字符值默认类型只能是 rune，字符串值的默认类型只能是 string 等。<br>这种省略类型信息声明的“语法糖”<strong>仅适用于在变量声明的同时显式赋予变量初值的情况</strong>，下面这种没有初值的声明形式是不被允许的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b<br></code></pre></td></tr></table></figure><p>结合多变量声明，我们可以使用这种变量声明“语法糖”声明多个不同类型的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b, c = <span class="hljs-number">12</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>在这个变量声明中，我们声明了三个变量 a、b 和 c，但它们分别具有不同的类型，分别为 int、rune 和 string。</p><p>如果我们不接受默认类型，而是要显式地为变量指定类型，除了通用的声明形式，我们还可以通过显式类型转型达到我们的目的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = <span class="hljs-type">int32</span>(<span class="hljs-number">13</span>) <span class="hljs-comment">//但是这种方式和正常的变量声明就区别不大了</span><br></code></pre></td></tr></table></figure><h4 id="2-短变量声明"><a href="#2-短变量声明" class="headerlink" title="2. 短变量声明"></a>2. 短变量声明</h4><p>Go 语言还为我们提供了最简化的变量声明形式：短变量声明。可以省去 var 关键字以及类型信息，它的标准范式是“<strong>varName :&#x3D; initExpression</strong>”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">12</span><br>b := <span class="hljs-string">&#x27;A&#x27;</span><br>c := <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>短变量声明也支持一次声明多个变量，而且形式更为简洁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a, b, c := <span class="hljs-number">12</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>但是，并不是所有变量都能用短变量声明来声明的。</p><h3 id="如何使用声明（何时用何种声明）"><a href="#如何使用声明（何时用何种声明）" class="headerlink" title="如何使用声明（何时用何种声明）"></a>如何使用声明（何时用何种声明）</h3><p><strong>Go 语言的两类变量</strong>：包级变量和局部变量</p><h4 id="包级变量-package-varible"><a href="#包级变量-package-varible" class="headerlink" title="包级变量 (package varible)"></a>包级变量 (package varible)</h4><p>在包级别可见的变量。如果是导出变量（大写字母开头），那么这个包级变量也可以被视为全局变量。</p><h5 id="包级变量的声明形式"><a href="#包级变量的声明形式" class="headerlink" title="包级变量的声明形式"></a>包级变量的声明形式</h5><p>包级变量只能使用带有 var 关键字的变量声明形式，<strong>不能使用短变量声明形式</strong>，但在形式细节上可以有一定灵活度。而这个灵活度从“<strong>变量声明时是否延迟初始化</strong>”这个角度来考虑。</p><h6 id="第一类：声明并同时显式初始化"><a href="#第一类：声明并同时显式初始化" class="headerlink" title="第一类：声明并同时显式初始化"></a>第一类：声明并同时显式初始化</h6><p>如果能够接受默认的类型，多使用省略类型信息的声明方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> varName = initExpression<br></code></pre></td></tr></table></figure><p>而如果不接受默认类型，则要显式地为包级变量指定类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//第一种：</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">13</span> <span class="hljs-comment">// 使用默认类型</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int32</span> = <span class="hljs-number">17</span>  <span class="hljs-comment">// 显式指定类型</span><br><span class="hljs-keyword">var</span> f <span class="hljs-type">float32</span> = <span class="hljs-number">3.14</span> <span class="hljs-comment">// 显式指定类型</span><br><br><span class="hljs-comment">//第二种：</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">13</span> <span class="hljs-comment">// 使用默认类型</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-type">int32</span>(<span class="hljs-number">17</span>) <span class="hljs-comment">// 显式指定类型</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-type">float32</span> (<span class="hljs-number">3.14</span>) <span class="hljs-comment">// 显式指定类型</span><br></code></pre></td></tr></table></figure><p>Go 更推荐我们使用第二种，这样能统一接受默认类型和显式指定类型这两种声明形式，方便浏览。</p><h6 id="第二类：声明但延迟初始化"><a href="#第二类：声明但延迟初始化" class="headerlink" title="第二类：声明但延迟初始化"></a>第二类：声明但延迟初始化</h6><p>对于声明时并不立即显式初始化的包级变量，使用通用变量声明形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span><br><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span><br></code></pre></td></tr></table></figure><h5 id="声明的聚类与就近原则"><a href="#声明的聚类与就近原则" class="headerlink" title="声明的聚类与就近原则"></a>声明的聚类与就近原则</h5><h6 id="聚类原则"><a href="#聚类原则" class="headerlink" title="聚类原则"></a>聚类原则</h6><p>声明聚类可以提升代码可读性。<br>将同一类的变量声明放在一个 var 变量声明块中，不同类的声明放在不同的 var 声明块中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net. go</span><br><span class="hljs-keyword">var</span> (<br>    netGo  <span class="hljs-type">bool</span> <br>    netCgo <span class="hljs-type">bool</span> <br>)<br><br><span class="hljs-keyword">var</span> (<br>    aLongTimeAgo = time.Unix(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>    noDeadline = time.Time&#123;&#125;<br>    noCancel   = (<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)(<span class="hljs-literal">nil</span>)<br>)<br></code></pre></td></tr></table></figure><p>将延迟初始化的变量声明放在一个 var 声明块 (比如上面的第一个 var 声明块)，然后将声明且显式初始化的变量放在另一个 var 块中（比如上面的第二个 var 声明块）</p><h6 id="就近原则"><a href="#就近原则" class="headerlink" title="就近原则"></a>就近原则</h6><p>就近原则是对变量的作用域最小化的一种实现手段。<br>尽可能在靠近第一次使用变量的位置声明这个变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/request.go</span><br><br><span class="hljs-keyword">var</span> ErrNoCookie = errors.New(<span class="hljs-string">&quot;http: named cookie not present&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Request)</span></span> Cookie(name <span class="hljs-type">string</span>) (*Cookie, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> readCookies(r.Header, name) &#123;<br>        <span class="hljs-keyword">return</span> c, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrNoCookie<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码块，ErrNoCookie 这个变量在整个包中仅仅被用在了 Cookie 方法中，因此它被声明在紧邻 Cookie 方法定义的地方。当然了，<strong>如果一个包级变量在包内部被多处使用，那么这个变量还是放在源文件头部声明比较适合</strong>的。</p><h4 id="局部变量-local-varible"><a href="#局部变量-local-varible" class="headerlink" title="局部变量 (local varible)"></a>局部变量 (local varible)</h4><p>Go 函数或方法体内声明的变量，仅在函数或方法体内可见。</p><h5 id="局部变量的声明形式"><a href="#局部变量的声明形式" class="headerlink" title="局部变量的声明形式"></a>局部变量的声明形式</h5><p>和包级变量相比，局部变量又多了一种<strong>短变量声明</strong>形式，这是局部变量特有的一种变量声明形式，也是局部变量采用最多的一种声明形式。</p><h6 id="第一类：对于延迟初始化的局部变量声明，我们采用通用的变量声明形式"><a href="#第一类：对于延迟初始化的局部变量声明，我们采用通用的变量声明形式" class="headerlink" title="第一类：对于延迟初始化的局部变量声明，我们采用通用的变量声明形式"></a>第一类：对于延迟初始化的局部变量声明，我们采用通用的变量声明形式</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><h6 id="第二类：对于声明且显式初始化的局部变量，建议使用短变量声明形式"><a href="#第二类：对于声明且显式初始化的局部变量，建议使用短变量声明形式" class="headerlink" title="第二类：对于声明且显式初始化的局部变量，建议使用短变量声明形式"></a>第二类：对于声明且显式初始化的局部变量，建议使用短变量声明形式</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">17</span><br>f := <span class="hljs-number">3.14</span><br>s := <span class="hljs-string">&quot;hello, gopher!&quot;</span><br></code></pre></td></tr></table></figure><p>对于不接受默认类型的变量，我们依然可以使用短变量声明形式，只是在”:&#x3D;”右侧要做一个显式转型，以保持声明的一致性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-type">int32</span>(<span class="hljs-number">17</span>)<br>f := <span class="hljs-type">float32</span>(<span class="hljs-number">3.14</span>)<br>s := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;hello, gopher!&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>注意：尽量在分支控制时使用短变量声明形式，让变量的作用域最小化。</strong></p><p>虽然良好的函数 &#x2F; 方法设计都讲究“单一职责”，所以每个函数 &#x2F; 方法规模都不大，很少需要应用 var 块来聚类声明局部变量，但是如果你在声明局部变量时遇到了适合聚类的应用场景，也应该毫不犹豫地使用 var 声明块来声明多于一个的局部变量。</p><p><font color=" #76923c ">Go 语言的变量声明形式与其他主流静态语言有一个显著的差异，那就是它将变量名放在了类型的前面。这样做有什么好处呢？</font><br>为了提高代码可读性，和 C 相比，在当参数是指针的复杂情况下，这种声明格式会相对好理解一点，方便辨析指针类型。<br><a target="_blank" rel="noopener" href="https://go.dev/blog/declaration-syntax">Go’s Declaration Syntax - The Go Programming Language</a></p><h2 id="代码块与作用域"><a href="#代码块与作用域" class="headerlink" title="代码块与作用域"></a>代码块与作用域</h2><p>变量遮蔽（Variable Shadowing）是 Go 开发人员在日常开发工作中最容易犯的编码错误之一，它低级又不容易查找，常常会让你陷入漫长的调试过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//变量遮蔽的例子</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">11</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>  a := <span class="hljs-number">1</span><br>  a += n<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;a =&quot;</span>, a) <span class="hljs-comment">// 11</span><br>  foo(<span class="hljs-number">5</span>)<br>  fmt.Println(<span class="hljs-string">&quot;after calling foo, a =&quot;</span>, a) <span class="hljs-comment">// 11</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，函数 foo 调用前后，包级变量 a 的值都没有发生变化。这是因为，虽然 foo 函数中也使用了变量 a，但是 foo 函数中的变量 a 遮蔽了外面的包级变量 a，这使得包级变量 a 没有参与到 foo 函数的逻辑中，所以就没有发生变化了。</p><p>暂时放到一边。</p><h2 id="Go-基本数据类型"><a href="#Go-基本数据类型" class="headerlink" title="Go 基本数据类型"></a>Go 基本数据类型</h2><p>Go 语言的类型大体可分为基本数据类型、复合数据类型和接口类型这三种。</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>可以分为平台无关整型和平台相关整型这两种，它们的区别主要就在，这些整数类型在不同 CPU 架构或操作系统下面，它们的长度是否是一致的。</p><h4 id="平台无关整型"><a href="#平台无关整型" class="headerlink" title="平台无关整型"></a>平台无关整型</h4><p>下面是平台无关整型：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230211152317.png]]<br>这些平台无关的整型也可以分成两类：有符号整型（int8<del>int64）和无符号整型（uint8</del>uint64）。两者的本质差别在于最高二进制位（bit 位）是否被解释为符号位，这点会影响到无符号整型与有符号整型的取值范围。<br>以下图中的这个 8 比特（一个字节）的整型值为例，当它被解释为无符号整型 uint8 时，和它被解释为有符号整型 int8 时表示的值是不同的：</p><p>![[【Go基础】未整理合集&#x2F;Pasted image 20230211152534.png]]<br>为什么上图中 int8 对应的是-127 而不是-1? 这是因为 Go 采用 2 的补码（Two’s Complement）作为整型的比特位编码方法。它是通过原码逐位取反后再加 1 得到的。<br>-127 得到的过程如下：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230211153258.png]]</p><h4 id="平台相关整型"><a href="#平台相关整型" class="headerlink" title="平台相关整型"></a>平台相关整型</h4><p>Go 语言原生提供了三个平台相关整型，它们是 int、uint 与 uintptr。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230211152734.png]]<br>由于这三个类型的长度是平台相关的，所以我们在编写有移植性要求的代码时，千万不要强依赖这些类型的长度。<br>如果不知道这三个类型在目标运行平台上的长度，可以通过 unsafe 包提供的 SizeOf 函数来获取，比如在 x86-64 平台上，它们的长度均为 8：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b = <span class="hljs-type">int</span>(<span class="hljs-number">5</span>), <span class="hljs-type">uint</span>(<span class="hljs-number">6</span>)<br><span class="hljs-keyword">var</span> p <span class="hljs-type">uintptr</span> = <span class="hljs-number">0x12345678</span><br>fmt.Println(<span class="hljs-string">&quot;signed integer a&#x27;s length is&quot;</span>, unsafe.Sizeof(a)) <span class="hljs-comment">// 8</span><br>fmt.Println(<span class="hljs-string">&quot;unsigned integer b&#x27;s length is&quot;</span>, unsafe.Sizeof(b)) <span class="hljs-comment">// 8</span><br>fmt.Println(<span class="hljs-string">&quot;uintptr&#x27;s length is&quot;</span>, unsafe.Sizeof(p)) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><h4 id="整型的溢出问题"><a href="#整型的溢出问题" class="headerlink" title="整型的溢出问题"></a>整型的溢出问题</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">int8</span> = <span class="hljs-number">127</span><br>s += <span class="hljs-number">1</span> <span class="hljs-comment">// 预期128，实际结果-128</span><br><br><span class="hljs-keyword">var</span> u <span class="hljs-type">uint8</span> = <span class="hljs-number">1</span><br>u -= <span class="hljs-number">2</span> <span class="hljs-comment">// 预期-1，实际结果255</span><br></code></pre></td></tr></table></figure><p>解决方法：记住使用的整数类型的取值范围。</p><h4 id="字面值与格式化输出"><a href="#字面值与格式化输出" class="headerlink" title="字面值与格式化输出"></a>字面值与格式化输出</h4><p>Go 语言继承了 C 语言关于数值字面值（Number Literal）的语法形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">53</span>        <span class="hljs-comment">// 十进制</span><br>b := <span class="hljs-number">0700</span>      <span class="hljs-comment">// 八进制，以&quot;0&quot;为前缀</span><br>c1 := <span class="hljs-number">0xaabbcc</span> <span class="hljs-comment">// 十六进制，以&quot;0x&quot;为前缀</span><br>c2 := <span class="hljs-number">0Xddeeff</span> <span class="hljs-comment">// 十六进制，以&quot;0X&quot;为前缀</span><br><span class="hljs-comment">//go 1.13版本后增加对二进制字面值的支持和两种八进制字面值的形式</span><br>d1 := <span class="hljs-number">0</span>b10000001 <span class="hljs-comment">// 二进制，以&quot;0b&quot;为前缀</span><br>d2 := <span class="hljs-number">0</span>B10000001 <span class="hljs-comment">// 二进制，以&quot;0B&quot;为前缀</span><br>e1 := <span class="hljs-number">0o700</span>      <span class="hljs-comment">// 八进制，以&quot;0o&quot;为前缀</span><br>e2 := <span class="hljs-number">0O700</span>      <span class="hljs-comment">// 八进制，以&quot;0O&quot;为前缀</span><br><span class="hljs-comment">//还增加了在字面值中增加数字分隔符“_”,用来将数字分组以提高可读性</span><br>a := <span class="hljs-number">5_3_7</span>   <span class="hljs-comment">// 十进制: 537</span><br>b := <span class="hljs-number">0</span>b_1000_0111  <span class="hljs-comment">// 二进制位表示为10000111 </span><br>c1 := <span class="hljs-number">0_700</span>  <span class="hljs-comment">// 八进制: 0700</span><br>c2 := <span class="hljs-number">0o_700</span> <span class="hljs-comment">// 八进制: 0700</span><br>d1 := <span class="hljs-number">0x_5c_6d</span> <span class="hljs-comment">// 十六进制：0x5c6d</span><br></code></pre></td></tr></table></figure><p>Go 语言整数类型使用 fmt 标准化输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">59</span><br>fmt.Printf(<span class="hljs-string">&quot;%b\n&quot;</span>, a) <span class="hljs-comment">//输出二进制：111011</span><br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, a) <span class="hljs-comment">//输出十进制：59</span><br>fmt.Printf(<span class="hljs-string">&quot;%o\n&quot;</span>, a) <span class="hljs-comment">//输出八进制：73</span><br>fmt.Printf(<span class="hljs-string">&quot;%O\n&quot;</span>, a) <span class="hljs-comment">//输出八进制(带0o前缀)：0o73</span><br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, a) <span class="hljs-comment">//输出十六进制(小写)：3b</span><br>fmt.Printf(<span class="hljs-string">&quot;%X\n&quot;</span>, a) <span class="hljs-comment">//输出十六进制(大写)：3B</span><br></code></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>和使用广泛的整型相比，浮点型的使用场景就相对聚焦了，主要集中在科学数值计算、图形图像处理和仿真、多媒体游戏以及人工智能等领域。<br><strong>注意：Go 提供的浮点类型都是平台无关的。</strong><br>它只提供了 float32 与 float64 两种浮点类型，它们分别对应的就是 IEEE 754 中的单精度与双精度浮点数值类型。Go 语言中没有提供 float 类型。这不像整型那样，Go 既提供了 int16、int32 等类型，又有 int 类型。<br><font color=" #8064a2 ">（跳过一部分关于 IEEE 浮点数标准的知识）</font><br>因为双精度浮点类型（float64）阶码与尾数使用的比特位数更多，它可以表示的精度要远超单精度浮点类型，所以在日常开发中，我们使用双精度浮点类型（float64）的情况更多，这也是 Go 语言中浮点常量或字面值的默认类型。<br>而 float32 由于表示范围与精度有限，经常会给开发者造成一些困扰。比如我们可能会因为 float32 精度不足，导致输出结果与常识不符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f1 <span class="hljs-type">float32</span> = <span class="hljs-number">16777216.0</span><br><span class="hljs-keyword">var</span> f2 <span class="hljs-type">float32</span> = <span class="hljs-number">16777217.0</span><br>fmt.Println(f1 == f2) <span class="hljs-comment">// true</span><br><span class="hljs-comment">//f1 与 f2 两个浮点类型变量被两个不同的浮点字面值初始化，但逻辑比较的结果却是两个变量的值相等。</span><br></code></pre></td></tr></table></figure><p><strong>上面 f1, f2 为什么相等？</strong><br>f1 转换成二进制是：1266679808<br>f2 转换成二进制也是：1266679808<br>是因为转换成二进制的数据是相等的。</p><h4 id="字面值与格式化输出-1"><a href="#字面值与格式化输出-1" class="headerlink" title="字面值与格式化输出"></a>字面值与格式化输出</h4><p>Go 浮点类型字面值大体可分为两类，一类是直白地用十进制表示的浮点值形式。这一类，我们通过字面值就可直接确定它的浮点值，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">3.1415</span><br><span class="hljs-number">.15</span>  <span class="hljs-comment">// 整数部分如果为0，整数部分可以省略不写</span><br><span class="hljs-number">81.80</span><br><span class="hljs-number">82.</span> <span class="hljs-comment">// 小数部分如果为0，小数点后的0可以省略不写</span><br></code></pre></td></tr></table></figure><p>另一类则是科学计数法形式。采用科学计数法表示的浮点字面值，我们需要通过一定的换算才能确定其浮点值。而且在这里，科学计数法形式又分为十进制形式表示的，和十六进制形式表示的两种。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//十进制科学计数法形式的浮点数字面值</span><br><span class="hljs-number">6674.28e-2</span> <span class="hljs-comment">// 6674.28 * 10^(-2) = 66.742800</span><br><span class="hljs-number">.12345E+5</span>  <span class="hljs-comment">// 0.12345 * 10^5 = 12345.000000</span><br><br><span class="hljs-comment">//十六进制科学计数法形式的浮点数</span><br><span class="hljs-number">0x2.p10</span>  <span class="hljs-comment">// 2.0 * 2^10 = 2048.000000</span><br><span class="hljs-number">0x1.Fp+0</span> <span class="hljs-comment">// 1.9375 * 2^0 = 1.937500</span><br><span class="hljs-comment">//注意，十六进制科学计数法的整数部分、小数部分用的都是十六进制形式，但指数部分依然是十进制形式，并且字面值中的 p/P 代表的幂运算的底数为 2。</span><br></code></pre></td></tr></table></figure><p>fmt 格式化输出浮点类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-number">123.45678</span><br>fmt.Printf(<span class="hljs-string">&quot;%f\n&quot;</span>, f) <span class="hljs-comment">// 123.456780</span><br><span class="hljs-comment">//科学计数法形式</span><br>fmt.Printf(<span class="hljs-string">&quot;%e\n&quot;</span>, f) <span class="hljs-comment">// 1.234568e+02</span><br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, f) <span class="hljs-comment">// 0x1.edd3be22e5de1p+06</span><br><span class="hljs-comment">//其中 %e 输出的是十进制的科学计数法形式，而 %x 输出的则是十六进制的科学计数法形式。</span><br></code></pre></td></tr></table></figure><h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><p>复数类型在 Go 中的应用就更为局限和小众，主要用于专业领域的计算，比如矢量计算等。<br>Go 提供两种复数类型，它们分别是 complex64 和 complex128，complex64 的实部与虚部都是 float32 类型，而 complex128 的实部与虚部都是 float64 类型。如果一个复数没有显示赋予类型，那么它的默认类型为 complex128。<br><strong>复数字面值的表示 (三种)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//第一种 通过复数字面值直接初始化一个复数类型变量</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-number">5</span> + <span class="hljs-number">6i</span><br><span class="hljs-keyword">var</span> d = <span class="hljs-number">0o123</span> + <span class="hljs-number">.12345E+5i</span> <span class="hljs-comment">// 83+12345i</span><br><br><span class="hljs-comment">//第二种，通过complex 函数</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">complex</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 5 + 6i</span><br><span class="hljs-keyword">var</span> d = <span class="hljs-built_in">complex</span>(<span class="hljs-number">0o123</span>, <span class="hljs-number">.12345E+5</span>) <span class="hljs-comment">// 83+12345i</span><br><br><span class="hljs-comment">//第三种 通过 Go 提供的预定义的函数 real 和 imag，来获取一个复数的实部与虚部，返回值为一个浮点类型</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">complex</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 5 + 6i</span><br>r := <span class="hljs-built_in">real</span>(c) <span class="hljs-comment">// 5.000000</span><br>i := <span class="hljs-built_in">imag</span>(c) <span class="hljs-comment">// 6.000000</span><br></code></pre></td></tr></table></figure><h3 id="创建自定义的数值类型"><a href="#创建自定义的数值类型" class="headerlink" title="创建自定义的数值类型"></a>创建自定义的数值类型</h3><p>通过 Go 提供的类型定义语法，可以使用 type 关键字基于原生数值类型来声明一个新类型。<br>但是自定义的数值类型，在和其他类型相互赋值时容易出现一些问题。<br>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义了一个MyInt类型。</span><br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int32</span><br></code></pre></td></tr></table></figure><p>虽然 MyInt 类型的底层类型是 int32，它的数值性质与 int32 完全相同，但它们仍然是完全不同的两种类型。根据 Go 的类型安全规则，我们无法直接让它们相互赋值，或者是把它们放在同一个运算中直接计算，这样编译器就会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-type">int</span> = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int32</span> = <span class="hljs-number">6</span><br><span class="hljs-keyword">var</span> a MyInt = m <span class="hljs-comment">// 错误：在赋值中不能将m（int类型）作为MyInt类型使用</span><br><span class="hljs-keyword">var</span> a MyInt = n <span class="hljs-comment">// 错误：在赋值中不能将n（int32类型）作为MyInt类型使用</span><br></code></pre></td></tr></table></figure><p>要避免这个错误，我们需要借助显式转型，让赋值操作符左右两边的操作数保持类型一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-type">int</span> = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int32</span> = <span class="hljs-number">6</span><br><span class="hljs-keyword">var</span> a MyInt = MyInt(m) <span class="hljs-comment">// ok</span><br><span class="hljs-keyword">var</span> a MyInt = MyInt(n) <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>可以集体声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>   T1 <span class="hljs-type">int</span><br>   T2 T1<br>   T3 <span class="hljs-type">string</span><br>)<br></code></pre></td></tr></table></figure><p><strong>也可以通过 Go 提供的类型别名（Type Alias）语法来自定义数值类型。</strong><br>和上面使用标准 type 语法的定义不同的是，通过类型别名语法定义的新类型与原类型别无二致，可以完全相互替代。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt = <span class="hljs-type">int32</span><br><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int32</span> = <span class="hljs-number">6</span><br><span class="hljs-keyword">var</span> a MyInt = n <span class="hljs-comment">// ok</span><br><br><span class="hljs-comment">//辨析：</span><br><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int32</span> <span class="hljs-comment">//新的类型，与int32不一样 </span><br><span class="hljs-keyword">type</span> myInt = <span class="hljs-type">int32</span> <span class="hljs-comment">// int32的别名，与int32一模一样</span><br></code></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>Go 不像 C 语言，Go 原生支持字符串类型。<br><strong>非原生字符串会造成的问题：</strong></p><ul><li>不是原生类型，编译器不会对它进行类型校验，导致类型安全性差；</li><li>字符串操作时要时刻考虑结尾的’\0’，防止缓冲区溢出；</li><li>以字符数组形式定义的“字符串”，</li><li>它的值是可变的，在并发场景中需要考虑同步问题；</li><li>获取一个字符串的长度代价较大，通常是 O (n) 时间复杂度；</li><li>C 语言没有内置对非 ASCII 字符（如中文字符）的支持。</li></ul><p>在 Go 中，字符串类型为 string。Go 语言通过 string 类型统一了对“字符串”的抽象。这样无论是字符串常量、字符串变量或是代码中出现的字符串字面值，它们的类型都被统一设置为 string，</p><h4 id="Go-原生支持-string-带来的好处"><a href="#Go-原生支持-string-带来的好处" class="headerlink" title="Go 原生支持 string 带来的好处"></a>Go 原生支持 string 带来的好处</h4><p><strong>第一点：string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率。</strong><br>Go 语言规定，字符串类型的值在它的生命周期内是不可改变的。<br>如果我们声明了一个字符串类型的变量，那我们是无法通过这个变量改变它对应的字符串值的，但这并不是说我们不能为一个字符串类型变量进行二次赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello&quot;</span><br>s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;k&#x27;</span>   <span class="hljs-comment">// 错误：字符串的内容是不可改变的</span><br>s = <span class="hljs-string">&quot;gopher&quot;</span> <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Go 这样的“字符串类型数据不可变”的性质给开发人员带来的最大好处，就是我们不用再担心字符串的并发安全问题。这样，Go 字符串可以被多个 Goroutine（Go 语言的轻量级用户线程，后面我们会详细讲解）共享，开发者不用因为担心并发安全问题，使用会带来一定开销的同步机制。<br>另外，也由于字符串的不可变性，针对同一个字符串值，无论它在程序的几个位置被使用，Go 编译器只需要为它分配一块存储就好了，大大提高了存储利用率。</p><p><strong>第二点：没有结尾’\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。</strong><br>Go 字符串中没有结尾’\0’，获取字符串长度更不需要结尾’\0’作为结束标志。并且，Go 获取字符串长度是一个常数级时间复杂度，无论字符串中字符个数有多少，我们都可以快速得到字符串的长度值。而 C 语言中的 strlen 函数是一个线性时间复杂度的算法。</p><p><strong>第三点：原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担。</strong><br>在 C 语言中构造多行字符串，一般就是两个方法：要么使用多个字符串的自然拼接，要么需要结合续行符””。而在 GO 中就简单多了，通过一对反引号原生支持构造“所见即所得”的原始字符串（Raw String）。而且，Go 语言原始字符串中的任意转义字符都不会起到转义的作用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">`         ,_---~~~~~----._</span><br><span class="hljs-string">    _,,_,*^____      _____*g*\&quot;*,--,</span><br><span class="hljs-string">   / __/ /&#x27;     ^.  /      \ ^@q   f</span><br><span class="hljs-string">  [  @f | @))    |  | @))   l  0 _/</span><br><span class="hljs-string">   \/   \~____ / __ \_____/     \</span><br><span class="hljs-string">    |           _l__l_           I</span><br><span class="hljs-string">    &#125;          [______]           I</span><br><span class="hljs-string">    ]            | | |            |</span><br><span class="hljs-string">    ]             ~ ~             |</span><br><span class="hljs-string">    |                            |</span><br><span class="hljs-string">     |                           |`</span><br>fmt.Println(s)<br></code></pre></td></tr></table></figure><p><strong>第四点：对非 ASCII 字符提供原生支持，消除了源码在不同环境下显示乱码的可能。</strong><br>Go 语言源文件默认采用的是 Unicode 字符集，Unicode 字符集是目前市面上最流行的字符集，它囊括了几乎所有主流非 ASCII 字符（包括中文字符）。Go 字符串中的每个字符都是一个 Unicode 字符，并且这些 Unicode 字符是以 UTF-8 编码格式存储在内存当中的。</p><h4 id="Go-字符串的组成"><a href="#Go-字符串的组成" class="headerlink" title="Go 字符串的组成"></a>Go 字符串的组成</h4><p>可以使用两个视角来看待 Go 字符串的组成，一种是字节视角。Go 字符串是由一个可空的字节序列组成，字节的个数称为字符串的长度；另外一种是字符视角。Go 字符串是由一个可空的字符序列构成。Go 字符串中的每个字符都是一个 Unicode 字符。</p><p>Go 语言中的字符串值也是一个可空的字节序列，字节序列中的字节个数称为该字符串的长度。一个个的字节只是孤立数据，不表意。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//字节视角</span><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;the length of s = %d\n&quot;</span>, <span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">// 9</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, s[i]) <span class="hljs-comment">// 0xe4 0xb8 0xad 0xe5 0x9b 0xbd 0xe4 0xba 0xba</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment">//字符视角</span><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;the character count in s is&quot;</span>, utf8.RuneCountInString(s)) <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, c) <span class="hljs-comment">// 0x4e2d 0x56fd 0x4eba</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>Go 采用的是 Unicode 字符集，每个字符都是一个 Unicode 字符，那么这里输出的 0x4e2d、0x56fd 和 0x4eba 就应该是某种 Unicode 字符的表示了。没错，以 0x4e2d 为例，它是汉字“中”在 Unicode 字符集表中的<strong>码点</strong>（Code Point）。</p><p>什么是 Unicode 码点呢？</p><p>Unicode 字符集中的每个字符，都被分配了统一且唯一的字符编号。所谓 Unicode 码点，就是指将 Unicode 字符集中的所有字符“排成一队”，字符在这个“队伍”中的位次，就是它在 Unicode 字符集中的码点。也就说，一个码点唯一对应一个字符。“码点”的概念和我们马上要讲的 rune 类型有很大关系。</p><h4 id="rune-类型与字符字面值"><a href="#rune-类型与字符字面值" class="headerlink" title="rune 类型与字符字面值"></a>rune 类型与字符字面值</h4><p>Go 使用 rune 这个类型来表示一个 Unicode 码点。rune 本质上是 int32 类型的别名类型，它与 int32 类型是完全等价的，在 Go 源码中我们可以看到它的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/builtin.go</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">rune</span> = <span class="hljs-type">int32</span><br></code></pre></td></tr></table></figure><p>一个 rune 实例就是一个 Unicode 字符，一个 Go 字符串也可以被视为 rune 实例的集合。我们可以通过字符字面值来初始化一个 rune 变量。(感觉 rune 和 char 有点像)</p><p>在 Go 中，字符字面值有多种表示法，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//最常见的是通过单引号括起的字符字面值</span><br><span class="hljs-string">&#x27;a&#x27;</span>  <span class="hljs-comment">// ASCII字符</span><br><span class="hljs-string">&#x27;中&#x27;</span> <span class="hljs-comment">// Unicode字符集中的中文字符</span><br><span class="hljs-string">&#x27;\n&#x27;</span> <span class="hljs-comment">// 换行字符</span><br><span class="hljs-string">&#x27;\&#x27;&#x27;</span> <span class="hljs-comment">// 单引号字符</span><br><br><span class="hljs-comment">//还可以使用 Unicode 专用的转义字符\u 或\U 作为前缀，来表示一个 Unicode 字符</span><br><span class="hljs-string">&#x27;\u4e2d&#x27;</span>     <span class="hljs-comment">// 字符：中</span><br><span class="hljs-string">&#x27;\U00004e2d&#x27;</span> <span class="hljs-comment">// 字符：中</span><br><span class="hljs-string">&#x27;\u0027&#x27;</span>     <span class="hljs-comment">// 单引号字符</span><br><span class="hljs-comment">//要注意，\u 后面接四个十六进制数。如果是用四个十六进制数无法表示的 Unicode 字符，我们可以使用\U，\U 后面可以接八个十六进制数来表示一个 Unicode 字符。</span><br><br><span class="hljs-comment">//由于表示码点的 rune 本质上就是一个整型数，所以我们还可用整型值来直接作为字符字面值给 rune 变量赋值</span><br><span class="hljs-string">&#x27;\x27&#x27;</span>  <span class="hljs-comment">// 使用十六进制表示的单引号字符</span><br><span class="hljs-string">&#x27;\047&#x27;</span>  <span class="hljs-comment">// 使用八进制表示的单引号字符</span><br></code></pre></td></tr></table></figure><h4 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h4><p>字符串是字符的集合，了解了字符字面值后，字符串的字面值也就很简单了。<br>将单个 Unicode 字符字面值一个接一个地连在一起，并用双引号包裹起来就构成了字符串字面值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">&quot;abc\n&quot;</span><br><span class="hljs-string">&quot;中国人&quot;</span><br><span class="hljs-string">&quot;\u4e2d\u56fd\u4eba&quot;</span> <span class="hljs-comment">// 中国人</span><br><span class="hljs-string">&quot;\U00004e2d\U000056fd\U00004eba&quot;</span> <span class="hljs-comment">// 中国人</span><br><span class="hljs-string">&quot;中\u56fd\u4eba&quot;</span> <span class="hljs-comment">// 中国人，不同字符字面值形式混合在一起</span><br><span class="hljs-string">&quot;\xe4\xb8\xad\xe5\x9b\xbd\xe4\xba\xba&quot;</span> <span class="hljs-comment">// 十六进制表示的字符串字面值：中国人</span><br></code></pre></td></tr></table></figure><h4 id="什么是-UTF-8-编码方案"><a href="#什么是-UTF-8-编码方案" class="headerlink" title="什么是 UTF-8 编码方案"></a>什么是 UTF-8 编码方案</h4><p>UTF-8 编码解决的是 Unicode 码点值在计算机中如何存储和表示（位模式）的问题。<br>像 UTF-32 编码标准就是直接固定使用 4 个字节表示每个 Unicode 字符码点。它的好处是编解码简单，而缺点如下：</p><ul><li>这种编码方案使用 4 个字节存储和传输一个整型数的时候，需要考虑不同平台的字节序问题 ;</li><li>由于采用 4 字节的固定长度编码，与采用 1 字节编码的 ASCII 字符集无法兼容；</li><li>所有 Unicode 字符码点都用 4 字节编码，显然空间利用率很差。</li></ul><p>针对这些问题，Go 语言之父 Rob Pike 发明了 UTF-8 编码方案。UTF-8 方案使用变长度字节，对 Unicode 字符的码点进行编码。编码采用的字节数量与 Unicode 字符在码点表中的序号有关：表示序号（码点）小的字符使用的字节数量少，表示序号（码点）大的字符使用的字节数多。<br>UTF-8 编码方案是兼容 ASCII 字符内存表示的，这意味着采用 UTF-8 方案在内存中表示 Unicode 字符时，已有的 ASCII 字符可以被直接当成 Unicode 字符进行存储和传输，不用再做任何改变。<br>总结：<br>UTF-32 编码方案，将所有 Unicode 字符的码点都按照 4 字节编码。<br>UTF-8 编码方案：根据 Unicode 字符的码点序号不同，所编码的字节数不同。1~4 个字节</p><p>使用 Go 在标准库中提供的 UTF-8 包，对 Unicode 字符（rune）进行编解码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// rune -&gt; []byte </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">encodeRune</span><span class="hljs-params">()</span></span> &#123; <br>	<span class="hljs-keyword">var</span> r <span class="hljs-type">rune</span> = <span class="hljs-number">0x4E2D</span> <br>	fmt.Printf(<span class="hljs-string">&quot;the unicode charactor is %c\n&quot;</span>, r) <span class="hljs-comment">// 中 </span><br>	buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">3</span>)<br>	 _ = utf8.EncodeRune(buf, r) <span class="hljs-comment">// 对rune进行utf-8编码 </span><br>	fmt.Printf(<span class="hljs-string">&quot;utf-8 representation is 0x%X\n&quot;</span>, buf) <span class="hljs-comment">// 0xE4B8AD </span><br>&#125;<br><span class="hljs-comment">// []byte -&gt; rune </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeRune</span><span class="hljs-params">()</span></span> &#123; <br>	<span class="hljs-keyword">var</span> buf = []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0xE4</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0xAD</span>&#125; <br>	r, _ := utf8.DecodeRune(buf) <span class="hljs-comment">// 对buf进行utf-8解码 </span><br>	fmt.Printf(<span class="hljs-string">&quot;the unicode charactor after decoding [0xE4, 0xB8, 0xAD] is %s\n&quot;</span>, <span class="hljs-type">string</span>(r)) <span class="hljs-comment">// 中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，encodeRune 通过调用 UTF-8 的 EncodeRune 函数实现了对一个 rune，也就是一个 Unicode 字符的编码，decodeRune 则调用 UTF-8 包的 decodeRune，将一段内存字节转换回一个 Unicode 字符。</p><h4 id="Go-字符串类型的内部表示"><a href="#Go-字符串类型的内部表示" class="headerlink" title="Go 字符串类型的内部表示"></a>Go 字符串类型的内部表示</h4><p>Go 字符串类型的内部表示究竟是什么样的?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/reflect/value.go</span><br><br><span class="hljs-comment">// StringHeader是一个string的运行时表示</span><br><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>    Data <span class="hljs-type">uintptr</span><br>    Len  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>string 类型的本质其实是一个“描述符”，它本身并不真正存储字符串数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成的。</strong><br>![[【Go基础】未整理合集&#x2F;Pasted image 20230211165806.png|975]]<br>go 中的字符串的底层存储是二元组——字节数组指针+长度常量，所以获取字符串长度是 log (1) 时间；另外由于字符串保存的是字节数组的指针，所以函数&#x2F;方法间传递字符串时的开销也很小，因为并没有真的传递字符串的数据。</p><p>下面代码利用了 unsafe. Pointer 的通用指针转型能力，按照 StringHeader 给出的结构内存布局，“顺藤摸瓜”，一步步找到了底层数组的地址，并输出了底层数组内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dumpBytesArray</span><span class="hljs-params">(arr []<span class="hljs-type">byte</span>)</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;[&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, b := <span class="hljs-keyword">range</span> arr &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, b)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;]\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello&quot;</span><br>    hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) <span class="hljs-comment">// 将string类型变量地址显式转型为reflect.StringHeader</span><br>    fmt.Printf(<span class="hljs-string">&quot;0x%x\n&quot;</span>, hdr.Data) <span class="hljs-comment">// 0x10a30e0</span><br>    p := (*[<span class="hljs-number">5</span>]<span class="hljs-type">byte</span>)(unsafe.Pointer(hdr.Data)) <span class="hljs-comment">// 获取Data字段所指向的数组的指针</span><br>    dumpBytesArray((*p)[:]) <span class="hljs-comment">// [h e l l o ]   // 输出底层数组的内容</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go-字符串类型的常见操作"><a href="#Go-字符串类型的常见操作" class="headerlink" title="Go 字符串类型的常见操作"></a>Go 字符串类型的常见操作</h4><p>由于字符串的不可变性，针对字符串，我们更多是尝试对其进行读取，或者将它作为一个组成单元去构建其他字符串，又或是转换为其他类型。</p><p><strong>第一个操作：下标操作。</strong><br>在字符串的实现中，真正存储数据的是底层的数组。字符串的下标操作本质上等价于底层数组的下标操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;0x_%x\n&quot;</span>, s[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 0x_e4：字符“中” utf-8编码的第一个字节</span><br></code></pre></td></tr></table></figure><p>通过下标操作，我们获取的是字符串中特定下标上的字节，而不是字符。</p><p><strong>第二个操作：字符迭代。</strong><br>Go 有两种迭代形式：常规 for 迭代与 for range 迭代。但是要<strong>注意，通过这两种形式的迭代对字符串进行操作得到的结果是不同的。</strong></p><p><strong>for 迭代：字节形式 for range 迭代：字符形式。</strong></p><p>常规 for 迭代对字符串进行的操作是一种字节视角的迭代，每轮迭代得到的的结果都是组成字符串内容的一个字节，以及该字节所在的下标值，这也等价于对字符串底层数组的迭代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, s[i])<br>&#125;<br><span class="hljs-comment">//输出</span><br>index: <span class="hljs-number">0</span>, value: <span class="hljs-number">0xe4</span><br>index: <span class="hljs-number">1</span>, value: <span class="hljs-number">0xb8</span><br>index: <span class="hljs-number">2</span>, value: <span class="hljs-number">0xad</span><br>index: <span class="hljs-number">3</span>, value: <span class="hljs-number">0xe5</span><br>index: <span class="hljs-number">4</span>, value: <span class="hljs-number">0x9b</span><br>index: <span class="hljs-number">5</span>, value: <span class="hljs-number">0xbd</span><br>index: <span class="hljs-number">6</span>, value: <span class="hljs-number">0xe4</span><br>index: <span class="hljs-number">7</span>, value: <span class="hljs-number">0xba</span><br>index: <span class="hljs-number">8</span>, value: <span class="hljs-number">0xba</span><br></code></pre></td></tr></table></figure><p>而通过 for range 迭代，我们每轮迭代得到的是字符串中 Unicode 字符的码点值，以及该字符在字符串中的偏移值。我们可以通过这样的迭代，获取字符串中的字符个数（或者使用调用标准库 UTF-8 包中的 RuneCountInString 函数），而通过 Go 提供的内置函数 len，我们只能获取字符串内容的长度（字节个数）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, v)<br>&#125;<br><span class="hljs-comment">//输出</span><br>index: <span class="hljs-number">0</span>, value: <span class="hljs-number">0x4e2d</span><br>index: <span class="hljs-number">3</span>, value: <span class="hljs-number">0x56fd</span><br>index: <span class="hljs-number">6</span>, value: <span class="hljs-number">0x4eba</span><br></code></pre></td></tr></table></figure><p><strong>第三个操作：字符串连接。</strong><br>Go 原生支持通过 +&#x2F;+&#x3D; 操作符进行字符串连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;Rob Pike, &quot;</span><br>s = s + <span class="hljs-string">&quot;Robert Griesemer, &quot;</span><br>s += <span class="hljs-string">&quot; Ken Thompson&quot;</span><br><br>fmt.Println(s) <span class="hljs-comment">// Rob Pike, Robert Griesemer, Ken Thompson</span><br></code></pre></td></tr></table></figure><p>虽然通过 +&#x2F;+&#x3D; 进行字符串连接的开发体验是最好的，但连接性能就未必是最快的了。除了这个方法外，Go 还提供了 strings. Builder、strings. Join、fmt. Sprintf 等函数来进行字符串连接操作。</p><p><strong>第四个操作：字符串比较。</strong><br>在字符串的比较上，Go 采用字典序的比较策略，分别从每个字符串的起始处，开始逐个<strong>字节</strong>地对两个字符串类型变量进行比较（字符串比较会进行从左到右做逐字节比较，而不是码点）。当两个字符串之间出现了第一个不相同的元素，比较就结束了，这两个元素的比较结果就会做为串最终的比较结果。如果出现两个字符串长度不同的情况，长度比较小的字符串会用空元素补齐，空元素比其他非空元素都小。<a target="_blank" rel="noopener" href="https://tonybai.com/2022/04/18/inside-go-string-comparison">Fetching Title#ln3o</a><br>鉴于 Go string 类型是不可变的，所以说如果两个字符串的长度不相同，那么我们不需要比较具体字符串数据，也可以断定两个字符串是不同的。但是如果两个字符串长度相同，就要进一步判断，数据指针是否指向同一块底层存储数据。如果还相同，那么我们可以说两个字符串是等价的，如果不同，那就还需要进一步去比对实际的数据内容（虽然内存地址不同，也可能值相同，所以，需要进一步比较。）。</p><p><strong>第五个操作：字符串转换。</strong><br>Go 支持字符串与字节切片、字符串与 rune 切片的双向转换，并且这种转换无需调用任何函数，只需使用显式类型转换就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;中国人&quot;</span><br>                      <br><span class="hljs-comment">// string -&gt; []rune</span><br>rs := []<span class="hljs-type">rune</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, rs) <span class="hljs-comment">// [4e2d 56fd 4eba]</span><br>                <br><span class="hljs-comment">// string -&gt; []byte</span><br>bs := []<span class="hljs-type">byte</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, bs) <span class="hljs-comment">// e4b8ade59bbde4baba</span><br>                <br><span class="hljs-comment">// []rune -&gt; string</span><br>s1 := <span class="hljs-type">string</span>(rs)<br>fmt.Println(s1) <span class="hljs-comment">// 中国人</span><br>                <br><span class="hljs-comment">// []byte -&gt; string</span><br>s2 := <span class="hljs-type">string</span>(bs)<br>fmt.Println(s2) <span class="hljs-comment">// 中国人</span><br></code></pre></td></tr></table></figure><p>这样的转型看似简单，但无论是 string 转切片，还是切片转 string，这类转型背后也是有着一定开销的。这些开销的根源就在于 string 是不可变的，运行时要为转换后的类型分配新内存。</p><h5 id="那种连接方式是性能最高的？"><a href="#那种连接方式是性能最高的？" class="headerlink" title="那种连接方式是性能最高的？"></a>那种连接方式是性能最高的？</h5><p>如果能知道拼接字符串的个数，那么使用 bytes. Buffer 和 strings. Builder 的 Grows 申请空间后，性能是最好的；<br>如果不能确定长度，那么 bytes. Buffer 和 strings. Builder 也比“+”和 fmt. Sprintf 性能好很多。 bytes. Buffer 与 strings. Builder 相比的话，strings. Builder 更合适，因为 bytes. Buffer 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 strings. Builder 直接将底层的 []byte 转换成了字符串类型返回了回来。</p><h3 id="Go-常量"><a href="#Go-常量" class="headerlink" title="Go 常量"></a>Go 常量</h3><p>（暂时跳过）</p><h2 id="Go-复合类型"><a href="#Go-复合类型" class="headerlink" title="Go 复合类型"></a>Go 复合类型</h2><h3 id="同构复合类型"><a href="#同构复合类型" class="headerlink" title="同构复合类型"></a>同构复合类型</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>Go 语言的数组是一个长度固定的、由同构类型元素组成的连续序列。<br>Go 的数组类型包含两个重要属性：<strong>元素的类型</strong>和<strong>数组长度</strong>（元素的个数）。这两个属性也直接构成了 Go 语言中数组类型变量的声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [N]T<br></code></pre></td></tr></table></figure><p>这里我们声明了一个数组变量 arr，它的类型为[N]T，其中元素的类型为 T，数组的长度为 N。<br>数组元素的类型可以为任意的 Go 原生类型或自定义类型，而且数组的长度必须在声明数组变量时提供，Go 编译器需要在编译阶段就知道数组类型的长度，所以，我们只能用整型数字面值或常量表达式作为 N 值。<br><strong>如果两个数组类型的元素类型 T 与数组长度 N 都是一样的，那么这两个数组类型是等价的，如果有一个属性不同，它们就是两个不同的数组类型。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(arr [5]<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> arr2 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> arr3 [<span class="hljs-number">5</span>]<span class="hljs-type">string</span><br><br>    foo(arr1) <span class="hljs-comment">// ok</span><br>    foo(arr2) <span class="hljs-comment">// 错误：[6]int与函数foo参数的类型[5]int不是同一数组类型</span><br>    foo(arr3) <span class="hljs-comment">// 错误：[5]string与函数foo参数的类型[5]int不是同一数组类型</span><br>&#125;  <br></code></pre></td></tr></table></figure><p>数组类型不仅是逻辑上的连续序列，而且在实际内存分配时也占据着一整块内存。Go 编译器在为数组类型的变量实际分配内存时，会为 Go 数组分配一整块、可以容纳它所有元素的连续内存，如下图所示：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213121345.png]]<br>Go 提供了预定义函数 len 可以用于获取一个数组类型变量的长度，通过 unsafe 包提供的 Sizeof 函数，我们可以获得一个数组变量的总大小.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;数组长度：&quot;</span>, <span class="hljs-built_in">len</span>(arr))           <span class="hljs-comment">// 6</span><br>fmt.Println(<span class="hljs-string">&quot;数组大小：&quot;</span>, unsafe.Sizeof(arr)) <span class="hljs-comment">// 48</span><br></code></pre></td></tr></table></figure><p>数组大小就是所有元素的大小之和，这里数组元素的类型为 int。在 64 位平台上，int 类型的大小为 8，数组 arr 一共有 6 个元素，因此它的总大小为 6x8&#x3D;48 个字节。</p><p>和基本数据类型一样，我们声明一个数组类型变量的同时，也可以显式地对它进行初始化。如果不进行显式初始化，那么数组中的元素值就是它类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// [0 0 0 0 0 0]</span><br></code></pre></td></tr></table></figure><p>如果要显式地对数组初始化，我们需要在右值中显式放置数组类型，并通过大括号的方式给各个元素赋值（如下面代码中的 arr2）。我们也可以忽略掉右值初始化表达式中数组类型的长度，用“…”替代，Go 编译器会根据数组元素的个数，自动计算出数组长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>,<br>&#125; <span class="hljs-comment">// [11 12 13 14 15 16]</span><br><br><span class="hljs-keyword">var</span> arr3 = [...]<span class="hljs-type">int</span> &#123; <br>    <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>,<br>&#125; <span class="hljs-comment">// [21 22 23]</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, arr3) <span class="hljs-comment">// [3]int</span><br></code></pre></td></tr></table></figure><p>如果我们要对一个长度较大的稀疏数组进行显式初始化, 可以通过使用下标赋值的方式对它进行初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr4 = [...]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-number">99</span>: <span class="hljs-number">39</span>, <span class="hljs-comment">// 将第100个元素(下标值为99)的值赋值为39，其余元素值均为0</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, arr4) <span class="hljs-comment">// [100]int</span><br></code></pre></td></tr></table></figure><p>这种赋值方式有点怪，和 python 的逻辑是完全不同的。</p><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>数组类型自身也可以作为数组元素的类型，这样就会产生<strong>多维数组</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mArr [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>![[【Go基础】未整理合集&#x2F;Pasted image 20230213123358.png]]<br>从左到右看，[2][3][4]int 可以把这个多维数组拆分。无论多维数组究竟有多少维，我们都可以将它从左到右逐一展开，最终化为我们熟悉的一维数组。</p><p>数组类型变量是一个整体，这就意味着一个数组变量表示的是整个数组，因此在 Go 语言中，无论是参与迭代，还是作为实际参数传给一个函数 &#x2F; 方法，Go 传递数组的方式都是纯粹的值拷贝，这会带来较大的内存拷贝开销。这点与 C 语言完全不同，在 C 语言中，数组变量可视为指向数组第一个元素的指针，而 Go 语言对这个问题的解决方式为使用一个新的数据类型<strong>切片</strong>，来解决这个问题。</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>数组在使用上确有两点不足：<br>1、元素的个数是固定的，不可变<br>2、默认只传递值（需要显示指定传递指针），有内存拷贝的开销。<br>于是 Go 设计者们又引入了另外一种同构复合类型：切片（slice），来弥补数组的这两处不足。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<span class="hljs-comment">//初始化一个切片变量</span><br>fmt.Println(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 6</span><br>nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">7</span>) <span class="hljs-comment">// 切片变为[1 2 3 4 5 6 7]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 7</span><br></code></pre></td></tr></table></figure><p>与数组声明相比，切片声明仅仅是少了一个“长度”属性.<br>虽然不需要像数组那样在声明时指定长度，但切片也有自己的长度，只不过这个长度不是固定的，而是随着切片中元素个数的变化而变化的。通过 Go 内置函数 append，我们可以动态地向切片中添加元素。</p><h5 id="切片类型组成"><a href="#切片类型组成" class="headerlink" title="切片类型组成"></a>切片类型组成</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>    array unsafe.Pointer<br>    <span class="hljs-built_in">len</span>   <span class="hljs-type">int</span><br>    <span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每个切片包含三个字段：</p><ul><li>array: 是指向底层数组的指针；</li><li>len: 是切片的长度，即切片中当前元素的个数；</li><li>cap: 是底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len 值。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213125017.png]]</li></ul><p>Go 编译器会自动为每个新创建的切片，建立一个底层数组，默认底层数组的长度与切片初始元素个数相同。我们还可以用以下几种方法创建切片，并指定它底层数组的长度。</p><h5 id="创建切片的方法"><a href="#创建切片的方法" class="headerlink" title="创建切片的方法"></a>创建切片的方法</h5><p><a target="_blank" rel="noopener" href="https://qcrao.com/post/dive-into-go-slice/">深度解密 Go 语言之 slice | qcrao 的博客</a><br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213145059.png]]</p><p><strong>方法一：通过 make 函数来创建切片，并指定底层数组的长度</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">sl := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 6为切片的初始长度,10为cap值，即底层数组长度，</span><br></code></pre></td></tr></table></figure><p>如果没有在 make 中指定 cap 参数，那么底层数组长度 cap 就等于 len，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">sl := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// cap = len = 6</span><br></code></pre></td></tr></table></figure><p><strong>方法二：采用 array[low : high : max]语法基于一个已存在的数组创建切片。这种方式被称为数组的切片化，</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;<br>sl := arr[<span class="hljs-number">3</span>:<span class="hljs-number">7</span>:<span class="hljs-number">9</span>]<span class="hljs-comment">//sl是一个指向arr, len为4, cap为6的切片</span><br><br>sl[<span class="hljs-number">0</span>] += <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;arr[3] =&quot;</span>, arr[<span class="hljs-number">3</span>]) <span class="hljs-comment">// 14</span><br></code></pre></td></tr></table></figure><p>基于数组创建的切片，它的起始元素从 low 所标识的下标值开始，切片的长度（len）是 high - low，它的容量是 max - low。由于切片 sl 的底层数组就是数组 arr，对切片 sl 中元素的修改将直接影响数组 arr 变量。比如，如果我们将切片的第一个元素加 10，那么数组 arr 的第四个元素将变为 14：<br>这个切片 sl 在运行时中的表示是这样：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213125334.png]]<br><strong>切片好比打开了一个访问与修改数组的“窗口”，通过这个窗口，我们可以直接操作底层数组中的部分元素。</strong><br>这有些类似于我们操作文件之前打开的“文件描述符”（Windows 上称为句柄），通过文件描述符我们可以对底层的真实文件进行相关操作。可以说，切片之于数组就像是文件描述符之于文件。<br>在 Go 语言中，数组更多是“退居幕后”，承担的是底层存储空间的角色。切片就是数组的“描述符”，也正是因为这一特性，切片才能在函数参数传递时避免较大性能开销。因为我们传递的并不是数组本身，而是数组的“描述符”，这个描述符的大小是固定的（见上面的三元组结构），无论底层的数组有多大，切片打开的“窗口”长度有多长，它都是不变的。此外，<strong>我们在进行数组切片化的时候，通常省略 max，而 max 的默认值为数组的长度。</strong><br>可以为同一个内存分配多个”描述符”也就是多个切片。这样的情况下，无论我们通过哪个切片对数组进行的修改操作，都会反映到另一个切片中。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213130856.png]]<br>比如，将 sl2[2]置为 14，那么 sl1[0]也会变成 14，因为 sl2[2]直接操作的是底层数组 arr 的第四个元素 arr[3]。</p><p><strong>方法三：基于切片创建切片。</strong><br>和前面是一样的。</p><h5 id="切片的动态扩容"><a href="#切片的动态扩容" class="headerlink" title="切片的动态扩容"></a>切片的动态扩容</h5><p>“动态扩容”指的就是，当我们通过 append 操作向切片追加数据的时候，如果这时切片的 len 值和 cap 值是相等的，也就是说切片底层数组已经没有空闲空间再来存储追加的值了，Go 运行时就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br>s = <span class="hljs-built_in">append</span> (s, <span class="hljs-number">11</span>) <br>fmt. Println (<span class="hljs-built_in">len</span> (s), <span class="hljs-built_in">cap</span> (s)) <span class="hljs-comment">//1 1</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">12</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//2 2</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">13</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//3 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">14</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//4 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">15</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//5 8</span><br></code></pre></td></tr></table></figure><p>append 会根据切片的需要，在当前底层数组容量无法满足的情况下，动态分配新的数组，新数组长度会按一定规律扩展。<br>在上面这段代码中，针对元素是 int 型的数组，新数组的容量是当前数组的 2 倍。新数组建立后，append 会把旧数组中的数据拷贝到新数组中，之后新数组便成为了切片的底层数组，旧数组会被垃圾回收掉。</p><h5 id="关于扩容的小坑"><a href="#关于扩容的小坑" class="headerlink" title="关于扩容的小坑"></a>关于扩容的小坑</h5><p>append 操作的这种自动扩容行为，有些时候会给我们开发者带来一些困惑，比如基于一个已有数组建立的切片，一旦追加的数据操作触碰到切片的容量上限（实质上也是数组容量的上界)，切片就会和原数组解除“绑定”，后续对切片的任何修改都不会反映到原数组中了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">u := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;array:&quot;</span>, u) <span class="hljs-comment">// [11, 12, 13, 14, 15]</span><br>s := u[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>fmt.Printf(<span class="hljs-string">&quot;slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><span class="hljs-comment">// slice(len=2, cap=4): [12 13]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">24</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 24, array:&quot;</span>, u)<br><span class="hljs-comment">// after append 24, array: [11 12 13 24 15]</span><br>fmt.Printf(<span class="hljs-string">&quot;after append 24, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><span class="hljs-comment">// after append 24, slice(len=3, cap=4): [12 13 24]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">25</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 25, array:&quot;</span>, u)<br><span class="hljs-comment">// after append 25, array: [11 12 13 24 25]</span><br>fmt.Printf(<span class="hljs-string">&quot;after append 25, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><span class="hljs-comment">// after append 25, slice(len=4, cap=4): [12 13 24 25]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">26</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 26, array:&quot;</span>, u)<br><span class="hljs-comment">// after append 26, array: [11 12 13 24 25]</span><br>fmt.Printf(<span class="hljs-string">&quot;after append 26, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><span class="hljs-comment">// after append 26, slice(len=5, cap=8): [12 13 24 25 26]</span><br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">22</span><br>fmt.Println(<span class="hljs-string">&quot;after reassign 1st elem of slice, array:&quot;</span>, u)<br><span class="hljs-comment">// after reassign 1st elem of slice, array: [11 12 13 24 25]</span><br>fmt.Printf(<span class="hljs-string">&quot;after reassign 1st elem of slice, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><span class="hljs-comment">// after reassign 1st elem of slice, slice(len=5, cap=8): [22 13 24 25 26]</span><br></code></pre></td></tr></table></figure><p>这里，在 append 25 之后，切片的元素已经触碰到了底层数组 u 的边界了。然后我们再 append 26 之后，append 发现底层数组已经无法满足 append 的要求，于是新创建了一个底层数组（数组长度为 cap (s) 的 2 倍，即 8），并将 slice 的元素拷贝到新数组中了。<br>在这之后，我们即便再修改切片的第一个元素值，原数组 u 的元素也不会发生改变了，因为这个时候切片 s 与数组 u 已经解除了“绑定关系”，s 已经不再是数组 u 的“描述符”。<br><strong>容易遇到的问题</strong><br>切片做入参，本质还是值传递，构建一个新变量接受内部字段值，所以函数内扩容后无法反应到函数外的切片。</p><h5 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h5><p><a target="_blank" rel="noopener" href="https://qcrao.com/post/dive-into-go-slice/">深度解密 Go 语言之 slice | qcrao 的博客</a></p><h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>map 是 Go 语言提供的一种抽象数据类型，它表示一组无序的键值对。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213140031.png]]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">map</span>[key_type]value_type<br><span class="hljs-comment">//key 与 value 的类型可以相同，也可以不同：</span><br><br><span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span> <span class="hljs-comment">// key与value元素的类型相同</span><br><span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>    <span class="hljs-comment">// key与value元素的类型不同</span><br></code></pre></td></tr></table></figure><p>如果两个 map 类型的 key 元素类型相同，value 元素类型也相同，那么我们可以说它们是同一个 map 类型，否则就是不同的 map 类型。<br>map 类型对 value 的类型没有限制，但是对 key 的类型却有严格要求，因为 map 类型要保证 key 的唯一性。<strong>Go 语言中要求，key 的类型必须支持“=&#x3D;”和“!&#x3D;”两种比较操作符。</strong> 而在 Go 语言中，函数类型、map 类型自身，以及切片只支持与 nil 的比较，而不支持同类型两个变量的比较。因此<strong>函数类型、map 类型自身，以及切片类型是不能作为 map 的 key 类型</strong>的。</p><h5 id="map-变量的声明和初始化"><a href="#map-变量的声明和初始化" class="headerlink" title="map 变量的声明和初始化"></a>map 变量的声明和初始化</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 一个 map[string]int 类型的变量</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 初值为零值 nil 的切片类型变量，可以借助内置的 append 的函数进行操作，这种在 Go 语言中被称为“零值可用”。但 map 类型，因为它内部实现的复杂性，无法“零值可用”。所以，如果我们对处于零值状态的 map 变量直接进行操作，就会导致运行时异常（panic），从而导致程序进程异常退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// m = nil</span><br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-number">1</span>         <span class="hljs-comment">// 发生运行时异常：panic: assignment to entry in nil map</span><br></code></pre></td></tr></table></figure><p>为 map 类型变量显式赋值有两种方式：一种是使用复合字面值；另外一种是使用 make 这个预声明的内置函数。</p><p><strong>方法一：使用复合字面值初始化 map 类型变量。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>此时 map 类型变量 m 中没有任何键值对，变量 m 也不等同于初值为 nil 的 map 变量。这个时候，我们对 m 进行键值对的插入操作，不会引发运行时异常。<br>复杂一些的复合字面值，对 map 类型变量进行初始化，不过这里能写的这么简单是因为 Go 提供了“语法糖”：<strong>Go 允许省略字面值中的元素类型</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Position <span class="hljs-keyword">struct</span> &#123; x <span class="hljs-type">float64</span> y <span class="hljs-type">float64</span>&#125;<br>m2 := <span class="hljs-keyword">map</span>[Position]<span class="hljs-type">string</span>&#123;<br>    &#123;<span class="hljs-number">29.935523</span>, <span class="hljs-number">52.568915</span>&#125;: <span class="hljs-string">&quot;school&quot;</span>,<br>    &#123;<span class="hljs-number">25.352594</span>, <span class="hljs-number">113.304361</span>&#125;: <span class="hljs-string">&quot;shopping-mall&quot;</span>,<br>    &#123;<span class="hljs-number">73.224455</span>, <span class="hljs-number">111.804306</span>&#125;: <span class="hljs-string">&quot;hospital&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：使用 make 为 map 类型变量进行显式初始化。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>) <span class="hljs-comment">// 未指定初始容量</span><br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 指定初始容量为8</span><br></code></pre></td></tr></table></figure><p>map 类型的容量不会受限于它的初始容量值，当其中的键值对数量超过初始容量后，Go 运行时会自动增加 map 类型的容量，保证后续键值对的正常插入。</p><h5 id="map-的基本操作"><a href="#map-的基本操作" class="headerlink" title="map 的基本操作"></a>map 的基本操作</h5><p>插入新键值对、获取当前键值对数量、查找特定键和读取对应值、删除键值对，以及遍历键值等操作<br><strong>操作一：插入新键值对。</strong><br>面对一个非 nil 的 map 类型变量，我们可以在其中插入符合 map 类型定义的任意新键值对。插入新键值对的方式很简单，我们只需要把 value 赋值给 map 中对应的 key 就可以了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;value1&quot;</span><br>m[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;value2&quot;</span><br>m[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;value3&quot;</span><br></code></pre></td></tr></table></figure><p>而且，我们不需要自己判断数据有没有插入成功，因为 Go 会保证插入总是成功的。这里，Go 运行时会负责 map 变量内部的内存管理，因此除非是系统内存耗尽，我们可以不用担心向 map 中插入新数据的数量和执行结果。<br>如果我们插入新键值对的时候，某个 key 已经存在于 map 中了，那我们的插入操作就会用新值覆盖旧值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>m[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-number">11</span> <span class="hljs-comment">// 11会覆盖掉&quot;key1&quot;对应的旧值1</span><br>m[<span class="hljs-string">&quot;key3&quot;</span>] = <span class="hljs-number">3</span>  <span class="hljs-comment">// 此时m为map[key1:11 key2:2 key3:3]</span><br></code></pre></td></tr></table></figure><p><strong>操作二：获取键值对数量。</strong><br>和切片一样，map 类型也可以通过内置函数 len，获取当前变量已经存储的键值对数量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>fmt.Println(<span class="hljs-built_in">len</span>(m)) <span class="hljs-comment">// 2</span><br>m[<span class="hljs-string">&quot;key3&quot;</span>] = <span class="hljs-number">3</span>  <br>fmt.Println(<span class="hljs-built_in">len</span>(m)) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>不过，这里要注意的是<strong>我们不能对 map 类型变量调用 cap，来获取当前容量，这是 map 类型与切片类型的一个不同点。</strong> (底层实现不同，切片连续数组，map 底层一般为 RBTree)</p><p><strong>操作三：查找和数据读取</strong><br>和写入相比，map 类型更多用在查找和数据读取场合。所谓查找，就是判断某个 key 是否存在于某个 map 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// 1 错误的查找方法 即使&quot;key1&quot;不在map中，v还是会得到一个int的零值、</span><br>v := m[<span class="hljs-string">&quot;key1&quot;</span>] <br></code></pre></td></tr></table></figure><p>上面 1 这样是无法确定键 key1 是否真实存在于 map 中的。如果这个键在 map 中并不存在，我们也会得到一个值，这个值是 value 元素类型的零值。 如果键 key1 在 map 中并不存在，那么 v 的值就会被赋予 value 元素类型 int 的零值，也就是 0。所以我们无法通过 v 值判断出，究竟是因为 key1 不存在返回的零值，还是因为 key1 本身对应的 value 就是 0。</p><p>正确姿势是：<strong>Go 语言的 map 类型支持通过用一种名为“comma ok”的惯用法，进行对某个 key 的查询。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 2 正确的方法</span><br>v, ok := m[<span class="hljs-string">&quot;key1&quot;</span>]<br><span class="hljs-keyword">if</span> !ok &#123;    <br>	<span class="hljs-comment">// &quot;key1&quot;不在map中</span><br>	&#125;<br><span class="hljs-comment">// &quot;key1&quot;在map中，v将被赋予&quot;key1&quot;键对应的value</span><br></code></pre></td></tr></table></figure><p><strong>操作四：删除数据。</strong><br>在 Go 中，我们需要借助内置函数 delete 来从 map 中删除数据。<strong>delete 函数是从 map 中删除键的唯一方法。</strong> 使用 delete 函数的情况下，传入的第一个参数是我们的 map 类型变量，第二个参数就是我们想要删除的键。即便传给 delete 的键在 map 中并不存在，delete 函数的执行也不会失败，更不会抛出运行时的异常。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>fmt.Println(m) <span class="hljs-comment">// map[key1:1 key2:2]</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key2&quot;</span>) <span class="hljs-comment">// 删除&quot;key2&quot;</span><br>fmt.Println(m) <span class="hljs-comment">// map[key1:1]</span><br></code></pre></td></tr></table></figure><p><strong>操作五：遍历 map 中的键值数据</strong><br>遍历 map 的键值对只有一种方法，那就是像对待切片那样通过 for range 语句对 map 数据进行遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-number">1</span>: <span class="hljs-number">11</span>,<br>        <span class="hljs-number">2</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-number">3</span>: <span class="hljs-number">13</span>,<br>    &#125;<br><br>    fmt. Printf (<span class="hljs-string">&quot;&#123; &quot;</span>)<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;[%d, %d] &quot;</span>, k, v)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;&#125;\n&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是注意：<strong>对同一 map 做多次遍历的时候，每次遍历元素的次序都不相同。</strong> 因此，程序逻辑千万不要依赖遍历 map 所得到的的元素次序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doIteration</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;&#123; &quot;</span>)<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;[%d, %d] &quot;</span>, k, v)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;&#125;\n&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-number">1</span>: <span class="hljs-number">11</span>,<br>        <span class="hljs-number">2</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-number">3</span>: <span class="hljs-number">13</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>        doIteration(m)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出</span><br>&#123; [<span class="hljs-number">3</span>, <span class="hljs-number">13</span>] [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>] [<span class="hljs-number">2</span>, <span class="hljs-number">12</span>] &#125;<br>&#123; [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>] [<span class="hljs-number">2</span>, <span class="hljs-number">12</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">13</span>] &#125;<br>&#123; [<span class="hljs-number">3</span>, <span class="hljs-number">13</span>] [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>] [<span class="hljs-number">2</span>, <span class="hljs-number">12</span>] &#125;<br></code></pre></td></tr></table></figure><h5 id="map-变量的传递开销"><a href="#map-变量的传递开销" class="headerlink" title="map 变量的传递开销"></a>map 变量的传递开销</h5><p>和切片类型一样，map 也是引用类型。这就意味着 map 类型变量作为参数被传递给函数或方法的时候，实质上传递的只是一个“描述符”，而不是整个 map 的数据拷贝，所以这个传递的开销是固定的，而且也很小。<br>并且，不同于切片，当 map 变量被传递到函数或方法内部后，我们在函数内部对 map 类型参数的修改在函数外部也是可见的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    m[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-number">11</span><br>    m[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-number">12</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-string">&quot;key1&quot;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&quot;key2&quot;</span>: <span class="hljs-number">2</span>,<br>    &#125;<br><br>    fmt.Println(m) <span class="hljs-comment">// map[key1:1 key2:2]  </span><br>    foo(m)<br>    fmt.Println(m) <span class="hljs-comment">// map[key1:11 key2:12] </span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="map-的内部实现"><a href="#map-的内部实现" class="headerlink" title="map 的内部实现"></a>map 的内部实现</h5><p>Go 运行时使用一张哈希表来实现抽象的 map 类型。运行时实现了 map 类型操作的所有功能，包括查找、插入、删除等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建map类型变量实例</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[keyType]valType, capacityhint)<br>→ m := runtime.makemap(maptype, capacityhint, m)<br><span class="hljs-comment">// 插入新键值对或给键重新赋值</span><br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span><br>→ v := runtime. mapassign (maptype, m, <span class="hljs-string">&quot;key&quot;</span>) v 是用于后续存储 value 的空间的地址<br><span class="hljs-comment">// 获取某键的值 </span><br>v := m[<span class="hljs-string">&quot;key&quot;</span>]      <br>→ v := runtime.mapaccess1(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br>v, ok := m[<span class="hljs-string">&quot;key&quot;</span>]  <br>→ v, ok := runtime.mapaccess2(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br><span class="hljs-comment">// 删除某键</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key&quot;</span>)   <br>→ runtime.mapdelete(maptype, m, “key”)<br></code></pre></td></tr></table></figure><p>（略）</p><h5 id="map-扩容"><a href="#map-扩容" class="headerlink" title="map 扩容"></a>map 扩容</h5><p>(略)</p><h5 id="map-与并发"><a href="#map-与并发" class="headerlink" title="map 与并发"></a>map 与并发</h5><p>map 实例不是并发写安全的，也不支持并发读写。如果我们对 map 实例进行并发读写，程序运行时就会抛出异常。<br>不过，如果我们仅仅是进行并发读，map 是没有问题的。而且，Go 1.9 版本中引入了支持并发写安全的 sync. Map 类型，可以在并发读写的场景下替换掉 map。</p><p>考虑到 map 可以自动扩容，map 中数据元素的 value 位置可能在这一过程中发生变化，所以 Go 不允许获取 map 中 value 的地址，这个约束是在编译期间就生效的。</p><h5 id="使用-map-的三个要点"><a href="#使用-map-的三个要点" class="headerlink" title="使用 map 的三个要点"></a>使用 map 的三个要点</h5><ul><li>不要依赖 map 的元素遍历顺序；</li><li>map 不是线程安全的，不支持并发读写；</li><li>不要尝试获取 map 中元素（value）的地址。</li></ul><h5 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h5><p><a target="_blank" rel="noopener" href="https://www.qcrao.com/2019/05/22/dive-into-go-map/">https://www.qcrao.com/2019/05/22/dive-into-go-map/</a><br><a target="_blank" rel="noopener" href="https://qcrao.com/2020/05/06/dive-into-go-sync-map/">https://qcrao.com/2020/05/06/dive-into-go-sync-map/</a><br><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/</a></p><h4 id="Struct-自定义类型"><a href="#Struct-自定义类型" class="headerlink" title="Struct 自定义类型"></a>Struct 自定义类型</h4><h5 id="如何自定义一个新类型？"><a href="#如何自定义一个新类型？" class="headerlink" title="如何自定义一个新类型？"></a>如何自定义一个新类型？</h5><p>自定义一个新类型一般有两种方法。<br><strong>第一种是类型定义（Type Definition</strong>），这也是我们最常用的类型定义方法。在这种方法中，我们会使用关键字 type 来定义一个新类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T S <span class="hljs-comment">// 定义一个新类型T</span><br></code></pre></td></tr></table></figure><p><strong>第二种自定义新类型的方式是使用类型别名（Type Alias）</strong>，这种类型定义方式通常用在项目的渐进式重构，还有对已有包的二次封装方面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T = S <span class="hljs-comment">// type alias</span><br></code></pre></td></tr></table></figure><h5 id="如何定义一个结构体类型？"><a href="#如何定义一个结构体类型？" class="headerlink" title="如何定义一个结构体类型？"></a>如何定义一个结构体类型？</h5><p>典型的结构体类型的定义形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    Field1 T1<br>    Field2 T2<br>    ... ...<br>    FieldN Tn<br>&#125;<br></code></pre></td></tr></table></figure><p>struct 关键字后面的大括号包裹的内容就是一个<strong>类型字面值</strong>。这个类型字面值由若干个字段（field）聚合而成，每个字段有自己的名字与类型，并且在一个结构体中，每个字段的名字应该都是唯一的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> book<br><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>     Title <span class="hljs-type">string</span>              <span class="hljs-comment">// 书名</span><br>     Pages <span class="hljs-type">int</span>                 <span class="hljs-comment">// 书的页数</span><br>     Indexes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>    <span class="hljs-comment">// 书的索引</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类型 Book 的类型名“Book”以及内部的各个字段中首字母大写的原因是这样类型 Book 以及它的各个字段都是导出标识符，只要其他包导入了包 book，我们就可以在这些包中直接引用类型名 Book，也可以通过 Book 类型变量引用 Name、Pages 等字段。<br>而如果结构体类型只在它定义的包内使用，那么我们可以将类型名的首字母小写；如果你不想将结构体类型中的某个字段暴露给其他包，那么我们同样可以把这个字段名字的首字母小写。<br>还可以用空标识符“_”作为结构体类型定义中的字段名称。这样以空标识符为名称的字段，不能被外部包引用，甚至无法被结构体所在的包使用。</p><h6 id="特殊情况-特殊但是不少见"><a href="#特殊情况-特殊但是不少见" class="headerlink" title="特殊情况 (特殊但是不少见)"></a>特殊情况 (特殊但是不少见)</h6><p><strong>第一种：定义一个空结构体。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// Empty是一个不包含任何字段的空结构体类型</span><br></code></pre></td></tr></table></figure><p>空结构体类型有什么用?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s Empty<br><span class="hljs-built_in">println</span>(unsafe.Sizeof(s)) <span class="hljs-comment">// 0 空结构体类型变量的内存占用为 0。</span><br></code></pre></td></tr></table></figure><p>基于空结构体类型内存零开销这样的特性，我们在日常 Go 开发中会经常使用空结构体类型元素，作为一种“事件”信息进行 Goroutine 之间的通信。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Empty) <span class="hljs-comment">// 声明一个元素类型为Empty的channel</span><br>c&lt;-Empty&#123;&#125;               <span class="hljs-comment">// 向channel写入一个“事件”</span><br></code></pre></td></tr></table></figure><p>这种以空结构体为元素类建立的 channel，是目前能实现的、内存占用最小的 Goroutine 间通信方式。</p><p><strong>第二种情况：使用其他结构体作为自定义结构体中字段的类型。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Phone <span class="hljs-type">string</span><br>    Addr <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span><br>    Author Person<br>    ... ...<br>&#125;<br><span class="hljs-comment">//如果我们要访问 Book 结构体字段 Author 中的 Phone 字段，我们可以这样操作</span><br><span class="hljs-keyword">var</span> book Book <br><span class="hljs-built_in">println</span>(book.Author.Phone)<br></code></pre></td></tr></table></figure><p>不过，对于包含结构体类型字段的结构体类型来说，Go 还提供了一种更为简便的定义方法，那就是我们可以无需提供字段的名字，只需要使用其类型就可以了，以上面的 Book 结构体定义的一个等价的定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span><br>    Person<br>    ... ...<br>&#125;<br><br><span class="hljs-keyword">var</span> book Book <br><span class="hljs-built_in">println</span>(book.Person.Phone) <span class="hljs-comment">// 将类型名当作嵌入字段的名字</span><br><span class="hljs-built_in">println</span>(book.Phone)        <span class="hljs-comment">// 支持直接访问嵌入字段所属类型中字段</span><br></code></pre></td></tr></table></figure><p>以这种方式定义的结构体字段，我们叫做<strong>嵌入字段（Embedded Field）</strong> 或者 <strong>匿名字段</strong>。<br>这样就可以把类型名当作嵌入字段的名字来进行操作的，而第二种方式更像是一种“语法糖”，我们可以“绕过”Person 类型这一层，直接访问 Person 中的字段。</p><p><strong>Go 语言不支持这种在结构体类型定义中，递归地放入其自身类型字段的定义方式</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第一种</span><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    t T  <br>    ... ...<br>&#125;<br><span class="hljs-comment">// 第二种</span><br><span class="hljs-keyword">type</span> T1 <span class="hljs-keyword">struct</span> &#123;<br>  t2 T2<br>&#125;<br><span class="hljs-keyword">type</span> T2 <span class="hljs-keyword">struct</span> &#123;<br>  t1 T1<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，虽然我们不能在结构体类型 T 定义中，拥有以自身类型 T 定义的字段，但却<strong>可以拥有自身类型的指针类型、以自身类型为元素类型的切片类型，以及以自身类型作为 value 类型的 map 类型的字段</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    t  *T           <span class="hljs-comment">// ok</span><br>    st []T          <span class="hljs-comment">// ok</span><br>    m  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]T <span class="hljs-comment">// ok</span><br>&#125;     <br></code></pre></td></tr></table></figure><h5 id="结构体变量的声明与初始化"><a href="#结构体变量的声明与初始化" class="headerlink" title="结构体变量的声明与初始化"></a>结构体变量的声明与初始化</h5><p>可以使用标准变量声明语句，或者是短变量声明语句声明一个结构体类型的变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">var</span> book Book<br><span class="hljs-keyword">var</span> book = Book&#123;&#125;<br>book := Book&#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>结构体类型的变量通常都要被赋予适当的初始值后，才会有合理的意义。</strong></p><h6 id="零值初始化"><a href="#零值初始化" class="headerlink" title="零值初始化"></a>零值初始化</h6><p>零值初始化说的是使用结构体的类型的默认值作为它的初始值。Go 结构体类型由若干个字段组成，当这个结构体类型变量的各个字段的值都是零值时，我们就说这个结构体类型变量处于零值状态。<br>虽然不是所有结构体的零值初始化有意义，但是如果一种类型采用零值初始化得到的零值变量，是有意义的，而且是直接可用的，我称这种类型为“零值可用”类型。可以说，定义零值可用类型是简化代码、改善开发者使用体验的一种重要的手段。<br>下面这个就是不适合零值初始化，因为没有意义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> book Book <span class="hljs-comment">// book 为零值结构体变量</span><br></code></pre></td></tr></table></figure><p>而在 Go 语言标准库和运行时的代码中，有很多践行“零值可用”理念的好例子，最典型的莫过于 sync 包的 Mutex 类型了。Mutex 是 Go 标准库中提供的、用于多个并发 Goroutine 之间进行同步的互斥锁。</p><p>运用“零值可用”类型，给 Go 语言中的线程互斥锁带来了什么好处呢？对比一下 C 语言就知道了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> mutex; <br>pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br><br>pthread_mutex_lock(&amp;mutex); <br>... ...<br>pthread_mutex_unlock(&amp;mutex); <br></code></pre></td></tr></table></figure><p>在 C 中使用互斥锁，我们需要首先声明一个 mutex 变量。但这个时候，我们不能直接使用声明过的变量，因为它的零值状态是不可用的，我们必须使用 pthread_mutex_init 函数对其进行专门的初始化操作后，它才能处于可用状态。再之后，我们才能进行 lock 与 unlock 操作。<br>但是在 Go 语言中，我们只需要这几行代码就可以了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex<br>mu.Lock()<br>mu.Unlock()<br></code></pre></td></tr></table></figure><p>Go 标准库的设计者很贴心地将 sync. Mutex 结构体的零值状态，设计为可用状态，这样开发者便可直接基于零值状态下的 Mutex 进行 lock 与 unlock 操作，而且不需要额外显式地对它进行初始化操作了。<br>Go 标准库中的 bytes. Buffer 结构体类型，也是一个零值可用类型的典型例子，这里我演示了 bytes. Buffer 类型的常规用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b bytes.Buffer<br>b.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, Go&quot;</span>))<br>fmt.Println(b.String()) <span class="hljs-comment">// 输出：Hello, Go</span><br></code></pre></td></tr></table></figure><p>我们不需要对 bytes. Buffer 类型的变量 b 进行任何显式初始化，就可以直接通过处于零值状态的变量 b，调用它的方法进行写入和读取操作。</p><h6 id="使用复合字面值"><a href="#使用复合字面值" class="headerlink" title="使用复合字面值"></a>使用复合字面值</h6><p>最简单的对结构体变量进行显式初始化的方式，就是按<strong>顺序依次给每个结构体字段进行赋值</strong>，比如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span>              <span class="hljs-comment">// 书名</span><br>    Pages <span class="hljs-type">int</span>                 <span class="hljs-comment">// 书的页数</span><br>    Indexes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>    <span class="hljs-comment">// 书的索引</span><br>&#125;<br><br><span class="hljs-keyword">var</span> book = Book&#123;<span class="hljs-string">&quot;The Go Programming Language&quot;</span>, <span class="hljs-number">700</span>, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)&#125;<br></code></pre></td></tr></table></figure><p>不过这种方式很麻烦，而且一旦结构体中包含非导出字段，那么这种逐一字段赋值的方式就不再被支持了，编译会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    F1 <span class="hljs-type">int</span><br>    F2 <span class="hljs-type">string</span><br>    f3 <span class="hljs-type">int</span><br>    F4 <span class="hljs-type">int</span><br>    F5 <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> t = T&#123;<span class="hljs-number">11</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">13</span>&#125; <span class="hljs-comment">// 错误：implicit assignment of unexported field &#x27;f3&#x27; in T literal</span><br>或<br><span class="hljs-keyword">var</span> t = T&#123;<span class="hljs-number">11</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125; <span class="hljs-comment">// 错误：implicit assignment of unexported field &#x27;f3&#x27; in T literal</span><br></code></pre></td></tr></table></figure><p>Go 语言并不推荐我们按字段顺序对一个结构体类型变量这样进行显式初始化。<br>Go 推荐我们用 <strong>“field: value”形式的复合字面值</strong>，对结构体类型变量进行显式初始化，这种方式可以降低结构体类型使用者和结构体类型设计者之间的耦合，这也是 Go 语言的惯用法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t = T&#123;<br>    F2: <span class="hljs-string">&quot;hello&quot;</span>,<br>    F1: <span class="hljs-number">11</span>,<br>    F4: <span class="hljs-number">14</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>复合字面值作为结构体类型变量初值被广泛使用，即便结构体采用类型零值时，我们也会使用复合字面值的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">t := T&#123;&#125;<br></code></pre></td></tr></table></figure><p>而比较少使用 new 这一个 Go 预定义的函数来创建结构体变量实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">tp := <span class="hljs-built_in">new</span>(T)<br></code></pre></td></tr></table></figure><p>如果一个结构体类型中包含未导出字段，并且这个字段的零值还不可用时，我们要如何初始化这个结构体类型的变量呢？又或是一个结构体类型中的某些字段，需要一个复杂的初始化逻辑，我们又该怎么做呢？这时我们就需要使用一个特定的构造函数，来创建并初始化结构体变量了。</p><h6 id="使用特定的构造函数"><a href="#使用特定的构造函数" class="headerlink" title="使用特定的构造函数"></a>使用特定的构造函数</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/time/sleep.go</span><br><span class="hljs-keyword">type</span> runtimeTimer <span class="hljs-keyword">struct</span> &#123;<br>    pp       <span class="hljs-type">uintptr</span><br>    when     <span class="hljs-type">int64</span><br>    period   <span class="hljs-type">int64</span><br>    f        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">uintptr</span>)</span></span> <br>    arg      <span class="hljs-keyword">interface</span>&#123;&#125;<br>    seq      <span class="hljs-type">uintptr</span><br>    nextwhen <span class="hljs-type">int64</span><br>    status   <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Timer <span class="hljs-keyword">struct</span> &#123;<br>    C &lt;-<span class="hljs-keyword">chan</span> Time<br>    r runtimeTimer<br>&#125;<br><br><span class="hljs-comment">// $GOROOT/src/time/sleep.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTimer</span><span class="hljs-params">(d Duration)</span></span> *Timer &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Time, <span class="hljs-number">1</span>)<br>    t := &amp;Timer&#123;<br>        C: c,<br>        r: runtimeTimer&#123;<br>            when: when(d),<br>            f:    sendTime,<br>            arg:  c,<br>        &#125;,<br>    &#125;<br>    startTimer(&amp;t.r)<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><p>NewTimer 这个函数只接受一个表示定时时间的参数 d，在经过一个复杂的初始化过程后，它返回了一个处于可用状态的 Timer 类型指针实例。<br>专用构造函数大多都符合以下模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewT</span><span class="hljs-params">(field1, field2, ...)</span></span> *T &#123;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>NewT 是结构体类型 T 的专用构造函数，它的参数列表中的参数通常与 T 定义中的导出字段相对应，返回值则是一个 T 指针类型的变量。T 的非导出字段在 NewT 内部进行初始化，一些需要复杂初始化逻辑的字段也会在 NewT 内部完成初始化。这样，我们只要调用 NewT 函数就可以得到一个可用的 T 指针类型变量了。</p><h5 id="结构体类型的内存布局（内存对齐）"><a href="#结构体类型的内存布局（内存对齐）" class="headerlink" title="结构体类型的内存布局（内存对齐）"></a>结构体类型的内存布局（内存对齐）</h5><p>我们可以借助标准库 unsafe 包提供的函数，获得结构体类型变量占用的内存大小，以及它每个字段在内存中相对于结构体变量起始地址的偏移量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t T<br>unsafe.Sizeof(t)      <span class="hljs-comment">// 结构体类型变量占用的内存大小</span><br>unsafe.Offsetof(t.Fn) <span class="hljs-comment">// 字段Fn在内存中相对于变量t起始地址的偏移量</span><br></code></pre></td></tr></table></figure><p>![[【Go基础】未整理合集&#x2F;Pasted image 20230214104520.png]]<br>在真实情况下，虽然 Go 编译器没有在结构体变量占用的内存空间中插入额外字段，但结构体字段实际上可能并不是紧密相连的，中间可能存在“缝隙”。这些“缝隙”同样是结构体变量占用的内存空间的一部分，它们是 Go 编译器插入的“填充物（Padding）”。<br>这因为需要<strong>内存对齐</strong>。所谓内存对齐，指的就是各种内存对象的内存地址不是随意确定的，必须满足特定要求。<br>对于各种基本数据类型来说，它的变量的内存地址值必须是其类型本身大小的整数倍，比如，一个 int64 类型的变量的内存地址，应该能被 int64 类型自身的大小，也就是 8 整除；一个 uint16 类型的变量的内存地址，应该能被 uint16 类型自身的大小，也就是 2 整除。<br>对于结构体而言，它的变量的内存地址，只要是它最长字段长度与系统对齐系数两者之间较小的那个的整数倍就可以了。但对于结构体类型来说，我们还要让它每个字段的内存地址都严格满足内存对齐要求。(省略了一些内存对齐的计算过程) 总结就是：结构体不仅内部字段需要进行内存对齐，结构体整体也要对齐，为了结构体整体的对齐，结构体尾部也会有些填充。</p><p>**Go 语言中结构体类型的大小受内存对齐约束的影响。**不同的字段排列顺序也会影响到“填充字节”的多少，从而影响到整个结构体大小。比如下面两个结构体类型表示的抽象是相同的，但正是因为字段排列顺序不同，导致它们的大小也不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    b <span class="hljs-type">byte</span><br>    i <span class="hljs-type">int64</span><br>    u <span class="hljs-type">uint16</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>    b <span class="hljs-type">byte</span><br>    u <span class="hljs-type">uint16</span><br>    i <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-built_in">println</span> (unsafe. Sizeof (t)) <span class="hljs-comment">// 24</span><br>    <span class="hljs-keyword">var</span> s S<br>    <span class="hljs-built_in">println</span>(unsafe.Sizeof(s)) <span class="hljs-comment">// 16</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了节省内存占用，当前结构体类型声明时须自行排位字段。总体原则是要么由小到大，要么由大到小，保持有序，避免随意排列。可以用 unsafe. Alignof 查看各类型的对齐系数。</p><p>通常的内存填充部分，是由编译器自动完成的。不过，有些时候，为了保证某个字段的内存地址有更为严格的约束，我们也会做主动填充。比如 runtime 包中的 mstats 结构体定义就采用了主动填充：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/runtime/mstats.go</span><br><span class="hljs-keyword">type</span> mstats <span class="hljs-keyword">struct</span> &#123;<br>    ... ...<br>    <span class="hljs-comment">// Add an uint32 for even number of size classes to align below fields</span><br>    <span class="hljs-comment">// to 64 bits for atomic operations on 32 bit platforms.</span><br>    _ [<span class="hljs-number">1</span> - _NumSizeClasses%<span class="hljs-number">2</span>]<span class="hljs-type">uint32</span> <span class="hljs-comment">// 这里做了主动填充</span><br><br>    last_gc_nanotime <span class="hljs-type">uint64</span> <span class="hljs-comment">// last gc (monotonic time)</span><br>    last_heap_inuse  <span class="hljs-type">uint64</span> <span class="hljs-comment">// heap_inuse at mark termination of the previous GC</span><br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体类型是既数组类型之后，又一个以平铺形式存放在连续内存块中的类型。不过与数组类型不同，由于内存对齐的要求，结构体类型各个相邻字段间可能存在“填充物”，结构体的尾部同样可能被 Go 编译器填充额外的字节，满足结构体整体对齐的约束。</p><h5 id="扩展阅读-2"><a href="#扩展阅读-2" class="headerlink" title="扩展阅读"></a>扩展阅读</h5><p><a target="_blank" rel="noopener" href="https://geektutu.com/post/hpg-struct-alignment.html">Go struct 内存对齐 | Go 语言高性能编程 | 极客兔兔</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017527311">php - 在 Go 中恰到好处的内存对齐 - 煎鱼的清汤锅 - SegmentFault 思否</a></p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>Go 提供了 if 和 switch-case 两种语句形式；而针对循环结构，Go 只保留了 for 这一种循环语句形式。<br>在 C 语言基础上 Go 的改进点：</p><ul><li>Go 坚持“一件事情仅有一种做法的理念”，只保留了 for 这一种循环结构，去掉了 C 语言中的 while 和 do-while 循环结构；</li><li>Go 填平了 C 语言中 switch 分支结构中每个 case 语句都要以 break 收尾的“坑”；</li><li>Go 支持了 type switch 特性，让“类型”信息也可以作为分支选择的条件；</li><li>Go 的 switch 控制结构的 case 语句还支持表达式列表，让相同处理逻辑的多个分支可以合并为一个分支，等等。</li></ul><h3 id="If-分支结构"><a href="#If-分支结构" class="headerlink" title="If 分支结构"></a>If 分支结构</h3><p><strong>虽然各种编程语言几乎都原生支持了 if 语句，但 Go 的 if 语句依然有着自己的特点：</strong><br>第一，和 Go 函数一样，if 语句的分支代码块的左大括号与 if 关键字在同一行上，这也是 Go 代码风格的统一要求，gofmt 工具会帮助我们实现这一点；<br>第二，if 语句的布尔表达式整体不需要用括号包裹，一定程度上减少了开发人员敲击键盘的次数。而且，if 关键字后面的条件判断表达式的求值结果必须是布尔类型，即要么是 true，要么是 false：</p><p>会用到的一些操作符：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230214130331.png]]<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230214130423.png]]<br>如果记不住优先级顺序也没有关系的，使用带有小括号的子布尔表达式来清晰地表达判断条件就可以。<br><strong>多分枝结构</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> boolean_expression1 &#123;<br>  <span class="hljs-comment">// 分支1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> boolean_expression2 &#123;<br>  <span class="hljs-comment">// 分支2</span><br>... ...<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> boolean_expressionN &#123;<br>  <span class="hljs-comment">// 分支N</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 分支N+1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以在 if 后的布尔表达式前，进行一些变量的声明，这些变量只可以在 if 语句的代码块范围内使用，比如下面代码中的变量 a、b 和 c：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a, c := f(), h(); a &gt; <span class="hljs-number">0</span> &#123;<span class="hljs-comment">//由于声明本身是一个语句，所以我们需要把它和后面的布尔表达式通过分号分隔开。</span><br>        <span class="hljs-built_in">println</span>(a)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> b := f(); b &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println</span>(a, b)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println</span>(a, b, c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="if-语句的“快乐路径”原则"><a href="#if-语句的“快乐路径”原则" class="headerlink" title="if 语句的“快乐路径”原则"></a>if 语句的“快乐路径”原则</h5><p>从可读性上来看，单分支结构要优于二分支结构，二分支结构又优于多分支结构。那么显然，我们在日常编码中要减少多分支结构，甚至是二分支结构的使用，这会有助于我们编写出优雅、简洁、易读易维护且不易错的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">//伪代码段1：</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">if</span> errorCondition1 &#123;<br>    <span class="hljs-comment">// some error logic</span><br>    ... ...<br>    <span class="hljs-keyword">return</span> err1<br>  &#125;<br>  <br>  <span class="hljs-comment">// some success logic</span><br>  ... ...<br><br>  <span class="hljs-keyword">if</span> errorCondition2 &#123;<br>    <span class="hljs-comment">// some error logic</span><br>    ... ...<br>    <span class="hljs-keyword">return</span> err2<br>  &#125;<br><br>  <span class="hljs-comment">// some success logic</span><br>  ... ...<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 伪代码段 2：</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">if</span> successCondition1 &#123;<br>    <span class="hljs-comment">// some success logic</span><br>    ... ...<br><br>    <span class="hljs-keyword">if</span> successCondition2 &#123;<br>      <span class="hljs-comment">// some success logic</span><br>      ... ...<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// some error logic</span><br>      ... ...<br>      <span class="hljs-keyword">return</span> err2<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// some error logic</span><br>    ... ...<br>    <span class="hljs-keyword">return</span> err1<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的伪代码 1 比伪代码 2 易读。Go 社区把伪代码 1 的 if 语句的使用方式称为 if 语句的“<strong>快乐路径（Happy Path）</strong>”原则，所谓“快乐路径”也就是成功逻辑的代码执行路径，它的特点是这样的：</p><ul><li>仅使用单分支控制结构；</li><li>当布尔表达式求值为 false 时，也就是出现错误时，在单分支中快速返回；</li><li>正常逻辑在代码布局上始终“靠左”，这样读者可以从上到下一眼看到该函数正常逻辑的全貌；</li><li>函数执行到最后一行代表一种成功状态。<br>Go 社区推荐 Gopher 们在使用 if 语句时尽量符合这些原则，如果你的函数实现代码不符合“快乐路径”原则，你可以按下面步骤进行重构：</li><li>尝试将“正常逻辑”提取出来，放到“快乐路径”中；</li><li>如果无法做到上一点，很可能是函数内的逻辑过于复杂，可以将深度缩进到 else 分支中的代码析出到一个函数中，再对原函数实施“快乐路径”原则。</li></ul><h3 id="For-循环结构"><a href="#For-循环结构" class="headerlink" title="For 循环结构"></a>For 循环结构</h3><p>Go 只有 for 循环。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230214163055.png]]<br>在 C 语言基础上的突破和创新：<strong>Go 语言的 for 循环支持声明多循环变量，并且可以应用在循环体以及判断条件中</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, j, k := <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>; (i &lt; <span class="hljs-number">20</span>) &amp;&amp; (j &lt; <span class="hljs-number">10</span>) &amp;&amp; (k &lt; <span class="hljs-number">30</span>); i, j, k = i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>, k+<span class="hljs-number">5</span> &#123;<br>    sum += (i + j + k)<br>    <span class="hljs-built_in">println</span> (sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 for 循环中，循环体是必须，其他都可以省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10</span>; i++&#123;<br>    <span class="hljs-built_in">println</span>(i)<br>&#125;  <br><br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-built_in">println</span>(i)<br>    i++<br>&#125;  <br><br><br><span class="hljs-keyword">for</span> &#123; <br>   <span class="hljs-comment">// 循环体代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="for-range-循环形式"><a href="#for-range-循环形式" class="headerlink" title="for range 循环形式"></a>for range 循环形式</h5><p>Go 语言提供了一个方便的“语法糖”形式：for range</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;sl[%d] = %d\n&quot;</span>, i, sl[i])<br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> sl &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;sl[%d] = %d\n&quot;</span>, i, v)<br>&#125;<br><span class="hljs-comment">//　i和v分别为sl的下标值和元素值</span><br></code></pre></td></tr></table></figure><h6 id="For-range-的变种"><a href="#For-range-的变种" class="headerlink" title="For range 的变种"></a>For range 的变种</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//当我们不关心元素的值时，我们可以省略代表元素值的变量 v，只声明代表下标值的变量 i：</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br><br><span class="hljs-comment">// 如果我们不关心元素下标，只关心元素值，那么我们可以用空标识符替代代表下标值的变量 i。</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br><br><span class="hljs-comment">//既不关心下标值，也不关心元素值</span><br><span class="hljs-keyword">for</span> _, _ = <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br>或者更优雅的<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="一些类型的遍历"><a href="#一些类型的遍历" class="headerlink" title="一些类型的遍历"></a>一些类型的遍历</h6><p><strong>string 类型</strong><br>使用 for 经典形式与使用 for range 形式，对 string 类型进行循环操作的语义是不同的<br>for range 对于 string 类型来说，每次循环得到的 v 值是一个 <strong>Unicode 字符码点</strong>，也就是 rune 类型值，而不是一个字节，返回的第一个值 i 为该 Unicode 字符码点的内存编码（UTF-8）的第一个字节在字符串内存序列中的位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%d %s 0x%x\n&quot;</span>, i, <span class="hljs-type">string</span>(v), v)<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">0</span> 中 <span class="hljs-number">0x4e2d</span><br><span class="hljs-number">3</span> 国 <span class="hljs-number">0x56fd</span><br><span class="hljs-number">6</span> 人 <span class="hljs-number">0x4eba</span><br><span class="hljs-comment">//返回的 i 为该 Unicode 字符码点的内存编码（UTF-8）的字节在字符串内存序列中的位置。</span><br><span class="hljs-comment">//v 值是一个Unicode 字符码点</span><br></code></pre></td></tr></table></figure><p><strong>map</strong><br><strong>要对 map 进行循环操作，for range 是唯一的方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;Rob&quot;</span> : <span class="hljs-number">67</span>,<br>    <span class="hljs-string">&quot;Russ&quot;</span> : <span class="hljs-number">39</span>,<br>    <span class="hljs-string">&quot;John&quot;</span> : <span class="hljs-number">29</span>,<br>&#125;<br><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-built_in">println</span> (k, v)<br>&#125;<br><span class="hljs-comment">//输出</span><br>John <span class="hljs-number">29</span><br>Rob <span class="hljs-number">67</span><br>Russ <span class="hljs-number">39</span><br></code></pre></td></tr></table></figure><p><strong>channel</strong><br><strong>channel 是 Go 语言提供的并发设计的原语，它用于多个 Goroutine 之间的通信</strong><br>当 channel 类型变量作为 for range 语句的迭代对象时，for range 会尝试从 channel 中读取数据，使用形式是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> c &#123;<br>   <span class="hljs-comment">// ... </span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，for range 每次从 channel 中读取一个元素后，会把它赋值给循环变量 v，并进入循环体。当 channel 中没有数据可读的时候，for range 循环会阻塞在对 channel 的读操作上。直到 channel 关闭时，for range 循环才会结束，这也是 for range 循环与 channel 配合时隐含的循环判断条件。</p><h4 id="带-label-的-continue-语句"><a href="#带-label-的-continue-语句" class="headerlink" title="带 label 的 continue 语句"></a>带 label 的 continue 语句</h4><p>Go 语言中的 continue 在 C 语言 continue 语义的基础上又增加了对 label 的支持。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><br>loop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">if</span> sl[i]%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 忽略切片中值为偶数的元素</span><br>            <span class="hljs-keyword">continue</span> loop<br>        &#125;<br>        sum += sl[i]<br>    &#125;<br>    <span class="hljs-built_in">println</span>(sum) <span class="hljs-comment">// 9</span><br>&#125;<br></code></pre></td></tr></table></figure><p>带 label 的 continue 语句，通常出现于嵌套循环语句中，被<strong>用于跳转到外层循环并继续执行外层循环语句的下一个迭代</strong>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sl = [][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">26</span>, <span class="hljs-number">35</span>, <span class="hljs-number">78</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">45</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">99</span>&#125;,<br>        &#123;<span class="hljs-number">101</span>, <span class="hljs-number">13</span>, <span class="hljs-number">38</span>, <span class="hljs-number">7</span>, <span class="hljs-number">127</span>&#125;,<br>        &#123;<span class="hljs-number">54</span>, <span class="hljs-number">27</span>, <span class="hljs-number">40</span>, <span class="hljs-number">83</span>, <span class="hljs-number">81</span>&#125;,<br>    &#125;<br><br>outerloop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span> (sl); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(sl[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> sl[i][j] == <span class="hljs-number">13</span> &#123;<br>                fmt.Printf(<span class="hljs-string">&quot;found 13 at [%d, %d]\n&quot;</span>, i, j)<br>                <span class="hljs-keyword">continue</span> outerloop<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码段的逻辑就是在 sl 的每个元素切片中找到 13 这个数字，并输出它的具体位置信息。<br>它和 goto 是有区别的，如果换成 goto 那么不管是内层循环还是外层循环都会被终结，代码将会从 outerloop 这个 label 处，开始重新执行我们的嵌套循环语句，这与带 label 的 continue 的跳转语义是完全不同的。<br><strong>go 保留了 goto 但是最好不要用</strong></p><h4 id="break-语句的使用"><a href="#break-语句的使用" class="headerlink" title="break 语句的使用"></a>break 语句的使用</h4><p>Break 用于彻底跳出循环，和 continue 语句一样，break 语句增加了对 label 的支持。<br>而且，和前面 continue 语句一样，如果遇到嵌套循环，break 要想跳出外层循环，用不带 label 的 break 是不够，因为不带 label 的 break 仅能跳出其所在的最内层循环。要想实现外层循环的跳出，我们还需给 break 加上 label。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> gold = <span class="hljs-number">38</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sl = [][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">26</span>, <span class="hljs-number">35</span>, <span class="hljs-number">78</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">45</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">99</span>&#125;,<br>        &#123;<span class="hljs-number">101</span>, <span class="hljs-number">13</span>, <span class="hljs-number">38</span>, <span class="hljs-number">7</span>, <span class="hljs-number">127</span>&#125;,<br>        &#123;<span class="hljs-number">54</span>, <span class="hljs-number">27</span>, <span class="hljs-number">40</span>, <span class="hljs-number">83</span>, <span class="hljs-number">81</span>&#125;,<br>    &#125;<br><br>outerloop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(sl[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> sl[i][j] == gold &#123;<br>                fmt.Printf(<span class="hljs-string">&quot;found gold at [%d, %d]\n&quot;</span>, i, j)<br>                <span class="hljs-keyword">break</span> outerloop<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 sl 这个二维切片中找到 38 这个数字，并输出它的位置信息。整个二维切片中至多有一个值为 38 的元素，所以只要我们通过嵌套循环发现了 38，我们就不需要继续执行这个循环了。这时，我们通过带有 label 的 break 语句，就可以直接终结外层循环，从而从复杂多层次的嵌套循环中直接跳出，避免不必要的算力资源的浪费。</p><p>(感覺上面的这两个例子都可以直接用多个 continue 或者 break 就可以直接实现了。)</p><h4 id="for-语句的常见“坑”与避坑方法"><a href="#for-语句的常见“坑”与避坑方法" class="headerlink" title="for 语句的常见“坑”与避坑方法"></a>for 语句的常见“坑”与避坑方法</h4><h5 id="问题一：循环变量的重用"><a href="#问题一：循环变量的重用" class="headerlink" title="问题一：循环变量的重用"></a>问题一：循环变量的重用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;  <br>             <br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>            fmt.Println(i, v)<br>        &#125;()<br>    &#125;<br><br>    time.Sleep(time.Second * <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>示例是对一个整型切片进行遍历，并且在每次循环体的迭代中都会创建一个新的 Goroutine（Go 中的轻量级协程），输出这次迭代的元素的下标值与元素值。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">//预期结果</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-comment">//实际结果</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>i，v 在 for range 语句中仅会被声明一次，且在每次迭代中都会被重用。而不会次迭代都会重新声明两个新的变量 i 和 v。<br>出现与预期结果不符合的原因为：Goroutine 执行的闭包函数引用了它的外层包裹函数中的变量 i、v，这样，变量 i、v 在主 Goroutine 和新启动的 Goroutine 之间实现了共享，而 i, v 值在整个循环过程中是<strong>重用</strong>的，仅有一份。在 for range 循环结束后，i &#x3D; 4, v &#x3D; 5，因此各个 Goroutine 在等待 3 秒后进行输出的时候，输出的是 i, v 的最终值。</p><p>与预期相符的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, v <span class="hljs-type">int</span>)</span></span> &#123;<br>            time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>            fmt.Println(i, v)<br>        &#125;(i, v)<br>    &#125;<br><br>    time.Sleep(time.Second * <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="问题二：参与循环的是-range-表达式的副本"><a href="#问题二：参与循环的是-range-表达式的副本" class="headerlink" title="问题二：参与循环的是 range 表达式的副本"></a>问题二：参与循环的是 range 表达式的副本</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    <span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br>    fmt.Println(<span class="hljs-string">&quot;original a =&quot;</span>, a)<br><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>            a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>            a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>        &#125;<br>        r[i] = v<br>    &#125;<br><br>    fmt. Println (<span class="hljs-string">&quot;after for range loop, r =&quot;</span>, r)<br>    fmt.Println(<span class="hljs-string">&quot;after for range loop, a =&quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//预计输出</span><br>original a = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>after <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> loop, r = [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>after <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> loop, a = [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br><span class="hljs-comment">//实际输出</span><br>original a = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>after <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> loop, r = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]  <span class="hljs-comment">//这里很奇怪，r与未修改的a相同，而不是修改后的</span><br>after <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> loop, a = [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>发生这个误差的原因就是参与 for range 循环的是 range 表达式的副本，而不是它本身。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> aa &#123; <span class="hljs-comment">//aa是a的一个值拷贝</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>        a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>        a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>    &#125;<br>    r[i] = v<br>&#125;<br></code></pre></td></tr></table></figure><p>每次迭代的都是从数组 a 的值拷贝 a’中得到的元素。aa 是 Go 临时分配的连续字节序列，与 a 完全不是一块内存区域。因此无论 a 被如何修改，它参与循环的副本 aa 依旧保持原值，因此 v 从 aa 中取出的仍旧是 a 的原值，而不是修改后的值。</p><p><strong>避免方法就是使用切片</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    <span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br>    fmt.Println(<span class="hljs-string">&quot;original a =&quot;</span>, a)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a[:] &#123;  <span class="hljs-comment">//使用切片后，实际输出就和预期输出一样了 </span><br>    <span class="hljs-comment">//换成传数组地址&amp;a也行。</span><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>            a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>            a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>        &#125;<br>        r[i] = v<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;after for range loop, r =&quot;</span>, r)<br>    fmt.Println(<span class="hljs-string">&quot;after for range loop, a =&quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p>当进行 range 表达式复制时，我们实际上复制的是一个切片，也就是表示切片的结构体。表示切片副本的结构体中的 array，依旧指向原切片对应的底层数组，所以我们对切片副本的修改也都会反映到底层数组 a 上去。而 v 再从切片副本结构体中 array 指向的底层数组中，获取数组元素，也就得到了被修改后的元素值。</p><h5 id="问题三：遍历-map-中元素的随机性"><a href="#问题三：遍历-map-中元素的随机性" class="headerlink" title="问题三：遍历 map 中元素的随机性"></a>问题三：遍历 map 中元素的随机性</h5><p>如果我们在循环的过程中，对 map 进行了修改，那么这样修改的结果是否会影响后续迭代呢？<br>这个结果和我们遍历 map 一样，具有随机性。<br>这是因为对 map 迭代的实质是按顺序逐个 bucket 的遍历, 每个 bucket 也是逐个遍历其中的 key。如果在中途创建或删除的元素在第一个被遍历的元素之前了，那么后续就不会遍历它了。别忘了，key 存储在哪里是根据 hash 值来定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//例子一</span><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-string">&quot;tony&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-string">&quot;tom&quot;</span>:  <span class="hljs-number">22</span>,<br>    <span class="hljs-string">&quot;jim&quot;</span>:  <span class="hljs-number">23</span>,<br>&#125;<br><br>counter := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;tony&quot;</span>)<br>    &#125;<br>    counter++<br>    fmt.Println(k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;counter is &quot;</span>, counter)<br><br><span class="hljs-comment">//例子二</span><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-string">&quot;tony&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-string">&quot;tom&quot;</span>:  <span class="hljs-number">22</span>,<br>    <span class="hljs-string">&quot;jim&quot;</span>:  <span class="hljs-number">23</span>,<br>&#125;<br><br>counter := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123;<br>        m[<span class="hljs-string">&quot;lucy&quot;</span>] = <span class="hljs-number">24</span><br>    &#125;<br>    counter++<br>    fmt.Println(k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;counter is &quot;</span>, counter)<br></code></pre></td></tr></table></figure><p>以上的两个例子，运行的话都会有两个结果。</p><h3 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a>switch 结构</h3><p>暂时跳过</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数是唯一一种基于特定输入，实现特定任务并可返回任务执行结果的代码块（Go 语言中的方法本质上也是函数）</strong></p><h3 id="Go-函数与函数声明"><a href="#Go-函数与函数声明" class="headerlink" title="Go 函数与函数声明"></a>Go 函数与函数声明</h3><p><strong>普通 Go 函数的声明：</strong><br>![[【Go基础】未整理合集&#x2F;Pasted image 20230219191355.png]]</p><p>包含五个部分：</p><ul><li><strong>关键字 func</strong>，必需要以 func 开头</li><li><strong>函数名</strong>，在同一个 Go 包中，函数名应该是唯一的，遵守 Go 标识符的导出规则（首字母大小写）</li><li><strong>参数列表</strong>，参数列表紧接在函数名的后面，并用一个括号包裹，使用逗号作为参数间的分隔符</li><li><strong>返回值列表</strong>，返回值列表的位置紧接在参数列表后面，两者之间用一个空格隔开，Go 中不仅声明返回值的类型，还可以声明返回值的名称，声明名称的这种叫做<strong>具名返回值</strong></li><li><strong>函数体 (可选)</strong>，如果没有函数体，说明这个函数可能是在 Go 语言之外实现的</li></ul><p>把函数声明等价转换为变量声明的形式如下，可以发现：</p><ul><li>函数名其实就是变量名</li><li>函数声明中的 func 关键字、参数列表和返回值列表共同构成了<strong>函数类型</strong></li><li>参数列表与返回值列表的组合也被称为<strong>函数签名</strong></li><li><strong>函数签名</strong>是决定两个函数类型是否相同的决定因素。因此，函数类型也可以看成是由 func 关键字与函数签名组合而成的。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230219192429.png]]</li></ul><p>如果两个函数类型的函数签名是相同的，即便参数列表中的参数名，以及返回值列表中的返回值变量名都是不同的，那么这两个函数类型也是相同类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">string</span>)</span></span> (results []<span class="hljs-type">string</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c <span class="hljs-type">int</span>, d <span class="hljs-type">string</span>)</span></span> (sl []<span class="hljs-type">string</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-comment">//以上两个函数的函数签名相同，他们是相同类型的函数。</span><br></code></pre></td></tr></table></figure><p><strong>每个函数声明所定义的函数，仅仅是对应的函数类型的一个实例</strong>，就像 var a int &#x3D; 13 这个变量声明语句中 a 是 int 类型的一个实例一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := T&#123;&#125;      <span class="hljs-comment">// 使用复合类型字面值对结构体类型 T 的变量进行显式初始化</span><br>f := <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">// 使用变量声明形式的函数声明 这就是匿名函数</span><br></code></pre></td></tr></table></figure><p>上面的第二行特别像一个没有函数名的函数声明，因此我们叫它<strong>匿名函数</strong></p><h3 id="关于函数的参数"><a href="#关于函数的参数" class="headerlink" title="关于函数的参数"></a>关于函数的参数</h3><p>当我们实际调用函数的时候，实参会传递给函数，并和形式参数逐一绑定，编译器会根据各个形参的类型与数量，来检查传入的实参的类型与数量是否匹配。只有匹配，程序才能继续执行函数调用，否则编译器就会报错。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230219193032.png]]<br>】<br>Go 语言中，函数参数传递采用是<strong>值传递</strong>的方式。所谓“值传递”，就是将实际参数在内存中的表示逐位拷贝（Bitwise Copy）到形式参数中。<br>对于像整型、数组、结构体这类类型，它们的内存表示就是它们自身的数据内容，因此当这些类型作为实参类型时，值传递拷贝的就是它们自身，传递的开销也与它们自身的大小成正比。<br>但是像 string、切片、map 这些类型就不是了，它们的内存表示对应的是它们数据内容的“描述符”。当这些类型作为实参类型时，值传递拷贝的也是它们数据内容的“描述符”，不包括数据内容本身，所以这些类型传递的开销是固定的，与数据内容大小无关。这种只拷贝“描述符”，不拷贝实际数据内容的拷贝过程，也被称为“<strong>浅拷贝</strong>”。</p><p>不过函数参数的传递也有两个例外，当函数的形参为接口类型，或者形参是变长参数时，简单的值传递就不能满足要求了，这时 Go 编译器会介入：对于类型为接口类型的形参，Go 编译器会把传递的实参赋值给对应的接口类型形参；对于为变长参数的形参，Go 编译器会将零个或多个实参按一定形式转换为对应的变长形参。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAppend</span><span class="hljs-params">(sl []<span class="hljs-type">int</span>, elems ...<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, elems) <span class="hljs-comment">// []int   所以elems是个切片</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;no elems to append&quot;</span>)<br>        <span class="hljs-keyword">return</span> sl<br>    &#125;<br>    sl = <span class="hljs-built_in">append</span>(sl, elems...)<br>    <span class="hljs-keyword">return</span> sl<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    sl := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    sl = myAppend(sl) <span class="hljs-comment">// no elems to append</span><br>    fmt.Println(sl) <span class="hljs-comment">// [1 2 3]</span><br>    sl = myAppend(sl, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>    fmt.Println(sl) <span class="hljs-comment">// [1 2 3 4 5 6]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Go 中，<strong>变长参数实际上是通过切片来实现的</strong>。所以，我们在函数体中，就可以使用切片支持的所有操作来操作变长参数，这会大大简化了变长参数的使用复杂度。</p><h3 id="函数的多返回值"><a href="#函数的多返回值" class="headerlink" title="函数的多返回值"></a>函数的多返回值</h3><p>和其他主流静态类型语言，比如 C、C++ 和 Java 不同，Go 函数支持多返回值。多返回值可以让函数将更多结果信息返回给它的调用者。Go 语言的错误处理机制很大程度就是建立在多返回值的机制之上。<br>函数返回值列表从形式上看主要有三种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>                       <span class="hljs-comment">// 无返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>                 <span class="hljs-comment">// 仅有一个返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">string</span>, <span class="hljs-type">error</span>)  <span class="hljs-comment">// 有2或2个以上返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> (n <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>,err <span class="hljs-type">error</span>)  <span class="hljs-comment">// 多个具名返回值</span><br></code></pre></td></tr></table></figure><p>带有名字的返回值被称为<strong>具名返回值（Named Return Value）</strong>。<strong>这种具名返回值变量可以像函数体中声明的局部变量一样在函数体内使用。</strong><br>当函数的返回值个数较多时，每次显式使用 return 语句时都会接一长串返回值，这时，我们用具名返回值可以让函数实现的可读性更好一些</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/time/format.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseNanoseconds</span><span class="hljs-params">(value <span class="hljs-type">string</span>, nbytes <span class="hljs-type">int</span>)</span></span> (ns <span class="hljs-type">int</span>, rangeErrString <span class="hljs-type">string</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> !commaOrPeriod(value[<span class="hljs-number">0</span>]) &#123;<br>        err = errBad<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> ns, err = atoi(value[<span class="hljs-number">1</span>:nbytes]); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> ns &lt; <span class="hljs-number">0</span> || <span class="hljs-number">1e9</span> &lt;= ns &#123;<br>        rangeErrString = <span class="hljs-string">&quot;fractional second&quot;</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    scaleDigits := <span class="hljs-number">10</span> - nbytes<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; scaleDigits; i++ &#123;<br>        ns *= <span class="hljs-number">10</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数是“一等公民”（Go-函数的特征）"><a href="#函数是“一等公民”（Go-函数的特征）" class="headerlink" title="函数是“一等公民”（Go 函数的特征）"></a>函数是“一等公民”（Go 函数的特征）</h4><p><strong>一等公民的含义</strong>：如果一门编程语言对某种语言元素的创建和使用没有限制，我们可以像对待值（value）一样对待这种语法元素，那么我们就称这种语法元素是这门编程语言的“一等公民”。拥有“一等公民”待遇的语法元素可以存储在变量中，可以作为参数传递给函数，可以在函数内部创建并可以作为返回值从函数返回。</p><h5 id="特征一：Go-函数可以存储在变量中。"><a href="#特征一：Go-函数可以存储在变量中。" class="headerlink" title="特征一：Go 函数可以存储在变量中。"></a>特征一：Go 函数可以存储在变量中。</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    myFprintf = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w io.Writer, format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>        <span class="hljs-keyword">return</span> fmt.Fprintf(w, format, a...)<br>    &#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, myFprintf) <span class="hljs-comment">// func(io.Writer, string, ...interface &#123;&#125;) (int, error)</span><br>    myFprintf(os.Stdout, <span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Hello, Go&quot;</span>) <span class="hljs-comment">// 输出Hello，Go 和上一行的效果一致</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们把新创建的一个匿名函数赋值给了一个名为 myFprintf 的变量，通过这个变量，我们便可以调用刚刚定义的匿名函数。</p><h5 id="特征二：支持在函数内创建并通过返回值返回。"><a href="#特征二：支持在函数内创建并通过返回值返回。" class="headerlink" title="特征二：支持在函数内创建并通过返回值返回。"></a>特征二：支持在函数内创建并通过返回值返回。</h5><p>Go 函数不仅可以在函数外创建，还可以在函数内创建。而且由于函数可以存储在变量中，所以函数也可以在创建后，作为函数返回值返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span> <span class="hljs-params">(task <span class="hljs-type">string</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span> (<span class="hljs-string">&quot;do some setup stuff for&quot;</span>, task)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;do some teardown stuff for&quot;</span>, task)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    teardown := setup(<span class="hljs-string">&quot;demo&quot;</span>)<br>    <span class="hljs-keyword">defer</span> teardown()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;do some bussiness stuff&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子，模拟了执行一些重要逻辑之前的上下文建立（setup），以及之后的上下文拆除（teardown）。在一些单元测试的代码中，我们也经常会在执行某些用例之前，建立此次执行的上下文（setup），并在这些用例执行后拆除上下文（teardown），避免这次执行对后续用例执行的干扰。<br>在这个例子中，我们在 setup 函数中创建了这次执行的上下文拆除函数，并通过返回值的形式，将这个拆除函数返回给了 setup 函数的调用者。setup 函数的调用者，在执行完对应这次执行上下文的重要逻辑后，再调用 setup 函数返回的拆除函数，就可以完成对上下文的拆除了。<br><strong>(这部分不是很懂啊)</strong><br>setup 函数中创建的拆除函数也是一个匿名函数，但和前面我们看到的匿名函数有一个不同，这个不同就在于这个匿名函数使用了定义它的函数 setup 的局部变量 task，这样的匿名函数在 Go 中也被称为<strong>闭包（Closure）。</strong></p><p><strong>闭包</strong>本质上就是一个匿名函数或叫函数字面值，它们可以引用它的包裹函数，也就是创建它们的函数中定义的变量。然后，这些变量在包裹函数和匿名函数之间共享，只要闭包可以被访问，这些共享的变量就会继续存在。</p><h5 id="特征三：作为参数传入函数。"><a href="#特征三：作为参数传入函数。" class="headerlink" title="特征三：作为参数传入函数。"></a>特征三：作为参数传入函数。</h5><p>既然函数可以存储在变量中，也可以作为返回值返回，那我们可以理所当然地想到，把函数作为参数传入函数也是可行的。<br>这里通过 AfterFunc 函数设置了一个 2 秒的定时器，并传入了时间到了后要执行的函数。这里传入的就是一个匿名函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">time.AfterFunc(time.Second*<span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;timer fired&quot;</span>) &#125;)<br></code></pre></td></tr></table></figure><h5 id="特征四：拥有自己的类型。"><a href="#特征四：拥有自己的类型。" class="headerlink" title="特征四：拥有自己的类型。"></a>特征四：拥有自己的类型。</h5><p>每个函数都和整型值、字符串值等一等公民一样，拥有自己的类型，也就是我们讲过的<strong>函数类型</strong>。</p><p>我们甚至可以基于函数类型来自定义类型，就像基于整型、字符串类型等类型来自定义类型一样。下面代码中的 HandlerFunc、visitFunc 就是 Go 标准库中，基于函数类型进行自定义的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span></span><br><br><span class="hljs-comment">// $GOROOT/src/sort/genzfunc.go</span><br><span class="hljs-keyword">type</span> visitFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ast.Node)</span></span> ast.Visitor<br></code></pre></td></tr></table></figure><p><strong>这部分还是看不懂…</strong></p><h4 id="函数“一等公民”特性的高效运用"><a href="#函数“一等公民”特性的高效运用" class="headerlink" title="函数“一等公民”特性的高效运用"></a>函数“一等公民”特性的高效运用</h4><h5 id="应用一：函数类型的妙用"><a href="#应用一：函数类型的妙用" class="headerlink" title="应用一：函数类型的妙用"></a>应用一：函数类型的妙用</h5><p>Go 函数是“一等公民”，也就是说，它拥有自己的类型。而且，整型、字符串型等所有类型都可以进行的操作，比如显式转型，也就是说，<strong>函数也可以被显式转型</strong>。</p><p>函数的显式转形和整型变量是一样的, 都是要求底层类型相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">5</span><br>y := MyInt(x) <span class="hljs-comment">// MyInt的底层类型为int，类比HandlerFunc的底层类型为func(ResponseWriter, *Request)</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greeting</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome, Gopher!\n&quot;</span>)<br>&#125;                    <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, http.HandlerFunc(greeting))<span class="hljs-comment">//这里函数greeting被转换为了http.HandlerFunc类型</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="应用二：利用闭包简化函数调用。"><a href="#应用二：利用闭包简化函数调用。" class="headerlink" title="应用二：利用闭包简化函数调用。"></a>应用二：利用闭包简化函数调用。</h5><p>Go 闭包是在函数内部创建的匿名函数，这个匿名函数可以访问创建它的函数的参数与局部变量。我们可以利用闭包的这一特性来简化函数调用，这里我们看一个具体例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">times</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">return</span> x * y<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，times 函数用来进行两个整型数的乘法。我们使用 times 函数的时候需要传入两个实参，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">times(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算2 x 5</span><br>times(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算3 x 5</span><br>times(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算4 x 5</span><br></code></pre></td></tr></table></figure><p>不过，有些场景存在一些高频使用的乘数，这个时候我们就没必要每次都传入这样的高频乘数了。那我们怎样能省去高频乘数的传入呢? 我们看看下面这个新函数 partialTimes：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partialTimes</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> times(x, y)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，partialTimes 的返回值是一个接受单一参数的函数，这个由 partialTimes 函数生成的匿名函数，使用了 partialTimes 函数的参数 x。按照前面的定义，这个匿名函数就是一个闭包。partialTimes 实质上就是用来生成以 x 为固定乘数的、接受另外一个乘数作为参数的、闭包函数的函数。当程序调用 partialTimes (2) 时，partialTimes 实际上返回了一个调用 times (2, y) 的函数，这个过程的逻辑类似于下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">timesTwo = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> times(<span class="hljs-number">2</span>, y)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span> &#123;<br>  timesTwo := partialTimes(<span class="hljs-number">2</span>)   <span class="hljs-comment">// 以高频乘数2为固定乘数的乘法函数</span><br>  timesThree := partialTimes(<span class="hljs-number">3</span>) <span class="hljs-comment">// 以高频乘数3为固定乘数的乘法函数</span><br>  timesFour := partialTimes(<span class="hljs-number">4</span>)  <span class="hljs-comment">// 以高频乘数4为固定乘数的乘法函数</span><br>  fmt.Println(timesTwo(<span class="hljs-number">5</span>))   <span class="hljs-comment">// 10，等价于times(2, 5)</span><br>  fmt.Println(timesTwo(<span class="hljs-number">6</span>))   <span class="hljs-comment">// 12，等价于times(2, 6)</span><br>  fmt.Println(timesThree(<span class="hljs-number">5</span>)) <span class="hljs-comment">// 15，等价于times(3, 5)</span><br>  fmt.Println(timesThree(<span class="hljs-number">6</span>)) <span class="hljs-comment">// 18，等价于times(3, 6)</span><br>  fmt.Println(timesFour(<span class="hljs-number">5</span>))  <span class="hljs-comment">// 20，等价于times(4, 5)</span><br>  fmt.Println(timesFour(<span class="hljs-number">6</span>))  <span class="hljs-comment">// 24，等价于times(4, 6)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过 partialTimes，我们生成了三个带有固定乘数的函数。这样，我们在计算乘法时，就可以减少参数的重复输入。</p><p><strong>Go 语言中的函数可以理解为一种类型。</strong></p><h2 id="错误处理——结合函数的多返回值"><a href="#错误处理——结合函数的多返回值" class="headerlink" title="错误处理——结合函数的多返回值"></a>错误处理——结合函数的多返回值</h2><p>Go 语言错误处理机制是在 C 语言错误处理机制基础上的再创新。</p><p>在 C 语言中，我们通常用一个类型为整型的函数返回值作为错误状态标识，函数调用者会基于值比较的方式，对这一代表错误状态的返回值进行检视。通常，这个返回值为 0，就代表函数调用成功；如果这个返回值是其它值，那就代表函数调用出现错误。也就是说，函数调用者需要根据这个返回值代表的错误状态，来决定后续执行哪条错误处理路径上的代码。</p><p>C 语言错误处理的优点和缺点：<br><strong>优点</strong>：每个开发人员必须显式地去关注和处理每个错误，经过显式错误处理的代码会更健壮，也会让开发人员对这些代码更有信心。<br>错误就是普通的值，所以我们不需要用额外的语言机制去处理它们，我们只需利用已有的语言机制，像处理其他普通类型值一样的去处理错误就可以了，这也让代码更容易调试，更容易针对每个错误处理的决策分支进行测试覆盖。</p><p><strong>缺点</strong>：由于 C 语言中的函数最多仅支持一个返回值，很多开发者会把这单一的返回值“一值多用”。就是说，一个返回值，不仅要承载函数要返回给调用者的信息，又要承载函数调用的最终错误状态。<br>当返回值为其他类型，比如字符串的时候，我们还很难将它与错误状态融合到一起。这个时候，很多 C 开发人员要么使用输出参数，承载要返回给调用者的信息，要么自定义一个包含返回信息与错误状态的结构体，作为返回值类型。大家做法不一，就很难形成统一的错误处理策略。</p><p>在 Go 语言中，我们依然可以像传统的 C 语言那样，用一个整型值来表示错误状态，但 Go 语言惯用法，是使用 error 这个接口类型表示错误，并且按惯例，我们通常将 error 类型返回值放在返回值列表的末尾，就像 fmt. Fprintf 函数声明中这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// fmt包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprintf</span><span class="hljs-params">(w io.Writer, format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>另外我们还可以看到，fmt. Fprintf 函数声明中代表错误状态的变量 err 的类型，并不是一个传统使用的整数类型，而是用了一个名为 error 的类型。<br><strong>Go 语言惯用法</strong>：使用 error 这个接口类型表示错误，并将 error 类型返回值放在返回值列表的末。</p><h4 id="error-类型与错误值构造"><a href="#error-类型与错误值构造" class="headerlink" title="error 类型与错误值构造"></a>error 类型与错误值构造</h4><p>error 接口是 Go 原生内置的类型，它的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/builtin/builtin.go</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>任何实现了 error 的 Error 方法的类型的实例，都可以作为错误值赋值给 error 接口变量。<br>在标准库中提供了两种方便 Go 开发者构造错误值的方法： errors. New 和 fmt. Errorf。使用这两种方法，我们可以轻松构造出一个满足 error 接口的错误值，就像下面代码这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">err := errors.New(<span class="hljs-string">&quot;your first demo error&quot;</span>)<br>errWithCtx = fmt.Errorf(<span class="hljs-string">&quot;index %d is out of bounds&quot;</span>, i)<br></code></pre></td></tr></table></figure><p>这两种方法实际上返回的是同一个实现了 error 接口的类型的实例，这个未导出的类型就是 errors. errorString，它的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/errors/errors.go</span><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>    s <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></td></tr></table></figure><p>大多数情况下，使用这两种方法构建的错误值就可以满足我们的需求了。但我们也要看到，虽然这两种构建错误值的方法很方便，但它们<strong>给错误处理者提供的错误上下文（Error Context）只限于以字符串形式呈现的信息</strong>，也就是 Error 方法返回的信息。</p><p>在一些场景下，错误处理者需要从错误值中提取出更多信息，帮助他选择错误处理路径，显然这两种方法就不能满足了。这个时候，我们可以自定义错误类型来满足这一需求。比如：标准库中的 net 包就定义了一种携带额外错误上下文的错误类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> OpError <span class="hljs-keyword">struct</span> &#123;<br>    Op <span class="hljs-type">string</span><br>    Net <span class="hljs-type">string</span><br>    Source Addr<br>    Addr Addr<br>    Err <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，错误处理者就可以根据这个类型的错误值提供的额外上下文信息，比如 Op、Net、Source 等，做出错误处理路径的选择，比如下面标准库中的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isCommonNetReadError</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> err == io.EOF &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> oe, ok := err.(*net.OpError); ok &amp;&amp; oe.Op == <span class="hljs-string">&quot;read&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码利用类型断言，判断 error 类型变量 err 的动态类型是否为 *net. OpError 或 net. Error。如果 err 的动态类型是 *net. OpError，那么类型断言就会返回这个动态类型的值（存储在 oe 中），代码就可以通过判断它的 Op 字段是否为”read”来判断它是否为 CommonNetRead 类型的错误。不过这里，你不用过多了解类型断言（Type Assertion）到底是什么，你只需要知道通过类型断言，我们可以判断接口类型的动态类型，以及获取它动态类型的值接可以了。后面我们在讲解接口类型的时候还会再细讲。(还是没有怎么看懂…)<br>那么，使用 error 类型，而不是传统意义上的整型或其他类型作为错误类型，有什么好处呢？至少有这三点好处：<br><strong>第一点：统一了错误类型</strong>。<br>如果不同开发者的代码、不同项目中的代码，甚至标准库中的代码，都统一以 error 接口变量的形式呈现错误类型，就能在提升代码可读性的同时，还更容易形成统一的错误处理策略。这个我们下面会细讲。<br><strong>第二点：错误是值</strong><br>我们构造的错误都是值，也就是说，即便赋值给 error 这个接口类型变量，我们也可以像整型值那样对错误做“=&#x3D;”和“!&#x3D;”的逻辑比较，函数调用者检视错误时的体验保持不变。<br><strong>第三点：易扩展，支持自定义错误上下文。</strong><br>虽然错误以 error 接口变量的形式统一呈现，但我们很容易通过自定义错误类型来扩展我们的错误上下文，就像前面的 Go 标准库的 OpError 类型那样。error 接口是错误值的提供者与错误值的检视者之间的契约。error 接口的实现者负责提供错误上下文，供负责错误处理的代码使用。这种错误具体上下文与作为错误值类型的 error 接口类型的解耦，也体现了 Go 组合设计哲学中“正交”的理念。</p><p>Go 语言的几种错误处理的惯用策略：</p><h4 id="策略一：透明错误处理策略"><a href="#策略一：透明错误处理策略" class="headerlink" title="策略一：透明错误处理策略"></a>策略一：透明错误处理策略</h4><p>简单来说，Go 语言中的错误处理，就是根据函数 &#x2F; 方法返回的 error 类型变量中携带的错误值信息做决策，并选择后续代码执行路径的过程。</p><p><strong>最简单的错误策略</strong>莫过于完全不关心返回错误值携带的具体上下文信息，只要发生错误就进入唯一的错误处理执行路径，比如下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">err := doSomething ()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 不关心err变量底层错误值所携带的具体上下文信息</span><br>    <span class="hljs-comment">// 执行简单错误处理逻辑并返回</span><br>    ... ...<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>这也是 Go 语言中最常见的错误处理策略，80% 以上的 Go 错误处理情形都可以归类到这种策略下。<br>在这种策略下，由于错误处理方并不关心错误值的上下文，所以错误值的构造方（如上面的函数 doSomething）可以直接使用 Go 标准库提供的两个基本错误值构造方法 errors. New 和 fmt. Errorf 来构造错误值，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(...)</span></span> <span class="hljs-type">error</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;some error occurred&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样构造出的错误值代表的上下文信息，对错误处理方是透明的，因此这种策略称为“<strong>透明错误处理策略</strong>”。在错误处理方不关心错误值上下文的前提下，透明错误处理策略能最大程度地减少错误处理方与错误值构造方之间的耦合关系。</p><h4 id="策略二-：“哨兵”错误处理策略"><a href="#策略二-：“哨兵”错误处理策略" class="headerlink" title="策略二 ：“哨兵”错误处理策略"></a>策略二 ：“哨兵”错误处理策略</h4><p>当错误处理方不能只根据“透明的错误值”就做出错误处理路径选取的情况下，错误处理方会尝试对返回的错误值进行检视，于是就有可能出现下面代码中的<strong>反模式</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := b.Peek(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">switch</span> err.Error() &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: negative count&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: buffer full&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: invalid use of UnreadByte&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>反模式</strong>就是，错误处理方以透明错误值所能提供的唯一上下文信息（描述错误的字符串），作为错误处理路径选择的依据。但这种“反模式”会造成严重的隐式耦合。这也就意味着，错误值构造方不经意间的一次错误描述字符串的改动，都会造成错误处理方处理行为的变化，并且这种通过字符串比较的方式，对错误值进行检视的性能也很差。</p><p>Go 标准库采用了定义导出的（Exported）“哨兵”错误值的方式，来辅助错误处理方检视（inspect）错误值并做出错误处理分支的决策，比如下面的 bufio 包中定义的“哨兵错误”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/bufio/bufio.go</span><br><span class="hljs-keyword">var</span> (<br>    ErrInvalidUnreadByte = errors.New(<span class="hljs-string">&quot;bufio: invalid use of UnreadByte&quot;</span>)<br>    ErrInvalidUnreadRune = errors.New(<span class="hljs-string">&quot;bufio: invalid use of UnreadRune&quot;</span>)<br>    ErrBufferFull        = errors.New(<span class="hljs-string">&quot;bufio: buffer full&quot;</span>)<br>    ErrNegativeCount     = errors.New(<span class="hljs-string">&quot;bufio: negative count&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p>下面的代码片段利用了上面的哨兵错误，进行错误处理分支的决策：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := b.Peek(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">switch</span> err &#123;<br>    <span class="hljs-keyword">case</span> bufio.ErrNegativeCount:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> bufio.ErrBufferFull:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> bufio.ErrInvalidUnreadByte:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就像给反模式里的字符串加了个变量。<br>一般“哨兵”错误值变量以 ErrXXX 格式命名。和透明错误策略相比，“哨兵”策略让错误处理方在有检视错误值的需求时候，可以“有的放矢”。</p><p>不过，对于 API 的开发者而言，暴露“哨兵”错误值也意味着这些错误值和包的公共函数 &#x2F; 方法一起成为了 API 的一部分。一旦发布出去，开发者就要对它进行很好的维护。而“哨兵”错误值也让使用这些值的错误处理方对它产生了依赖。</p><p>从 Go 1.13 版本开始，标准库 errors 包提供了 Is 函数用于错误处理方对错误值的检视。Is 函数类似于把一个 error 类型变量与“哨兵”错误值进行比较，比如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 类似 if err == ErrOutOfBounds&#123; … &#125;</span><br><span class="hljs-keyword">if</span> errors.Is(err, ErrOutOfBounds) &#123;<br>    <span class="hljs-comment">// 越界的错误处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>=&#x3D;与 errors. Is 不同的是，如果 error 类型变量的底层错误值是一个包装错误（Wrapped Error），errors. Is 方法会沿着该包装错误所在错误链（Error Chain)，与链上所有被包装的错误（Wrapped Error）进行比较，直至找到一个匹配的错误为止。下面是 Is 函数应用的一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ErrSentinel = errors.New(<span class="hljs-string">&quot;the underlying sentinel error&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  err1 := fmt.Errorf(<span class="hljs-string">&quot;wrap sentinel: %w&quot;</span>, ErrSentinel)<br>  err2 := fmt.Errorf(<span class="hljs-string">&quot;wrap err1: %w&quot;</span>, err1)<br>    <span class="hljs-built_in">println</span>(err2 == ErrSentinel) <span class="hljs-comment">//false</span><br>  <span class="hljs-keyword">if</span> errors. Is (err2, ErrSentinel) &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;err2 is ErrSentinel&quot;</span>) <span class="hljs-comment">//err2 is ErrSentinel</span><br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;err2 is not ErrSentinel&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过比较操作符对 err2 与 ErrSentinel 进行比较后，我们发现这二者并不相同。而 errors. Is 函数则会沿着 err2 所在错误链，向下找到被包装到最底层的“哨兵”错误值 ErrSentinel。</p><p>所以，如果你使用的是 Go 1.13 及后续版本，我建议你尽量使用 errors. Is 方法去检视某个错误值是否就是某个预期错误值，或者包装了某个特定的“哨兵”错误值。</p><h4 id="策略三：错误值类型检视策略"><a href="#策略三：错误值类型检视策略" class="headerlink" title="策略三：错误值类型检视策略"></a>策略三：错误值类型检视策略</h4><p>如果遇到错误处理方需要错误值提供更多的“错误上下文”的情况，上面这些错误处理策略和错误值构造方式都无法满足。</p><p>这种情况下，我们需要通过自定义错误类型的构造错误值的方式，来提供更多的“错误上下文”信息。并且，由于错误值都通过 error 接口变量统一呈现，要得到底层错误类型携带的错误上下文信息，错误处理方需要使用 Go 提供的<strong>类型断言机制（Type Assertion）</strong> 或<strong>类型选择机制（Type Switch)</strong>，这种错误处理方式，我称之为<strong>错误值类型检视策略</strong>。<br>我们来看一个标准库中的例子加深下理解，这个 json 包中自定义了一个 UnmarshalTypeError 的错误类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/encoding/json/decode.go</span><br><span class="hljs-keyword">type</span> UnmarshalTypeError <span class="hljs-keyword">struct</span> &#123;<br>    Value  <span class="hljs-type">string</span>       <br>    Type   reflect.Type <br>    Offset <span class="hljs-type">int64</span>        <br>    Struct <span class="hljs-type">string</span>       <br>    Field  <span class="hljs-type">string</span>      <br>&#125;<br></code></pre></td></tr></table></figure><p>错误处理方可以通过错误类型检视策略，获得更多错误值的错误上下文信息，下面就是利用这一策略的 json 包的一个方法的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/encoding/json/decode.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *decodeState)</span></span> addErrorContext(err <span class="hljs-type">error</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> d.errorContext.Struct != <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(d.errorContext.FieldStack) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">switch</span> err := err.(<span class="hljs-keyword">type</span>) &#123;<br>        <span class="hljs-keyword">case</span> *UnmarshalTypeError:<br>            err.Struct = d.errorContext.Struct.Name()<br>            err.Field = strings.Join(d.errorContext.FieldStack, <span class="hljs-string">&quot;.&quot;</span>)<br>            <span class="hljs-keyword">return</span> err<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码通过类型 switch 语句得到了 err 变量代表的动态类型和值，然后在匹配的 case 分支中利用错误上下文信息进行处理。<br>一般自定义导出的错误类型以 XXXError 的形式命名。和“哨兵”错误处理策略一样，错误值类型检视策略，由于暴露了自定义的错误类型给错误处理方，因此这些错误类型也和包的公共函数 &#x2F; 方法一起，成为了 API 的一部分。一旦发布出去，开发者就要对它们进行很好的维护。而它们也让使用这些类型进行检视的错误处理方对其产生了依赖。<br>从 Go 1.13 版本开始，标准库 errors 包提供了 As 函数给错误处理方检视错误值。As 函数类似于通过类型断言判断一个 error 类型变量是否为特定的自定义错误类型，如下面代码所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 类似 if e, ok := err.(*MyError); ok &#123; … &#125;</span><br><span class="hljs-keyword">var</span> e *MyError<br><span class="hljs-keyword">if</span> errors.As(err, &amp;e) &#123;<br>    <span class="hljs-comment">// 如果err类型为*MyError，变量e将被设置为对应的错误值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就像 errors. Is 函数那样, 和常规语句不同的是，如果 error 类型变量的动态错误值是一个包装错误，errors. As 函数会沿着该包装错误所在错误链，与链上所有被包装的错误的类型进行比较，直至找到一个匹配的错误类型。下面是 As 函数应用的一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>    e <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.e<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> err = &amp;MyError&#123;<span class="hljs-string">&quot;MyError error demo&quot;</span>&#125;<br>    err1 := fmt.Errorf(<span class="hljs-string">&quot;wrap err: %w&quot;</span>, err)<br>    err2 := fmt.Errorf(<span class="hljs-string">&quot;wrap err1: %w&quot;</span>, err1)<br>    <span class="hljs-keyword">var</span> e *MyError<br>    <span class="hljs-keyword">if</span> errors.As(err2, &amp;e) &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;MyError is on the chain of err2&quot;</span>)<span class="hljs-comment">//MyError is on the chain of err2</span><br>        <span class="hljs-built_in">println</span>(e == err)<span class="hljs-comment">//true                  </span><br>        <span class="hljs-keyword">return</span>                             <br>    &#125;                                      <br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;MyError is not on the chain of err2&quot;</span>)<br>&#125; <br></code></pre></td></tr></table></figure><p>errors. As 函数沿着 err2 所在错误链向下找到了被包装到最深处的错误值，并将 err2 与其类型 * MyError 成功匹配。<br>匹配成功后，errors. As 会将匹配到的错误值存储到 As 函数的第二个参数中，这也是为什么 println (e &#x3D;&#x3D; err) 输出 true 的原因。(?) 这段话不是很理解</p><p>errors. As ()：检视类型； errors. Is ()：检视错误。</p><h4 id="策略四：错误行为特征检视策略"><a href="#策略四：错误行为特征检视策略" class="headerlink" title="策略四：错误行为特征检视策略"></a>策略四：错误行为特征检视策略</h4><p>在前面的三种策略中，其实只有第一种策略，也就是“透明错误处理策略”，有效降低了错误的构造方与错误处理方两者之间的耦合。虽然前面的策略二和策略三，都是我们实际编码中有效的错误处理策略，但其实使用这两种策略的代码，依然在错误的构造方与错误处理方两者之间建立了耦合。<br>在 Go 标准库中，我们发现了这样一种错误处理方式：<strong>将某个包中的错误类型归类，统一提取出一些公共的错误行为特征，并将这些错误行为特征放入一个公开的接口类型中。</strong> 这种方式也被叫做错误行为特征检视策略。</p><p>以标准库中的 net 包为例，它将包内的所有错误类型的公共行为特征抽象并放入 net. Error 这个接口中，如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> Error <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">error</span><br>    Timeout() <span class="hljs-type">bool</span>  <br>    Temporary() <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>net. Error 接口包含两个用于判断错误行为特征的方法：Timeout 用来判断是否是超时（Timeout）错误，Temporary 用于判断是否是临时（Temporary）错误。<br>而错误处理方只需要依赖这个公共接口，就可以检视具体错误值的错误行为特征信息，并根据这些信息做出后续错误处理分支选择的决策。<br>我们再看一个 http 包使用错误行为特征检视策略进行错误处理的例子，加深下理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">for</span> &#123;<br>        rw, e := l.Accept()<br>        <span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-srv.getDoneChan():<br>                <span class="hljs-keyword">return</span> ErrServerClosed<br>            <span class="hljs-keyword">default</span>:<br>            &#125;<br>            <span class="hljs-keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;<br>                <span class="hljs-comment">// 注：这里对临时性(temporary)错误进行处理</span><br>                ... ...<br>                time.Sleep(tempDelay)<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> e<br>        &#125;<br>        ...<br>    &#125;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面代码中，Accept 方法实际上返回的错误类型为*OpError，它是 net 包中的一个自定义错误类型，它实现了错误公共特征接口 net. Error，如下代码所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> OpError <span class="hljs-keyword">struct</span> &#123;<br>    ... ...<br>    <span class="hljs-comment">// Err is the error that occurred during the operation.</span><br>    Err <span class="hljs-type">error</span><br>&#125;<br><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> &#123;<br>    Temporary() <span class="hljs-type">bool</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *OpError)</span></span> Temporary() <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">if</span> ne, ok := e.Err.(*os.SyscallError); ok &#123;<br>      t, ok := ne.Err.(temporary)<br>      <span class="hljs-keyword">return</span> ok &amp;&amp; t.Temporary()<br>  &#125;<br>  t, ok := e.Err.(temporary)<br>  <span class="hljs-keyword">return</span> ok &amp;&amp; t.Temporary()<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，OpError 实例可以被错误处理方通过 net. Error 接口的方法，判断它的行为是否满足 Temporary 或 Timeout 特征。</p><p>在错误处理策略选择上的建议：</p><ul><li>请尽量使用“透明错误”处理策略，降低错误处理方与错误值构造方之间的耦合；</li><li>如果可以从众多错误类型中提取公共的错误行为特征，那么请尽量使用“错误行为特征检视策略”;</li><li>在上述两种策略无法实施的情况下，再使用“哨兵”策略和“错误值类型检视”策略；</li><li>Go 1.13 及后续版本中，尽量用 errors. Is 和 errors. As 函数替换原先的错误检视比较语句。</li></ul><h2 id="如何让函数更健壮？"><a href="#如何让函数更健壮？" class="headerlink" title="如何让函数更健壮？"></a>如何让函数更健壮？</h2><p><strong>健壮性的“三不要”原则</strong></p><h5 id="原则一：不要相信任何外部输入的参数。"><a href="#原则一：不要相信任何外部输入的参数。" class="headerlink" title="原则一：不要相信任何外部输入的参数。"></a>原则一：不要相信任何外部输入的参数。</h5><p>函数的使用者可能是任何人，这些人在使用函数之前可能都没有阅读过任何手册或文档，他们会向函数传入你意想不到的参数。因此，为了保证函数的健壮性，函数需要对所有输入的参数进行合法性的检查。一旦发现问题，立即终止函数的执行，返回预设的错误值。</p><h5 id="原则二：不要忽略任何一个错误。"><a href="#原则二：不要忽略任何一个错误。" class="headerlink" title="原则二：不要忽略任何一个错误。"></a>原则二：不要忽略任何一个错误。</h5><p>在我们的函数实现中，也会调用标准库或第三方包提供的函数或方法。对于这些调用，我们不能假定它一定会成功，我们一定要显式地检查这些调用返回的错误值。一旦发现错误，要及时终止函数执行，防止错误继续传播。</p><h5 id="原则三：不要假定异常不会发生。"><a href="#原则三：不要假定异常不会发生。" class="headerlink" title="原则三：不要假定异常不会发生。"></a>原则三：不要假定异常不会发生。</h5><p>这里，我们先要确定一个认知：异常不是错误。错误是可预期的，也是经常会发生的，我们有对应的公开错误码和错误处理预案，但异常却是少见的、意料之外的。通常意义上的异常，指的是硬件异常、操作系统异常、语言运行时异常，还有更大可能是代码中潜在 bug 导致的异常，比如代码中出现了以 0 作为分母，或者是数组越界访问等情况。<br>虽然异常发生是“小众事件”，但是我们不能假定异常不会发生。所以，函数设计时，我们就需要根据函数的角色和使用场景，考虑是否要在函数内设置异常捕捉和恢复的环节。</p><h3 id="Panic-Go-函数的异常处理设计"><a href="#Panic-Go-函数的异常处理设计" class="headerlink" title="Panic     Go 函数的异常处理设计"></a>Panic Go 函数的异常处理设计</h3><p>不同编程语言表示异常（Exception）这个概念的语法都不相同。在 Go 语言中，异常这个概念由 panic 表示。一些教程或文章会把它译为恐慌，我这里依旧选择不译，保留 panic 的原汁原味。<br>panic 指的是 Go 程序在运行时出现的一个异常情况。如果异常出现了，但没有被捕获并恢复，Go 程序的执行就会被终止，即便出现异常的位置不在主 Goroutine 中也会这样。<br>在 Go 中，panic 主要有两类来源，一类是来自 Go 运行时，另一类则是 Go 开发人员通过 panic 函数主动触发的。无论是哪种，一旦 panic 被触发，后续 Go 程序的执行过程都是一样的 (go 的异常终止的逻辑中，程序 down 掉)，这个过程被 Go 语言称为 panicking。</p><p>Go 官方文档以手工调用 panic 函数触发 panic 为例，对 panicking 这个过程进行了诠释：当函数 F 调用 panic 函数时，函数 F 的执行将停止。不过，函数 F 中已进行求值的 deferred 函数都会得到正常执行，执行完这些 deferred 函数后，函数 F 才会把控制权返还给其调用者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call foo&quot;</span>)<br>    bar()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit foo&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call bar&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic occurs in bar&quot;</span>)<br>    zoo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit bar&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zoo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call zoo&quot;</span>)<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit zoo&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call main&quot;</span>)<br>    foo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit main&quot;</span>)<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">//call main</span><br><span class="hljs-comment">//call foo</span><br><span class="hljs-comment">//call bar</span><br><span class="hljs-comment">//panic: panic occurs in bar</span><br></code></pre></td></tr></table></figure><p>程序从入口函数 main 开始依次调用了 foo、bar 函数，在 bar 函数中，代码在调用 zoo 函数之前调用了 panic 函数触发了异常。那示例的 panicking 过程就从这开始了。bar 函数调用 panic 函数之后，它自身的执行就此停止了，所以我们也没有看到代码继续进入 zoo 函数执行。并且，bar 函数没有捕捉这个 panic，这样这个 panic 就会沿着函数调用栈向上走，来到了 bar 函数的调用者 foo 函数中。<br>从 foo 函数的视角来看，这就好比将它对 bar 函数的调用，换成了对 panic 函数的调用一样。这样一来，foo 函数的执行也被停止了。由于 foo 函数也没有捕捉 panic，于是 panic 继续沿着函数调用栈向上走，来到了 foo 函数的调用者 main 函数中。<br>同理，从 main 函数的视角来看，这就好比将它对 foo 函数的调用，换成了对 panic 函数的调用一样。结果就是，main 函数的执行也被终止了，于是整个程序异常退出，日志”exit main”也没有得到输出的机会。<br>不过，Go 也提供了捕捉 panic 并恢复程序正常执行秩序的方法，我们可以通过 recover 函数来实现这一点。<br>将 bar 函数更新为下面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> e := <span class="hljs-built_in">recover</span>(); e != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;recover the panic:&quot;</span>, e)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call bar&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic occurs in bar&quot;</span>)<br>    zoo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit bar&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>recover 是 Go 内置的专门用于恢复 panic 的函数，它必须被放在一个 defer 函数中才能生效。如果 recover 捕捉到 panic，它就会返回以 panic 的具体内容为错误上下文信息的错误值。如果没有 panic 发生，那么 recover 将返回 nil。如果 panic 被 recover 捕捉到，panic 引发的 panicking 过程就会停止。<br>无论 bar 函数正常执行结束，还是因 panic 异常终止，在那之前设置成功的 defer 函数都会得到执行就可以了。<br>执行更新后的程序，得到如下结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">call main<br>call foo<br>call bar<br><span class="hljs-built_in">recover</span> the <span class="hljs-built_in">panic</span>: <span class="hljs-built_in">panic</span> occurs in bar<br>exit foo<br>exit main<br></code></pre></td></tr></table></figure><p>在更新后的代码中，当 bar 函数调用 panic 函数触发异常后，bar 函数的执行就会被中断。但这一次，在代码执行流回到 bar 函数调用者之前，bar 函数中的、在 panic 之前就已经被设置成功的 derfer 函数就会被执行。<br>这个匿名函数会调用 recover 把刚刚触发的 panic 恢复，这样，panic 还没等沿着函数栈向上走，就被消除了。所以，这个时候，从 foo 函数的视角来看，bar 函数与正常返回没有什么差别。<br>foo 函数依旧继续向下执行，直至 main 函数成功返回。这样，这个程序的 panic“危机”就解除了。<br>感觉 recover 就是使得在这之前的函数都能执行完成，而不是直接退出。</p><h2 id="如何应对-panic？"><a href="#如何应对-panic？" class="headerlink" title="如何应对 panic？"></a>如何应对 panic？</h2><h5 id="第一点：评估程序对-panic-的忍受度"><a href="#第一点：评估程序对-panic-的忍受度" class="headerlink" title="第一点：评估程序对 panic 的忍受度"></a>第一点：评估程序对 panic 的忍受度</h5><p><strong>不同应用对异常引起的程序崩溃退出的忍受度是不一样的</strong><br>比如，一个单次运行于控制台窗口中的命令行交互类程序（CLI），和一个常驻内存的后端 HTTP 服务器程序，对异常崩溃的忍受度就是不同的。前者即便因异常崩溃，对用户来说也仅仅是再重新运行一次而已。但后者一旦崩溃，就很可能导致整个网站停止服务。<br><strong>针对各种应用对 panic 忍受度的差异，我们采取的应对 panic 的策略也应该有不同</strong></p><p>就比如 Go 标准库提供的 http server。一般来讲，无论在哪个 Goroutine 中发生未被恢复的 panic，整个程序都将崩溃退出。所以，为了保证处理某一个客户端连接的 Goroutine 出现 panic 时，不影响到 http server 主 Goroutine 的运行，Go 标准库在 serve 方法中加入了对 panic 的捕捉与恢复，下面是 serve 方法的部分代码片段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server. go</span><br><span class="hljs-comment">// Serve a new connection.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span></span> serve (ctx context. Context) &#123;<br>    c.remoteAddr = c.rwc.RemoteAddr().String()<br>    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;<br>            <span class="hljs-keyword">const</span> size = <span class="hljs-number">64</span> &lt;&lt; <span class="hljs-number">10</span><br>            buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size)<br>            buf = buf[:runtime.Stack(buf, <span class="hljs-literal">false</span>)]<br>            c.server.logf(<span class="hljs-string">&quot;http: panic serving %v: %v\n%s&quot;</span>, c.remoteAddr, err, buf)<br>        &#125;<br>        <span class="hljs-keyword">if</span> !c.hijacked() &#123;<br>            c.<span class="hljs-built_in">close</span>()<br>            c.setState(c.rwc, StateClosed, runHooks)<br>        &#125;<br>    &#125;()<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>serve 方法在一开始处就设置了 defer 函数，并在该函数中捕捉并恢复了可能出现的 panic。这样，即便处理某个客户端连接的 Goroutine 出现 panic，处理其他连接 Goroutine 以及 http server 自身都不会受到影响。</p><p>这种<strong>局部不要影响整体的异常处理策略</strong>，在很多并发程序中都有应用。并且，捕捉和恢复 panic 的位置通常都在子 Goroutine 的起始处，这样设置可以捕捉到后面代码中可能出现的所有 panic，就像 serve 方法中那样。</p><h5 id="第二点：提示潜在-bug"><a href="#第二点：提示潜在-bug" class="headerlink" title="第二点：提示潜在 bug"></a>第二点：提示潜在 bug</h5><p>在 Go 标准库中，<strong>大多数 panic 的使用都是充当类似 C 语言中断言的作用的。</strong><br>例如在 json 包的 encode. go 中也有使用 panic 做潜在 bug 提示的例子：：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/encoding/json/encode.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *reflectWithString)</span></span> resolve() <span class="hljs-type">error</span> &#123;<br>    ... ...<br>	<span class="hljs-keyword">switch</span> w.k.Kind() &#123;<br>	<span class="hljs-keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<br>		w.ks = strconv.FormatInt(w.k.Int(), <span class="hljs-number">10</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	<span class="hljs-keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<br>		w.ks = strconv.FormatUint(w.k.Uint(), <span class="hljs-number">10</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unexpected map key type&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码中，resolve 方法的最后一行代码就相当于一个“代码逻辑不会走到这里”的断言。一旦触发“断言”，这很可能就是一个潜在 bug。我们也看到，去掉这行代码并不会对 resolve 方法的逻辑造成任何影响，但真正出现问题时，开发人员就缺少了“断言”潜在 bug 提醒的辅助支持了。</p><h5 id="第三点：不要混淆异常与错误"><a href="#第三点：不要混淆异常与错误" class="headerlink" title="第三点：不要混淆异常与错误"></a>第三点：不要混淆异常与错误</h5><p>不能将 Go panic 当成 Java 的“checked exception”去用<br>查看 Java 标准类库，我们可以看到一些 Java 已预定义好的 checked exception 类，比较常见的有 IOException、TimeoutException、EOFException、FileNotFoundException，等等。看到这里，你是不是觉得这些 checked exception 和我们上一节讲的“哨兵错误值”十分相似？。它们都是预定义好的、代表特定场景下的错误状态。<br><strong>Java 的 checked exception 和 Go 中的 panic 有啥差别呢？</strong><br>Java 的 checked exception 用于一些可预见的、常会发生的错误场景，比如，针对 checked exception 的所谓“异常处理”，就是针对这些场景的“错误处理预案”。也可以说对 checked exception 的使用、捕获、自定义等行为都是“<strong>有意而为之</strong>”的。<br>如果它非要和 Go 中的某种语法对应来看，它对应的也是 Go 的错误处理，也就是基于 error 值比较模型的错误处理。所以，Java 中对 checked exception 处理的本质是错误处理，虽然它的名字用了带有“异常”的字样。<br>而 Go 中的 panic 呢，更接近于 Java 的 RuntimeException+Error，而不是 checked exception。<br>我们前面提到过 Java 的 checked exception 是必须要被上层代码处理的，也就是要么捕获处理，要么重新抛给更上层。但是在 Go 中，我们通常会导入大量第三方包，而对于这些第三方包 API 中是否会引发 panic，我们是不知道的。因此上层代码，也就是 API 调用者根本不会去逐一了解 API 是否会引发 panic，也没有义务去处理引发的 panic。<br>一旦你在编写的 API 中，像 checked exception 那样使用 panic 作为正常错误处理的手段，把引发的 panic 当作错误，那么你就会给你的 API 使用者带去大麻烦！因此，在 <strong>Go 中，作为 API 函数的作者，你一定不要将 panic 当作错误返回给 API 调用者。</strong></p><h2 id="defer-用于使得函数简洁"><a href="#defer-用于使得函数简洁" class="headerlink" title="defer      用于使得函数简洁"></a>defer 用于使得函数简洁</h2><p>defer 是 Go 语言提供的一种延迟调用机制，defer 的运作离不开函数。</p><ul><li>在 Go 中，只有在函数（和方法）内部才能使用 defer；</li><li>defer 关键字后面只能接函数（或方法），这些函数被称为 deferred 函数。defer 将它们注册到其所在 Goroutine 中，用于存放 deferred 函数的栈数据结构中，这些 deferred 函数将在执行 defer 的函数退出前，按后进先出（LIFO）的顺序被程序调度执行（如下图所示）。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230221153813.png]]<br>无论是执行到函数体尾部返回，还是在某个错误处理分支显式 return，又或是出现 panic，已经存储到 deferred 函数栈中的函数，都会被调度执行。所以说，deferred 函数是一个可以在任何情况下为函数进行收尾工作的好“伙伴”。</li></ul><p>使用案例如下<br>未使用 defer 之前：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> mu sync.Mutex<br>    mu.Lock()<br>    r1, err := OpenResource1()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    r2, err := OpenResource2()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    r3, err := OpenResource3()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r2.Close()<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-comment">// 使用r1，r2, r3</span><br>    err = doWithResources() <br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r3.Close()<br>        r2.Close()<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    r3.Close()<br>    r2.Close()<br>    r1.Close()<br>    mu.Unlock()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用 defer 之后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> mu sync.Mutex<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br><br>    r1, err := OpenResource1()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r1.Close()<br><br>    r2, err := OpenResource2()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r2.Close()<br><br>    r3, err := OpenResource3()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r3.Close()<br><br>    <span class="hljs-comment">// 使用r1，r2, r3</span><br>    <span class="hljs-keyword">return</span> doWithResources() <br>&#125;<br></code></pre></td></tr></table></figure><p>使用 defer 后对函数实现逻辑的简化是显而易见的。而且，这里资源释放函数的 defer 注册动作，紧邻着资源申请成功的动作，这样成对出现的惯例就极大降低了遗漏资源释放的可能性，我们开发人员也不用再小心翼翼地在每个错误处理分支中检查是否遗漏了某个资源的释放动作。同时，代码的简化也意味代码可读性的提高，以及代码健壮度的增强。</p><h3 id="defer-使用的几个注意事项"><a href="#defer-使用的几个注意事项" class="headerlink" title="defer 使用的几个注意事项"></a>defer 使用的几个注意事项</h3><h4 id="第一点：明确哪些函数可以作为-deferred-函数"><a href="#第一点：明确哪些函数可以作为-deferred-函数" class="headerlink" title="第一点：明确哪些函数可以作为 deferred 函数"></a>第一点：明确哪些函数可以作为 deferred 函数</h4><p>对于自定义的函数或方法，defer 可以给与无条件的支持，但是对于有返回值的自定义函数或方法，返回值会在 deferred 函数被调度执行的时候被自动丢弃（被 defer 关键字标记的函数的返回值会被舍弃）。<br>不过部分 Go 中的内置函数不能作为 deferred 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go中所有内置函数列表：</span><br>Functions:<br>  <span class="hljs-built_in">append</span> <span class="hljs-built_in">cap</span> <span class="hljs-built_in">close</span> <span class="hljs-built_in">complex</span> <span class="hljs-built_in">copy</span> <span class="hljs-built_in">delete</span> <span class="hljs-built_in">imag</span> <span class="hljs-built_in">len</span><br>  <span class="hljs-built_in">make</span> <span class="hljs-built_in">new</span> <span class="hljs-built_in">panic</span> <span class="hljs-built_in">print</span> <span class="hljs-built_in">println</span> <span class="hljs-built_in">real</span> <span class="hljs-built_in">recover</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// defer1.go</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>     <span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br>     <span class="hljs-keyword">var</span> sl []<span class="hljs-type">int</span><br>     <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>     m[<span class="hljs-string">&quot;item1&quot;</span>] = <span class="hljs-number">1</span><br>     m[<span class="hljs-string">&quot;item2&quot;</span>] = <span class="hljs-number">2</span><br>     <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">-1.4</span>)<br> <br>     <span class="hljs-keyword">var</span> sl1 []<span class="hljs-type">int</span><br>     <span class="hljs-keyword">defer</span> bar()<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">append</span>(sl, <span class="hljs-number">11</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">cap</span>(sl)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(c)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">complex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">copy</span>(sl1, sl)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">delete</span> (m, <span class="hljs-string">&quot;item2&quot;</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">imag</span>(a)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">len</span>(sl)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">new</span>(*<span class="hljs-type">int</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">panic</span>(<span class="hljs-number">1</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello, defer\n&quot;</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello, defer&quot;</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">real</span>(a)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">recover</span>()<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>     foo()<br> &#125;<br><span class="hljs-comment">//输出</span><br>$<span class="hljs-keyword">go</span> run defer1.<span class="hljs-keyword">go</span><br># command-line-arguments<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">17</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">append</span>(sl, <span class="hljs-number">11</span>)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">cap</span>(sl)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">20</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">complex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">23</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">imag</span>(a)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">24</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">len</span>(sl)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">25</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">26</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">new</span>(*<span class="hljs-type">int</span>)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">30</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">real</span>(a)<br></code></pre></td></tr></table></figure><p>如上，可以看出 append、cap、len、make、new、imag 等内置函数都是不能直接作为 deferred 函数的，而 close、copy、delete、print、recover 等内置函数则可以直接被 defer 设置为 deferred 函数<br>不过，对于那些不能直接作为 deferred 函数的内置函数，我们可以使用一个包裹它的匿名函数来间接满足要求，以 append 为例是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  _ = <span class="hljs-built_in">append</span>(sl, <span class="hljs-number">11</span>)<br>&#125;()<br></code></pre></td></tr></table></figure><h3 id="第二点：注意-defer-关键字后面表达式的求值时机"><a href="#第二点：注意-defer-关键字后面表达式的求值时机" class="headerlink" title="第二点：注意 defer 关键字后面表达式的求值时机"></a>第二点：注意 defer 关键字后面表达式的求值时机</h3><p>牢记：<strong>defer 关键字后面的表达式，是在将 deferred 函数注册到 deferred 函数栈的时候进行求值的。</strong>(意思是，如果 defer 关键字后面有未知的变量或者表达式，那么在压栈前就会计算成已知的)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo1</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(i)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo2</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>            fmt.Println(n)<br>        &#125;(i)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo3</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Println(i)<br>        &#125;()<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;foo1 result:&quot;</span>)<br>    foo1()<br>    fmt.Println(<span class="hljs-string">&quot;\nfoo2 result:&quot;</span>)<br>    foo2()<br>    fmt.Println(<span class="hljs-string">&quot;\nfoo3 result:&quot;</span>)<br>    foo3()<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 foo1，defer 后面直接用的是 fmt. Println 函数，每当 defer 将 fmt. Println 注册到 deferred 函数栈的时候，都会对 Println 后面的参数进行求值。根据上述代码逻辑，依次压入 deferred 函数栈的函数是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-number">0</span>)<br>fmt.Println(<span class="hljs-number">1</span>)<br>fmt.Println(<span class="hljs-number">2</span>)<br>fmt.Println(<span class="hljs-number">3</span>)<br><span class="hljs-comment">//因此输出为：</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>对于 foo2，defer 后面接的是一个带有一个参数的匿名函数。每当 defer 将匿名函数注册到 deferred 函数栈的时候，都会对该匿名函数的参数进行求值。根据上述代码逻辑，依次压入 deferred 函数栈的函数是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(0)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(1)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(2)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(3)</span></span><br><span class="hljs-comment">//输出为：</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>对于 foo3，foo3 中 defer 后面接的是一个不带参数的匿名函数。根据上述代码逻辑，依次压入 deferred 函数栈的函数是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">//当 foo3 返回后，deferred 函数被调度执行时，上述压入栈的 deferred 函数将以 LIFO 次序出栈执行。匿名函数会以闭包的方式访问外围函数的变量 i，并通过 Println 输出 i 的值，此时 i 的值为 4输出为：</span><br><span class="hljs-number">4</span><br><span class="hljs-number">4</span><br><span class="hljs-number">4</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>无论以何种形式将函数注册到 defer 中，deferred 函数的参数值都是在注册的时候进行求值的。</p><h4 id="第三点：知晓-defer-带来的性能损耗"><a href="#第三点：知晓-defer-带来的性能损耗" class="headerlink" title="第三点：知晓 defer 带来的性能损耗"></a>第三点：知晓 defer 带来的性能损耗</h4><p>在 Go 1.13 前的版本中, <strong>使用 defer 的函数的执行时间是没有使用 defer 函数的 8 倍左右。</strong><br>但从 Go 1.13 版本开始，带有 defer 的函数执行开销，仅是不带有 defer 的函数的执行开销的 1.45 倍左右，已经达到了几乎可以忽略不计的程度，我们可以放心使用。</p><p><strong>defer 要注意的：</strong></p><ul><li>函数返回前，deferred 函数是按照后入先出（LIFO）的顺序执行的；</li><li>defer 关键字是在注册函数时对函数的参数进行求值的。</li></ul><p>defer 的使用技巧：<br>1）defer 要在 panic 之前，才能执行；<br>2）defer 内部的 recover 只能捕获当前协程的 Panic，不能跨协程执行；<br>3）recover 只能在 defer 中调用才能生效。<br>4）可以跟踪函数的执行过程</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 语言从设计伊始，就不支持经典的面向对象语法元素，比如类、对象、继承，等等，但 Go 语言仍保留了名为“方法（method）”的语法元素。但这并不是要支持面向对象编程范式。<br>下面就是 Go 方法的一般形式：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230221164230.png]]<br>可以看清方法和函数非常相似，就多了一个 2. receiver ，这个 receiver 参数是方法与类型之间的纽带，也是方法与函数的最大不同。<br><strong>Go 中的方法必须是归属于一个类型的</strong>，而 receiver 参数的类型就是这个方法归属的类型，或者说这个方法就是这个类型的一个方法。就像上图中一样，ListenAndServeTLS 是 *Server 类型的方法, 注意是*Server 的方法而不是 Server 类型的方法。<br>每个方法只能有一个 receiver 参数，Go 不支持在方法的 receiver 部分放置包含多个 receiver 参数的参数列表，或者变长 receiver 参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T或T)</span></span> MethodName(参数列表) (返回值列表) &#123;<br>    <span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>receiver 部分的参数名不能与方法参数列表中的形参名，以及具名返回值中的变量名存在冲突，必须在这个方法的作用域中具有唯一性。如果这个不唯一不存在，比如像下面例子中那样，Go 编译器就会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M (t <span class="hljs-type">string</span>) &#123; <br><span class="hljs-comment">// 编译器报错：duplicate argument t (重复声明参数t)</span><br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在方法体中，我们没有用到 receiver 参数，我们也可以省略 receiver 的参数名，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M(t <span class="hljs-type">string</span>) &#123; <br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>仅当方法体中的实现不需要 receiver 参数参与时，我们才会省略 receiver 参数名，不过这一情况<strong>很少使用</strong>，你了解一下就好了。</p><p><strong>以及 receiver 参数的基类型本身不能为指针类型或接口类型。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt *<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r MyInt)</span></span> String() <span class="hljs-type">string</span> &#123; <br><span class="hljs-comment">// r的基类型为MyInt，编译器报错：invalid receiver type MyInt (MyInt is a pointer type)</span><br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, *(*<span class="hljs-type">int</span>)(r))<br>&#125;<br><br><span class="hljs-keyword">type</span> MyReader io.Reader<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r MyReader)</span></span> Read(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123; <br><span class="hljs-comment">// r的基类型为MyReader，编译器报错：invalid receiver type MyReader (MyReader is an interface type)</span><br>    <span class="hljs-keyword">return</span> r.Read(p)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>而且方法声明要与 receiver 参数的基类型声明放在同一个包内。</strong> 基于这个约束，我们还可以得到两个推论。</p><ul><li>第一个推论：<strong>我们不能为原生类型（诸如 int、float64、map 等）添加方法。</strong><br>比如，下面的代码试图为 Go 原生类型 int 增加新方法 Foo，这样做，Go 编译器会报错：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> Foo() <span class="hljs-type">string</span> &#123; <br><span class="hljs-comment">// 编译器报错：cannot define new methods on non-local type int</span><br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, i) <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第二个推论：<strong>不能跨越 Go 包为其他包的类型声明新方法。</strong><br>比如，下面的代码试图跨越包边界，为 Go 标准库中的 http. Server 类型添加新方法 Foo，这样做，Go 编译器同样会报错：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s http.Server)</span></span> Foo() &#123; <br><span class="hljs-comment">// 编译器报错：cannot define new methods on non-local type http.Server</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何调用方法？</strong><br>如果 receiver 参数的基类型为 T，那么我们说 receiver 参数绑定在 T 上，我们可以通过 *T 或 T 的变量实例调用该方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M(n <span class="hljs-type">int</span>) &#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    t.M(<span class="hljs-number">1</span>) <span class="hljs-comment">// 通过类型T的变量实例调用方法M</span><br><br>    p := &amp;T&#123;&#125;<br>    p.M(<span class="hljs-number">2</span>) <span class="hljs-comment">// 通过类型*T的变量实例调用方法M</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法的本质是什么-？"><a href="#方法的本质是什么-？" class="headerlink" title="方法的本质是什么 ？"></a>方法的本质是什么 ？</h4><p>C++ 中的对象在调用方法时，编译器会自动传入指向对象自身的 this 指针作为方法的第一个参数。而 Go 方法中的原理也是相似的，只不过我们是<strong>将 receiver 参数以第一个参数的身份并入到方法的参数列表中。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123; <br>    a <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> Get() <span class="hljs-type">int</span> &#123;  <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> Set(a <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123; <br>    t.a = a <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br><br><span class="hljs-comment">// 类型T的方法Get的等价函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Get</span><span class="hljs-params">(t T)</span></span> <span class="hljs-type">int</span> &#123;  <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br><span class="hljs-comment">// 类型*T的方法Set的等价函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Set</span><span class="hljs-params">(t *T, a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <br>    t.a = a <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br></code></pre></td></tr></table></figure><p>这种等价转换后的函数的类型就是方法的类型。只不过在 Go 语言中，这种等价转换是由 Go 编译器在编译和生成代码时自动完成的。Go 语言规范中还提供了<strong>方法表达式（Method Expression）</strong> 的概念，可以让我们更充分地理解上面的等价转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t T<br>t.Get()<br>(&amp;t).Set(<span class="hljs-number">1</span>)<br><span class="hljs-comment">//上面可以等价替换为：</span><br><span class="hljs-keyword">var</span> t T<br>T.Get(t)<br>(*T).Set(&amp;t, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><strong>直接以类型名 T 调用方法的表达方式，被称为 Method Expression。</strong><br>通过 Method Expression 这种形式，类型 T 只能调用 T 的方法集合（Method Set）中的方法，同理类型 *T 也只能调用 *T 的方法集合中的方法。</p><p><strong>Go 语言中的方法的本质就是，一个以方法的 receiver 参数作为第一个参数的普通函数。</strong><br>Method Expression 就是 Go 方法本质的最好体现，因为方法自身的类型就是一个普通函数的类型，我们甚至可以将它作为右值，赋值给一个函数类型的变量，比如下面示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    f1 := (*T).Set <br>    <span class="hljs-comment">// f1的类型，也是*T类型Set方法的类型：func (t *T, int)int</span><br>    f2 := T.Get    <br>    <span class="hljs-comment">// f2的类型，也是T类型Get方法的类型：func(t T)int</span><br>    fmt.Printf(<span class="hljs-string">&quot;the type of f1 is %T\n&quot;</span>, f1) <br>    <span class="hljs-comment">// the type of f1 is func(*main.T, int) int</span><br>    fmt.Printf(<span class="hljs-string">&quot;the type of f2 is %T\n&quot;</span>, f2) <br>    <span class="hljs-comment">// the type of f2 is func(main.T) int</span><br>    f1 (&amp;t, <span class="hljs-number">3</span>)<br>    fmt.Println(f2(t)) <span class="hljs-comment">// 3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(有部分案例，暂时跳过，感觉不是太看得懂…)</p><h4 id="如何选择-receiver-类型？"><a href="#如何选择-receiver-类型？" class="headerlink" title="如何选择 receiver 类型？"></a>如何选择 receiver 类型？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M1 () &lt;=&gt; F1 (t T)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M2() &lt;=&gt; F2(t *T)<br></code></pre></td></tr></table></figure><p>这个例子中有方法 M1 和 M2。M1 方法是 receiver 参数类型为 T 的一类方法的代表，而 M2 方法则代表了 receiver 参数类型为 *T 的另一类。下面我们分别来看看不同的 receiver 参数类型对 M1 和 M2 的影响。****</p><ul><li>首先，当 receiver 参数的类型为 T 时：当我们选择以 T 作为 receiver 参数类型时，M1 方法等价转换为 F1 (t T)。我们知道，Go 函数的参数采用的是<strong>值拷贝传递</strong>，也就是说，F1 函数体中的 t 是 T 类型实例的一个副本。这样，我们在 F1 函数的实现中对参数 t 做任何修改，都只会影响副本，而不会影响到原 T 类型实例。</li><li>第二，当 receiver 参数的类型为 *T 时：当我们选择以 *T 作为 receiver 参数类型时，M2 方法等价转换为 F2 (t *T)。同上面分析，我们传递给 F2 函数的 t 是 T 类型实例的地址，这样 F2 函数体中对参数 t 做的任何修改，都会反映到原 T 类型实例上。<br><strong>总结</strong>：当我们的方法 M1 采用类型为 T 的 receiver 参数时，代表 T 类型实例的 receiver 参数以值传递方式传递到 M1 方法体中的，实际上是 <strong>T 类型实例的副本，M1 方法体中对副本的任何修改操作，都不会影响到原 T 类型实例。</strong><br>当我们的方法 M2 采用类型为 *T 的 receiver 参数时，代表 *T 类型实例的 receiver 参数以值传递方式传递到 M2 方法体中的，实际上是 <strong>T 类型实例的地址，M2 方法体通过该地址可以对原 T 类型实例进行任何修改操作。</strong></li></ul><p><strong>无论是 T 类型实例，还是 *T 类型实例，都既可以调用 receiver 为 T 类型的方法，也可以调用 receiver 为 *T 类型的方法。</strong> 因为 Go 编译器在背后做了转换 (自动解引用或自动取地址)。也就是，Go 判断 t2 的类型为 *T，与方法 M1 的 receiver 参数类型 T 不一致，就会自动将 t2. M1 () 转换为 (*t2). M1 ()。</p><h5 id="第一个原则"><a href="#第一个原则" class="headerlink" title="第一个原则"></a>第一个原则</h5><p><strong>如果 Go 方法要把对 receiver 参数代表的类型实例的修改，反映到原类型实例上，那么我们应该选择 *T 作为 receiver 参数的类型。</strong><br><strong>如果 receiver 参数类型的 size 较大，以值拷贝形式传入就会导致较大的性能开销，这时我们选择 *T 作为 receiver 类型可能更好些。</strong></p><h5 id="第二个原则"><a href="#第二个原则" class="headerlink" title="第二个原则"></a>第二个原则</h5><p><strong>如果 Go 方法 不需要对 receiver 参数代表的类型实例的修改，并反映到原类型实例上，那么我们应该选择 \T 作为 receiver 参数的类型，因为这样可以缩窄外部修改类型实例内部状态的“接触面”，也就是尽量少暴露可以修改类型内部状态的方法。</strong></p><h5 id="第三个原则"><a href="#第三个原则" class="headerlink" title="第三个原则"></a>第三个原则</h5><p><strong>判断 T 类型是否需要实现某个接口</strong><br>如果 T 类型需要实现某个接口，那我们就要使用 T 作为 receiver 参数的类型，来满足接口类型方法集合中的所有方法。<br>如果 T 不需要实现某一接口，但 *T 需要实现该接口，那么根据方法集合概念，*T 的方法集合是包含 T 的方法集合的，这样我们在确定 Go 方法的 receiver 的类型时，参考原则一和原则二就可以了。</p><h4 id="方法集合"><a href="#方法集合" class="headerlink" title="方法集合"></a>方法集合</h4><p><strong>方法集合是用来判断一个类型是否实现了某接口类型的唯一手段</strong>，可以说，“<strong>方法集合决定了接口实现</strong>”<br><strong>什么是类型的方法集合?</strong><br>Go 中任何一个类型都有属于自己的方法集合，或者说方法集合是 Go 类型的一个“属性”。但不是所有类型都有自己的方法，比如 int 类型等。所以，对于没有定义方法的 Go 类型，我们称其拥有空方法集合。</p><h5 id="接口类型方法集合"><a href="#接口类型方法集合" class="headerlink" title="接口类型方法集合"></a>接口类型方法集合</h5><p>接口类型相对特殊，它只会列出代表接口的方法列表，不会具体定义某个方法，它的方法集合就是它的方法列表中的所有方法，我们可以一目了然地看到。</p><h5 id="非接口类型的方法集合"><a href="#非接口类型的方法集合" class="headerlink" title="非接口类型的方法集合"></a>非接口类型的方法集合</h5><p>下面这段代码可以用于输出一个非接口类型的方法集合：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dumpMethodSet</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    dynTyp := reflect.TypeOf(i)<br><br>    <span class="hljs-keyword">if</span> dynTyp == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;there is no dynamic type\n&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    n := dynTyp.NumMethod()<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%s&#x27;s method set is empty!\n&quot;</span>, dynTyp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;%s&#x27;s method set:\n&quot;</span>, dynTyp)<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        fmt.Println(<span class="hljs-string">&quot;-&quot;</span>, dynTyp.Method(j).Name)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M1() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M3() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M4() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br>    dumpMethodSet(n)<br>    dumpMethodSet(&amp;n)<br><br>    <span class="hljs-keyword">var</span> t T<br>    dumpMethodSet(t)<br>    dumpMethodSet(&amp;t)<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-type">int</span><span class="hljs-string">&#x27;s method set is empty!</span><br><span class="hljs-string">*int&#x27;</span>s method set is empty!<br>main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T&#x27;</span>s method set:<br>- M1<br>- M2<br>- M3<br>- M4<br></code></pre></td></tr></table></figure><p>其中，可以看到*T 把 T 这个类型下的所有方法 (T 和 *T) 都输出了。这是 Go 语言规定，<strong>*T 类型的方法集合包含所有以 *T 为 receiver 参数类型的方法，以及所有以 T 为 receiver 参数类型的方法。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>    M1 ()<br>    M2()<br>&#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-keyword">var</span> pt *T<br>    dumpMethodSet(t)<br>    dumpMethodSet(pt)<br>    i = pt <br>    i = t <br>    <span class="hljs-comment">// cannot use t (type T) as type Interface in assignment: T does not implement Interface (M2 method has pointer receiver)&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>T 类型的方法集合中只包含 M1，没有 Interface 类型方法集合中的 M2 方法，这就是 Go 编译器认为变量 t 不能赋值给 Interface 类型变量的原因。</p><p><strong>判断某个类型是否实现某接口的理论依据</strong><br>其中 T 类型的方法集合只包含 recevier 为 T 类型的方法，而*T 类型的方法集合包含 receiver 为 T 和*T、即类型下的所有方法。</p><p><strong>方法集合决定了接口实现</strong>的意思是：<br>如果某类型 T 的方法集合与某接口类型的方法集合相同，或者类型 T 的方法集合是接口类型 I 方法集合的超集，那么我们就说这个类型 T 实现了接口 I。或者说，方法集合这个概念在 Go 语言中的主要用途，就是用来判断某个类型是否实现了某个接口。</p><h3 id="类型嵌入"><a href="#类型嵌入" class="headerlink" title="类型嵌入"></a>类型嵌入</h3><p>类型嵌入指的就是在一个类型的定义中嵌入了其他类型。Go 语言支持两种类型嵌入，分别是<strong>接口类型的类型嵌入</strong>和<strong>结构体类型的类型嵌入</strong>。</p><h4 id="接口类型的类型嵌入"><a href="#接口类型的类型嵌入" class="headerlink" title="接口类型的类型嵌入"></a>接口类型的类型嵌入</h4><p><strong>接口类型声明了由一个方法集合代表的接口</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> E <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>    M3()<br>&#125;<span class="hljs-comment">//接口类型 I 方法集合中的 M1 和 M2，与接口类型 E 的方法集合中的方法完全相同。在这种情况下，我们可以用接口类型 E 替代上面接口类型 I 定义中 M1 和 M2</span><br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    E<br>    M3()<br>&#125;<span class="hljs-comment">//嵌入了接口类型 E</span><br></code></pre></td></tr></table></figure><p>像这种在一个接口类型（I）定义中，嵌入另外一个接口类型（E）的方式，接口类型的类型嵌入。<br>接口类型嵌入的语义就是<strong>新接口类型（如接口类型 I）将嵌入的接口类型（如接口类型 E）的方法集合，并入到自己的方法集合中。</strong><br>按 Go 语言惯例，Go 中的接口类型中只包含少量方法，并且常常只是一个方法。通过在接口类型中嵌入其他接口类型可以实现接口的组合，这也是 Go 语言中基于已有接口类型构建新接口类型的惯用法。</p><p>不过，这种通过嵌入其他接口类型来创建新接口类型的方式，在 Go 1.14 版本之前是有约束的：<strong>如果新接口类型嵌入了多个接口类型，这些嵌入的接口类型的方法集合不能有交集，同时嵌入的接口类型的方法集合中的方法名字，也不能与新接口中的其他方法同名。</strong> 比如我们用 Go 1.12.7 版本运行下面例子，Go 编译器就会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface1 <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>&#125;<br><span class="hljs-keyword">type</span> Interface2 <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br><span class="hljs-keyword">type</span> Interface3 <span class="hljs-keyword">interface</span> &#123;<br>    Interface1<br>    Interface2 <span class="hljs-comment">// Error: duplicate method M1 //1和2中M重复了</span><br>&#125;<br><span class="hljs-keyword">type</span> Interface4 <span class="hljs-keyword">interface</span> &#123;<br>    Interface2<br>    M2() <span class="hljs-comment">// Error: duplicate method M2 //也是重复了</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但自 Go 1.14 版本开始，Go 语言去除了这些约束，我们使用 Go 1.17 版本运行上面这个示例就不会得到编译错误了。</strong></p><h4 id="结构体类型的类型嵌入"><a href="#结构体类型的类型嵌入" class="headerlink" title="结构体类型的类型嵌入"></a>结构体类型的类型嵌入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//带有嵌入字段（Embedded Field）的结构体定义</span><br><span class="hljs-keyword">type</span> T1 <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> t2 <span class="hljs-keyword">struct</span>&#123;<br>    n <span class="hljs-type">int</span><br>    m <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>&#125;<br><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>    T1<br>    *t2<br>    I            <br>    a <span class="hljs-type">int</span><br>    b <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结构体 S1 定义中有三个“非常规形式”的标识符，分别是 T1、t2 和 I，它们<strong>既代表字段的名字，也代表字段的类型。</strong></p><ul><li>标识符 T1 表示字段名为 T1，它的类型为自定义类型 T1；</li><li>标识符 t2 表示字段名为 t2，它的类型为自定义结构体类型 t2 的指针类型；</li><li>标识符 I 表示字段名为 I，它的类型为接口类型 I。<br>这种以某个类型名、类型的指针类型名或接口类型名，直接作为结构体字段的方式就叫做<strong>结构体的类型嵌入</strong>，这些字段也被叫做<strong>嵌入字段（Embedded Field）</strong>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *MyInt)</span></span> Add(m <span class="hljs-type">int</span>) &#123;<br>    *n = *n + MyInt(m)<br>&#125;<br><br><span class="hljs-keyword">type</span> t <span class="hljs-keyword">struct</span> &#123;<br>    a <span class="hljs-type">int</span><br>    b <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>    *MyInt<br>    t<br>    io. Reader<br>    s <span class="hljs-type">string</span><br>    n <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := MyInt(<span class="hljs-number">17</span>)<br>    r := strings.NewReader(<span class="hljs-string">&quot;hello, go&quot;</span>)<br>    s := S&#123;<br>        MyInt: &amp;m,<br>        t: t&#123;<br>            a: <span class="hljs-number">1</span>,<br>            b: <span class="hljs-number">2</span>,<br>        &#125;,<br>        Reader: r, <span class="hljs-comment">//可以直接使用字段名来表示 </span><br>        s:      <span class="hljs-string">&quot;demo&quot;</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> sl = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello, go&quot;</span>))<br>    s.Reader.Read(sl)<br>    fmt.Println(<span class="hljs-type">string</span>(sl)) <span class="hljs-comment">// hello, go</span><br>    s.MyInt.Add(<span class="hljs-number">5</span>)<br>    fmt.Println(*(s.MyInt)) <span class="hljs-comment">// 22</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么第 29 行是 reader 而不是 io. Reader？<br>因为，Go 语言规定如果结构体使用从其他包导入的类型作为嵌入字段，比如 pkg. T，那么这个嵌入字段的字段名就是 T，代表的类型为 pkg. T。</p><p>Go 对嵌入字段有一些约束的。比如，和 Go 方法的 receiver 的基类型一样，嵌入字段类型的<strong>底层类型不能为指针类型</strong>。而且，嵌入字段的名字在结构体定义也必须是唯一的，这也意味这如果两个类型的名字相同，它们无法同时作为嵌入字段放到同一个结构体定义中。不过，这些约束你了解一下就可以了，一旦违反，Go 编译器会提示你的。</p><h3 id="Go-实现”继承”"><a href="#Go-实现”继承”" class="headerlink" title="Go 实现”继承”"></a>Go 实现”继承”</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//和上面的代码一起的</span><br><span class="hljs-keyword">var</span> sl = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello, go&quot;</span>))<br>s.Read(sl) <br>fmt.Println(<span class="hljs-type">string</span>(sl))<br>s.Add(<span class="hljs-number">5</span>) <br>fmt.Println(*(s.MyInt))<br></code></pre></td></tr></table></figure><p>可以看到 S 中并没有显式实现 read 和 add 方法，但是它却可以使用他们。<br>这两个方法其实是来自结构体类型 S 的两个嵌入字段 Reader 和 MyInt。结构体类型 S“继承”了 Reader 字段的方法 Read 的实现，也“继承”了 *MyInt 的 Add 方法的实现。<br>他们的工作机制是这样的，当我们通过结构体类型 S 的变量 s 调用 Read 方法时，Go 发现结构体类型 S 自身并没有定义 Read 方法，于是 Go 会查看 S 的嵌入字段对应的类型是否定义了 Read 方法。这个时候，Reader 字段就被找了出来，之后 s.Read 的调用就被转换为 <strong>s.Reader. Read</strong> 调用。这样一来，嵌入字段 Reader 的 Read 方法就被提升为 S 的方法，放入了类型 S 的方法集合。同理*MyInt 的 Add 方法也被提升为 S 的方法而放入 S 的方法集合。从外部来看，这种嵌入字段的方法的提升就给了我们一种结构体类型 S“<strong>继承</strong>”了 io. Reader 类型 Read 方法的实现，以及 *MyInt 类型 Add 方法的实现的错觉。<br>不过类型嵌入这种看似“继承”的机制实际上是一种组合的思想。</p><h4 id="类型嵌入与方法集合"><a href="#类型嵌入与方法集合" class="headerlink" title="类型嵌入与方法集合"></a>类型嵌入与方法集合</h4><p>接口类型的类型嵌入的本质，就是嵌入类型的方法集合并入到新接口类型的方法集合中。<br>接口类型只能嵌入接口类型。而结构体类型对嵌入类型的要求就比较宽泛了，可以是任意自定义类型或接口类型。</p><h5 id="结构体类型中嵌入接口类型"><a href="#结构体类型中嵌入接口类型" class="headerlink" title="结构体类型中嵌入接口类型"></a>结构体类型中嵌入接口类型</h5><p><strong>结构体类型的方法集合，包含嵌入的接口类型的方法集合。</strong><br>需要注意：当结构体嵌入的多个接口类型的方法集合存在交集时，编译器可能会出现的错误提示。<br>前面说的 Go 1.14 版本解决了嵌入接口类型的方法集合有交集的情况，但那仅限于接口类型中嵌入接口类型。如果是结构体类型中嵌入接口类型，并且方法集合存在交集，这个时候，Go 编译器就会因无法确定究竟使用哪个方法而报错。<br>有两个解决办法：</p><ol><li>在结构体中增加自身方法，因为嵌入了其他类型的结构体类型本身是一个代理，在调用其实例所代理的方法时，Go 会首先查看结构体自身是否实现了该方法。</li><li>消除方法集合存在交集的情况。</li></ol><p>总结：不同的嵌入字段之间，其方法交集时会报错。但一旦自身方法中有了，则优先用自身方法，不会报错。<br>.<br>结构体类型嵌入接口类型在日常编码中有一个妙用，就是可以<strong>简化单元测试的编写</strong>。<br>在编写单元测试时，可以通过内嵌接口类型的方式来假装实现了该接口。<br>（没有很懂）</p><h5 id="结构体类型中嵌入结构体类型"><a href="#结构体类型中嵌入结构体类型" class="headerlink" title="结构体类型中嵌入结构体类型"></a>结构体类型中嵌入结构体类型</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T1)</span></span> T1M1()   &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;T1&#x27;s M1&quot;</span>) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T1)</span></span> PT1M2() &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;PT1&#x27;s M2&quot;</span>) &#125;<br><br><span class="hljs-keyword">type</span> T2 <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T2)</span></span> T2M1()   &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;T2&#x27;s M1&quot;</span>) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T2)</span></span> PT2M2() &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;PT2&#x27;s M2&quot;</span>) &#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    T1<br>    *T2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    t := T&#123;<br>        T1: T1&#123;&#125;,<br>        T2: &amp;T2&#123;&#125;,<br>    &#125;<br>    dumpMethodSet(t)<br>    dumpMethodSet(&amp;t)<br>&#125;<br><span class="hljs-comment">//输出</span><br>main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- PT2M2</span><br><span class="hljs-string">- T1M1</span><br><span class="hljs-string">- T2M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main. T&#x27;</span>s method set:<br>- PT1M2<br>- PT2M2<br>- T1M1<br>- T2M1<br></code></pre></td></tr></table></figure><ul><li>类型 T 的方法集合 &#x3D; T1 的方法集合 +*T2 的方法集合类型</li><li>*T 的方法集合 &#x3D; *T1 的方法集合 + *T2 的方法集合</li></ul><p>注意 *T 类型的方法集合，它包含的可不是 T1 类型的方法集合，而是 *T1 类型的方法集合。</p><h4 id="defined-定义-类型与-alias-别名-类型的方法集合"><a href="#defined-定义-类型与-alias-别名-类型的方法集合" class="headerlink" title="defined (定义) 类型与 alias (别名) 类型的方法集合"></a>defined (定义) 类型与 alias (别名) 类型的方法集合</h4><p>defined (定义) 类型不会继承，新 defined 类型要想实现那些接口，仍然需要重新实现接口的所有方法。<br>无论原类型是接口类型还是非接口类型，类型别名都与原类型拥有完全相同的方法集合。</p><p>Define 的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-keyword">type</span> T1 T<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> t T<br>  <span class="hljs-keyword">var</span> pt *T<br>  <span class="hljs-keyword">var</span> t1 T1<br>  <span class="hljs-keyword">var</span> pt1 *T1<br><br>  dumpMethodSet(t)<br>  dumpMethodSet(t1)<br><br>  dumpMethodSet(pt)<br>  dumpMethodSet(pt1)<br>&#125;<br><span class="hljs-comment">//输出</span><br>main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">main.T1&#x27;</span>s method set is empty!<br><br>*main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T1&#x27;</span>s method set is empty!<br></code></pre></td></tr></table></figure><p>Alias 的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-keyword">type</span> T1 = T<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-keyword">var</span> pt *T<br>    <span class="hljs-keyword">var</span> t1 T1<br>    <span class="hljs-keyword">var</span> pt1 *T1<br><br>    dumpMethodSet(t)<br>    dumpMethodSet(t1)<br><br>    dumpMethodSet(pt)<br>    dumpMethodSet(pt1)<br>&#125;<br><span class="hljs-comment">//输出</span><br>main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">main.T&#x27;</span>s method set:<br>- M1<br><br>*main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T&#x27;</span>s method set:<br>- M1<br>- M2<br></code></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><a target="_blank" rel="noopener" href="https://learnku.com/articles/44099">Golang 学习——interface 接口学习（一） | Go 技术论坛</a><br>在 <strong>Golang</strong> 中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。它与 <code>OOP(面向对象编程)</code> 非常相似。接口指定了类型应该具有的方法，类型决定了如何实现这些方法。<br>接口类型是由 type 和 interface 关键字定义的一组方法集合。</p><h3 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1. 定义接口"></a>1. 定义接口</h3><p>使用关键字 <code>interface</code> 用来定义接口，语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> interface_name <span class="hljs-keyword">interface</span> &#123;<br>   method_name1([args ...arg_type]) [return_type]<br>   method_name2([args ...arg_type]) [return_type]<br>   method_name3 ([args ... arg_type]) [return_type]<br>   ...<br>   method_namen([args ...arg_type]) [return_type]<br>&#125;<br></code></pre></td></tr></table></figure><p>（跳过大部分）</p><h3 id="2-空接口"><a href="#2-空接口" class="headerlink" title="2. 空接口"></a>2. 空接口</h3><p><code>Golang</code> 很多库的源代码都会以空接口作为参数，表示接受任意类型的参数<br>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个空接口</span><br><span class="hljs-keyword">type</span> Empyt_interface <span class="hljs-keyword">interface</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 定义一个入参为任意类型的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getInfo</span><span class="hljs-params">(arg Empyt_interface)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;getInfo 函数.....&quot;</span>, arg)<br>&#125;<br><span class="hljs-comment">// 也可以写成如下形式，更推荐</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getInfo2</span><span class="hljs-params">(arg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;getInfo2 函数.....&quot;</span>, arg)<br>&#125;<br></code></pre></td></tr></table></figure><p>比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] <span class="hljs-keyword">interface</span>&#123;&#125;)<br>map1[<span class="hljs-string">&quot;数字&quot;</span>] = <span class="hljs-number">1</span><br>map1[<span class="hljs-string">&quot;字符串&quot;</span>] = <span class="hljs-string">&quot;字符串&quot;</span><br>map1[<span class="hljs-string">&quot;布尔&quot;</span>] = <span class="hljs-literal">false</span><br>fmt.Println(<span class="hljs-string">&quot;map1 ...........&quot;</span>, map1)<br><span class="hljs-comment">//输出</span><br>map1 ........... <span class="hljs-keyword">map</span>[字符串:字符串 布尔:<span class="hljs-literal">false</span> 数字:<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="Go-并发-goroutine"><a href="#Go-并发-goroutine" class="headerlink" title="Go 并发 goroutine"></a>Go 并发 goroutine</h2><h3 id="并发-1"><a href="#并发-1" class="headerlink" title="并发"></a>并发</h3><p><a target="_blank" rel="noopener" href="https://learnku.com/go/t/30845">[奔跑的 Go] 教程十五、深入学习 Go 语言的并发编程 | Go 优质外文翻译 | Go 技术论坛</a><br>并发（concurrency）与 并行（parallelism）<br><strong>并发不是并行，并发关乎结构，并行关乎执行。</strong><br><strong>并行（parallelism）</strong>，指的就是在同一时刻，有两个或两个以上的任务的代码在处理器上执行。<br><strong>并发 concurrency）</strong> 考虑的是如何将应用划分为多个互相配合的、可独立执行的模块的问题。采用并发设计的程序并不一定是并行执行的。<br><strong>并发是同时处理多个事物，并行是同时做多个事物</strong>。<br>将程序分成多个可独立执行的部分的结构化程序的设计方法，就是<strong>并发设计</strong>。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230223155040.png]]</p><p><strong>并发：</strong> 针对的是程序结构设计，将一个程序分成若干个模块，不同模块单独执行，由多个模块相互交替执行，实现程序的运行。<br><strong>并行：</strong> 针对的程序的执行，指的是同一时间点，有个多个任务在被多个或者多核的 CPU 下调度执行。</p><p>传统编程语言（如 C、C++ 等）中，基于多线程模型的应用设计就是一种典型的并发程序设计。<br>传统多线程是以操作系统线程做执行单元的。<br>传统多线程是以操作系统线程作为承载分解后的代码片段（模块）的执行单元，由操作系统执行调度。这种传统支持并发的方式有很多不足：</p><ul><li>复杂</li><li>难以规模化</li></ul><h3 id="Go-的并发"><a href="#Go-的并发" class="headerlink" title="Go 的并发"></a>Go 的并发</h3><p>Go 并没有使用操作系统线程作为承载分解后的代码片段（模块）的基本执行单元，而是实现了 goroutine 这一由 Go 运行时（runtime）负责调度的、轻量的用户级线程，为并发程序设计提供原生支持。<br>goroutine 的优势主要是：</p><ul><li>资源占用小，每个 goroutine 的初始<strong>栈</strong>大小仅为 2k；</li><li>由 Go 运行时而不是操作系统调度，goroutine 上下文切换在用户层完成，开销更小；</li><li>在语言层面而不是通过标准库提供。goroutine 由 go 关键字创建，一退出就会被回收或销毁，开发体验更佳；</li><li>语言内置 channel 作为 goroutine 间通信原语，为并发设计提供了强大支撑。<br>Go 语言是面向并发而生的，所以，在程序的结构设计阶段，Go 的惯例是优先考虑并发设计。</li></ul><h4 id="goroutine-的基本用法"><a href="#goroutine-的基本用法" class="headerlink" title="goroutine 的基本用法"></a>goroutine 的基本用法</h4><p><a target="_blank" rel="noopener" href="https://learnku.com/go/t/31082">[奔跑的 Go] 教程十六、深入学习 Go 并发编程之 goroutine | Go 优质外文翻译 | Go 技术论坛</a><br><strong>并发</strong>是一种能力，它让你的程序可以由若干个<strong>代码片段组合而成</strong>，并且每个片段都是独立运行的。goroutine 恰恰就是 Go 原生支持并发的一个具体实现。无论是 Go 自身运行时代码还是用户层 Go 代码，都无一例外地运行在 goroutine 中。</p><h4 id="创建和退出-goroutine"><a href="#创建和退出-goroutine" class="headerlink" title="创建和退出 goroutine"></a>创建和退出 goroutine</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建方式：go关键字+函数/方法</span><br><span class="hljs-keyword">go</span> fmt.Println(<span class="hljs-string">&quot;I am a goroutine&quot;</span>) <br><br><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>    c &lt;- a + b<br>&#125;(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br> <br><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br>c := srv.newConn(rw)<br><span class="hljs-keyword">go</span> c.serve(connCtx)<br></code></pre></td></tr></table></figure><p>通过 go 关键字，我们可以基于已有的具名函数 &#x2F; 方法创建 goroutine，也可以基于匿名函数 &#x2F; 闭包创建 goroutine。</p><p>多数情况下，我们不需要考虑对 goroutine 的退出进行控制：<strong>goroutine 的执行函数的返回，就意味着 goroutine 退出。</strong><br>如果 main goroutine 退出了，那么也意味着整个应用程序的退出。此外，你还要注意的是，<strong>goroutine 执行的函数或方法即便有返回值，Go 也会忽略这些返回值</strong>。<br>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   <span class="hljs-keyword">go</span> printHello()  <br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br><span class="hljs-comment">//输出</span><br>main() started<br>main() stopped<br></code></pre></td></tr></table></figure><p><strong>为什么我们看不到 printHello 函数的输出？</strong><br>这是因为，每个 go 应用程序都会创建一个 goroutine，main 函数在其中运行，称为 main goroutine。在上述情况下，main goroutine 生成另一个 goroutine 运行 printHello 函数，我们叫它 printHello goroutine。因此，当我们执行上述程序时，同时运行了两个 goroutine。<br>我们已经了解到，goroutine 是协同调度的。因此，在 main goroutine 执行完之前，printHello goroutine 不会执行。不幸的是，当 main goroutine 执行完毕后，程序会立即结束，调度器没有时间安排 printHello goroutine 执行。但是从之前的课程我们知道，我们可以通过阻塞当前 goroutine，通知调度器运行其他可用的 goroutine，即手动将控制权传递到其他 goroutine。我们可以使用 time. Sleep () 来实现这个目的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   <span class="hljs-keyword">go</span> printHello()  <br>   time.Sleep(<span class="hljs-number">10</span> * time.Millisecond)  <span class="hljs-comment">// 10ms 之后_</span><br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br><span class="hljs-comment">//输出</span><br>main() started<br>Hello World<br>main() stopped<br></code></pre></td></tr></table></figure><p>在 main goroutine 执行最后一行代码前，通过调用 time. Sleep (10 * time. Millisecond) ，把控制权传递给 printHello goroutine。在这种情况下，main goroutine 将休眠 10ms，在 10ms 内，调度器将不会再次执行它。一旦 printHello goroutine 执行，它向终端打印 「Hello World!」并终止，然后，main goroutine 继续被调度执行 堆栈指针指向的 最后一行代码（10ms 之后），因此 printHello 能够输出结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span></span> &#123;  <br>   time.Sleep(<span class="hljs-number">16</span> * time.Millisecond)  <span class="hljs-comment">// 16ms 之后 但是我测试15ms还是可以输出</span><br>   fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   <span class="hljs-keyword">go</span> printHello()  <br>   time.Sleep(<span class="hljs-number">10</span> * time.Millisecond)  <span class="hljs-comment">// 10ms 之后_</span><br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br><span class="hljs-comment">//输出</span><br>main() started<br>main() stopped<br></code></pre></td></tr></table></figure><p>现在我们已经明白了怎样去创建协程并使得它们协同工作。但是调度协程使用 time. Sleep 仅仅是一种 hack (折中) 手段。在生产环境中，我们不知道一个协程的运行时间，因此我们不能仅仅在主线程中去添加一个随机休眠时间。我们期望是让协程在执行结束后主动告诉我们。同样的，我们也不能从协程接收数据和发送数据。简单来说就是我们无法和协程进行数据交互操作。而 <strong>golang 的通道</strong>就是用来解决上述痛点的。</p><h5 id="匿名协程"><a href="#匿名协程" class="headerlink" title="匿名协程"></a>匿名协程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;  <br>      fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)  <br>   &#125;()  <span class="hljs-comment">//和上面的作用是差不多的。</span><br>   time.Sleep(<span class="hljs-number">10</span> * time.Millisecond)  <br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Goroutine-之间的通讯"><a href="#Goroutine-之间的通讯" class="headerlink" title="Goroutine 之间的通讯"></a>Goroutine 之间的通讯</h3><p>传统语言的并发模型是基于对内存的共享的。<br>Go 的并发模型这设计是借鉴的 <strong>CSP</strong>（Communicating Sequential Processes，通信顺序进程）并发模型。<br>（????）</p><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p><strong>通道</strong> 是用于协程间交流的通信载体。严格地来说，通道就是数据传输的管道，数据通过这根管道被 “传入” 或被 “读出”。 因此协程可以发送数据到通道中，而另一个协程可以从该通道中读取数据。</p><h5 id="声明一个通道"><a href="#声明一个通道" class="headerlink" title="声明一个通道"></a>声明一个通道</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">//声明了一个nil通道，但这是没有用的。</span><br>c:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-comment">//必须使用 make 函数器创建一个可以使用的通道。</span><br></code></pre></td></tr></table></figure><h5 id="通道的读写操作"><a href="#通道的读写操作" class="headerlink" title="通道的读写操作"></a>通道的读写操作</h5><p>Go 语言提供一个非常简洁的左箭头语法 <code>&lt;-</code> 去从通道读写数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c &lt;- data<br></code></pre></td></tr></table></figure><p>上面的代码意味着我们想要把 <code>data</code> 数据推入到通道 <code>c</code>. 注意看箭头的指向。它表明是从 <code>data</code> to 通道 <code>c</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;- c<br></code></pre></td></tr></table></figure><p>上面的代码表明我们想要从通道 c 读一些数据。注意看箭头的指向，它从通道 c 开始。这个语句不会把数据传输给任何变量，但是仍然是一个有效的语句。如果你希望有一个变量来接收通道 C 的数据，你可以使用下面的语句:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> data <span class="hljs-type">int</span><br>data = &lt;- c<br><span class="hljs-comment">//使用语法:= 重写</span><br>data := &lt;- c<span class="hljs-comment">//自动判断 data 变量的数据类型。</span><br></code></pre></td></tr></table></figure><p>现在来自 int 类型通道 c 的数据就可以被存储到 int 类型变量 data 中。</p><p>通道操作默认是阻塞的. 通道操作本质上是阻塞的。当一些数据被写入通道，对应的协程将阻塞直到有其他的协程可以从此通道接收数据。 同时正如我们之前看的文章 concurrency chapter, 通道操作会通知调度器去调度其他的协程，这就是为什么程序不会一直阻塞在一个协程。通道的这些特性在不同的协程沟通的时候非常有用，它避免了我们使用锁或者一些 hack 手段去达到阻塞协程的目的。(不是很懂)</p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p><strong>当通道读写数据时，所在协程会阻塞并且调度控制权会转移到其他未阻塞的协程。</strong></p><p>如果当前协程正在从一个没有任何值的通道中读取数据，那么当前协程会阻塞并且等待其他协程往此通道写入值。因此，读操作将被阻塞。同理，如果你发送数据到一个通道，它将阻塞当前协程直到有其他协程从通道中读取数据。此时写操作将阻塞。</p><p>通道阻塞的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span> <span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;  <br>   fmt. Println (<span class="hljs-string">&quot;Hello &quot;</span> + &lt;-c + <span class="hljs-string">&quot;!&quot;</span>)  <br>   fmt.Println(<span class="hljs-string">&quot;Hello &quot;</span> + &lt;-c + <span class="hljs-string">&quot;!&quot;</span>)   <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">1</span>)  <br>   <span class="hljs-keyword">go</span> greet(c)  <br>   c &lt;- <span class="hljs-string">&quot;John&quot;</span>  <br>   <span class="hljs-comment">//close(c)  </span><br>   c &lt;- <span class="hljs-string">&quot;Mike&quot;</span>  <br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br><span class="hljs-comment">//无close</span><br>main() started<br>Hello John!<br>Hello Mike!<br>main() stopped<br><span class="hljs-comment">//有close</span><br>main() started<br>Hello John!<br>Hello !<br><span class="hljs-built_in">panic</span>: send on closed channel <span class="hljs-comment">//不能够像已经关闭的通道里面传数据</span><br></code></pre></td></tr></table></figure><h5 id="关闭-channel"><a href="#关闭-channel" class="headerlink" title="关闭 channel"></a>关闭 channel</h5><p><strong>可以使用 close 来关闭通道。</strong><br><strong>从已经关闭的通道接收数据或者正在接收数据时，将会接收到通道类型的零值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">n := &lt;- ch      <span class="hljs-comment">// 当ch被关闭后，n将被赋值为ch元素类型的零值</span><br>m, ok := &lt;-ch   <span class="hljs-comment">// 当ch被关闭后，m将被赋值为ch元素类型的零值, ok值为false</span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123; <span class="hljs-comment">// 当ch被关闭后，for range循环结束</span><br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>channel 的一个使用惯例: <strong>发送端负责关闭 channel。因为发送端没有像接受端那样的、可以安全判断 channel 是否被关闭了的方法。同时，一旦向一个已经关闭的 channel 执行发送操作，这个操作就会引发 panic</strong><br>所以对于普通的 for 循环需要手动去关闭通道，比如下面那样。不过 go 的 for range 在通道关闭的时候主动退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squares</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;  <br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++ &#123;  <br>      c &lt;- i * i  <br>   &#125;  <br>   <span class="hljs-built_in">close</span>(c)  <span class="hljs-comment">//不关闭的话会死锁</span><br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)  <br>   <span class="hljs-keyword">go</span> squares(c)  <br>   <span class="hljs-comment">//for &#123;  </span><br>    <span class="hljs-comment">//  val, ok := &lt;-c  </span><br>    <span class="hljs-comment">//  if ok == false &#123;  </span><br>    <span class="hljs-comment">//     fmt.Println(val, ok, &quot;&lt;-- loop broke&quot;)  </span><br>    <span class="hljs-comment">//     break  </span><br>     <span class="hljs-comment">// &#125; else &#123;  </span><br>    <span class="hljs-comment">//     fmt.Println(val, ok)  </span><br>    <span class="hljs-comment">//  &#125;  </span><br>   <span class="hljs-comment">//&#125;  </span><br>   <span class="hljs-keyword">for</span> val := <span class="hljs-keyword">range</span> c &#123;  <br>      fmt.Println(val)  <br>   &#125;  <br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="通道容量"><a href="#通道容量" class="headerlink" title="通道容量"></a>通道容量</h5><p>前面我们声明的都是无缓冲的通道，每次往无缓冲通道发送数据会阻塞当前协程，这是因为我们还没有使用 <code>make</code> 函数的第二个参数。这第二个参数代表通道缓冲区的容量。<br>默认情况下通道缓冲区容量为 0，被称为无缓冲通道。 向无缓冲通道发送的数据需要立即被读取。</p><p>当缓冲区参数不是 0 的时候。<strong>协程将不会阻塞除非缓冲区被填满</strong>。 当缓冲区满了之后，想要再往缓冲区发送数据只有等到有其他协程从缓冲区接收数据， (此时的发送协程是阻塞的)。 有一点需要注意， 读缓冲区的操作是<strong>渴望式读取</strong>.。意味着一旦读操作开始它将读取缓冲区所有数据，直到缓冲区为空。<strong>原理上来说读操作的协程将不会阻塞直到缓冲区为空。</strong> 而且<strong>如果通道没有放满，也不会阻止你去从通道读取数据</strong>.</p><p>可以使用以下语法定义有缓冲的 type 类型的通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type, n)<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;Hello &quot;</span> + &lt;-c + <span class="hljs-string">&quot;!&quot;</span>)  <br>   fmt.Println(<span class="hljs-string">&quot;Hello &quot;</span> + &lt;-c + <span class="hljs-string">&quot;!&quot;</span>)  <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">//前面例子里面这里是1</span><br>   <span class="hljs-keyword">go</span> greet(c)  <br>   c &lt;- <span class="hljs-string">&quot;John&quot;</span>   <br>   c &lt;- <span class="hljs-string">&quot;Mike&quot;</span>  <br>   <span class="hljs-comment">//c &lt;- &quot;Mike2&quot;  </span><br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br><span class="hljs-comment">// 输出</span><br>main() started<br>main() stopped<br><span class="hljs-comment">// /c &lt;- &quot;Mike2&quot;  </span><br>main() started<br>Hello John!<br>Hello Mike!<br>main() stopped<br></code></pre></td></tr></table></figure><h5 id="通道的长度和容量"><a href="#通道的长度和容量" class="headerlink" title="通道的长度和容量"></a>通道的长度和容量</h5><p>和切片类似，一个缓冲通道也有长度和容量。通道的长度是其内部缓冲队列未读的数据量，而通道的容量是缓冲区可最大盛放的数据量。我们可以使用 <code>len</code> 函数去计算通道的长度，使用 <code>cap</code> 函数去获得通道的容量<br><strong>虽然通道没有放满，也不会阻止你去从通道读取数据</strong>.<br><strong>虽然通道关闭了，但是数据还在缓冲区，我们仍然可以获取这些数据。</strong></p><h5 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h5><p>目前为止的通道都是双向通道，我们可以对通道做<strong>读操作</strong>和<strong>写操作</strong>。但是事实上我们也可以创建单向通道。比如<strong>只读通道</strong>只允许读操作，<strong>只写通道</strong>只允许写操作。<br>单向通道也可以使用 make 函数创建，不过需要额外加一个箭头语法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">roc := <span class="hljs-built_in">make</span> (&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-comment">//读</span><br>soc := <span class="hljs-built_in">make</span> (<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)<span class="hljs-comment">//写</span><br>fmt.Printf(<span class="hljs-string">&quot;Data type of roc is `%T`\n&quot;</span>, roc)  <br>fmt.Printf(<span class="hljs-string">&quot;Data type of soc is `%T`\n&quot;</span>, soc)<br><span class="hljs-comment">//输出</span><br>Data <span class="hljs-keyword">type</span> of roc is <span class="hljs-string">`&lt;-chan int`</span><br>Data <span class="hljs-keyword">type</span> of soc is <span class="hljs-string">`chan&lt;- int`</span><br></code></pre></td></tr></table></figure><p><strong>但是单向通道有什么作用呢</strong> ?<br>使用单向通道可以 <strong>提高程序的类型安全性</strong>， 使得程序不容易出错。</p><p>但是假如你在一个协程中只需要<strong>读操作</strong>某通道，但是在主线程中却需要<strong>读写操作</strong>这个通道该怎么办呢？<br>幸运的是 Go 可以直接把<strong>双向通道转化为单向通道</strong>。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230224151335.png]]</p><h5 id="通道类型的通道"><a href="#通道类型的通道" class="headerlink" title="通道类型的通道"></a>通道类型的通道</h5><p>通道也是一种类型可以像其他类型一样被用在很多地方：比如结构体元素，函数参数，函数返回值，甚至是作为其他通道的数据传输类型。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p><code>select</code> 和 <code>switch</code> 很像，它不需要输入参数，并且仅仅被使用在通道操作上。</p><p>通过 select，我们可以同时在多个 channel 上进行发送 &#x2F; 接收操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> x := &lt;-ch1:     <span class="hljs-comment">// 从channel ch1接收数据</span><br>  ... ...<br><br><span class="hljs-keyword">case</span> y, ok := &lt;-ch2: <span class="hljs-comment">// 从channel ch2接收数据，并根据ok值判断ch2是否已经关闭</span><br>  ... ...<br><br><span class="hljs-keyword">case</span> ch3 &lt;- z:       <span class="hljs-comment">// 将z值发送到channel ch3中:</span><br>  ... ...<br><br><span class="hljs-keyword">default</span>:             <span class="hljs-comment">// 当上面case中的channel通信均无法实施时，执行该默认分支</span><br>&#125;<br></code></pre></td></tr></table></figure><p>default 分支可以使 select 语句永不阻塞. 这意味着， 任何通道的 发送 和 接收 操作 (不管是缓冲或者非缓冲) 都不会阻塞当前线程。<br>如果有 case 块的通道操作是非阻塞，那么 select 会执行其 case 块。如果没有那么 select 将默认执行 default 块.<br>当 select 语句中没有 default 分支，而且所有 case 中的 channel 操作都阻塞了的时候，整个 select 语句都将被阻塞，直到某一个 case 上的 channel 变成可发送，或者某个 case 上的 channel 变成可接收，select 语句才可以继续进行下去。</p><p>注意：<strong>一个 nil 通道的 case 块会被忽略</strong>. <strong>select{}也是正确的语法，但是它会一直阻塞</strong><br>Nil 的用法就是，之前一直用 nil 通道使得 case 块被忽略，然后再激活。</p><h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p><strong>WaitGroup</strong> 是一个带着计数器的 <code>结构体</code>，这个计数器可以追踪到有多少协程创建，有多少协程完成了其工作。当计数器为 0 的时候说明所有协程都完成了其工作。<br>它主要有三个方法：<code>Add</code>, <code>Wait</code> 和 <code>Done</code></p><ul><li><code>Add</code> 方法的参数是一个变量名叫 <code>delta</code> 的 <code>int</code> 类型参数，主要用来内部计数。部计数器默认值为 0，它用于记录多少个协程在运行。当协程建立后，<code>计数器</code> 的值不会自动递增 ，因此需要我们手动递增它。我们可以通过给 <code>Add</code> 方法传 int 类型值来增加它的数量。</li><li><code>Done</code> 方法可以降低计数器的值。他不接受任何参数，因此，它每执行一次计数器就减 1。</li><li><code>Wait</code> 方法用来阻塞当前协程。一旦 <code>计数器</code> 为 0, 被阻塞的协程将恢复运行。<br>实例如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">service</span><span class="hljs-params">(wg *sync.WaitGroup, instance <span class="hljs-type">int</span>)</span></span> &#123;  <br>   time.Sleep(<span class="hljs-number">2</span> * time.Second)  <br>   fmt.Println(<span class="hljs-string">&quot;Service called on instance&quot;</span>, instance)  <br>   wg.Done()  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   <span class="hljs-keyword">var</span> wg sync.WaitGroup  <br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;  <br>      wg.Add(<span class="hljs-number">1</span>)  <br>      <span class="hljs-keyword">go</span> service(&amp;wg, i)  <br>   &#125;  <br>   wg.Wait()  <br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子中，我们在创建 wg 变量后，运行了三次 for 循环，每次运行的时候我们创建一个协程并给计数器加 1。 这意味着现在我们有三个协程在等待运行并且 WaitGroup 的计数器值为 3。注意我们传给协程函数的是一个指针，这是因为一旦在协程内部工作完成后，我们需要通过调用 Done 方法去降低计数器的值。 如果 wg 通过值复制方式传过去， 因为传递的是一个拷贝，主线程中的 wg 将不会得到修改。 </p><p>在 for 循环执行完成后，我们通过调用 wg. Wait () 去阻塞当前主线程，并把调度权让给其他协程，直到计数器值为 0 之后，主线程才会被再次调度。我们在另外三个协程中通过 Done 方法把计数器值降为 0，此时主线程将再次被调度并开始执行之后的代码。</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>goroutines 都有自己的独立的调用栈，因此他们之间不分享任何数据。但是有一种情况是数据存放在堆上，并且被多个 goroutines 使用。 多个 goroutines 试图去操作一个内存区域的数据会造成意想不到的后果。而互斥锁就是用来解决这个问题的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span> <span class="hljs-params">(wg *sync. WaitGroup)</span></span> &#123;  <br>   i = i + <span class="hljs-number">1</span>  <br>   wg. Done ()  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   <span class="hljs-keyword">var</span> wg sync.WaitGroup  <br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;  <br>      wg.Add(<span class="hljs-number">1</span>)  <br>      <span class="hljs-keyword">go</span> worker(&amp;wg)  <br>   &#125;  <br>   wg.Wait()  <span class="hljs-comment">//建了1000个协程</span><br>   fmt.Println(<span class="hljs-string">&quot;value of i after 1000 operations is &quot;</span>, i)  <br>&#125;<br><span class="hljs-comment">//输出</span><br>value of i after <span class="hljs-number">1000</span> operations is  <span class="hljs-number">983</span><br></code></pre></td></tr></table></figure><p>例如让我们从 1000 个 goroutines 中拿出两个举个例子，标明 G1 和 G2。</p><p>G1 开始执行的时候 i 为 0, 运行两步之后 i 现在是 1. 但是在 G1 执行第三步更新 i 的值的时候，新的协程 G2 被调度并且执行了 3 个步骤。 因此现在 i 的值为 1。现在 G1 又一次被调度从第二步开始更新了 i 的值。理想情况下，2 个协程调度后 i 的值应该是 2，但是事实却不是这样。因此我们可以猜想到为什么结果不是 1000。</p><p>目前为止我们学习到的调度方式都是协同调度。我们知道除非一个协程阻塞，否则其他协程是没有机会获得调度的。那么 i &#x3D; i + 1 也没有阻塞，为什么 Go 的调度器会去调度其他协程呢？ 好像不是很可靠。<br><strong>在任何情况下，都不应该依赖 Go 的调度算法，而应该实现自己的逻辑来同步不同的 goroutine</strong>（比如互斥锁）<br>互斥锁是一个编程概念，它保证了在同一时间只能有一个线程或者协程去操作同一个数据。当一个协程想要操作数据的时候，必须获取该数据的一个锁，操作完成后必须释放锁，如果没有获取到该数据的锁，那么就不能操作这个数据。<br>我们需要在操作数据之前使用 mutex. Lock () 去锁定它，一旦我们完成操作，比如上面提到的 i &#x3D; i + 1, 我们就可以使用  mutext. Unlock () 方法解锁。如果在锁定的时候，有一个协程想要读写 i 的值，那么此协程将阻塞 直到前面的协程完成操作并解锁数据。因此在某一时刻有且仅有一个协程可以操作数据，从而避免竞态条件。记住，任何锁之间的变量在解锁之前对于其他协程都不是可用的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(wg *sync.WaitGroup, m *sync.Mutex)</span></span> &#123;  <span class="hljs-comment">//新增m</span><br>   m.Lock()  <span class="hljs-comment">//加锁</span><br>   i = i + <span class="hljs-number">1</span>  <br>   m.Unlock()  <span class="hljs-comment">//解锁</span><br>   wg.Done()  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   <span class="hljs-keyword">var</span> wg sync.WaitGroup  <br>   <span class="hljs-keyword">var</span> m sync.Mutex  <span class="hljs-comment">//定义一个锁</span><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;  <br>      wg.Add(<span class="hljs-number">1</span>)  <br>      <span class="hljs-keyword">go</span> worker(&amp;wg, &amp;m)  <br>   &#125;  <br>   wg.Wait()  <br>   fmt.Println(<span class="hljs-string">&quot;value of i after 1000 operations is &quot;</span>, i)  <br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的结果来看互斥锁可以帮助我们解决竞态条件。 <strong>但首要规则是避免 goroutine 之间共享资源</strong>。</p><h2 id="图书管理-API-服务"><a href="#图书管理-API-服务" class="headerlink" title="图书管理 API 服务"></a>图书管理 API 服务</h2><h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><p>在这个实战小项目中，我们模拟的是真实世界的一个书店的图书管理后端服务。这个服务为平台前端以及其他客户端，提供针对图书的 CRUD（创建、检索、更新与删除）的基于 HTTP 协议的 API。API 采用典型的 RESTful 风格设计，这个服务提供的 API 集合如下：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230206223859.png]]<br>简单来说，我们通过 id 来唯一标识一本书，对于图书来说，这个 id 通常是 ISBN 号。至于客户端和服务端中请求与响应的数据，我们采用放在 HTTP 协议包体（Body）中的 Json 格式数据来承载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">mkdir</span> bookstore</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">cd</span> bookstore</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">go mod init bookstore</span><br>go: creating new go.mod: module bookstore<br></code></pre></td></tr></table></figure><p>这个服务大体拆分为两大部分，一部分是 HTTP 服务器，用来对外提供 API 服务；另一部分是图书数据的存储模块，所有的图书数据均存储在这里。</p><p><strong>项目布局</strong></p><pre><code class="hljs">├── cmd/
│   └── bookstore/         // 放置 bookstore main 包源码
│       └── main. go
├── go. mod                 // module bookstore 的 go. mod
├── go. sum
├── internal/              // 存放项目内部包的目录
│   └── store/
│       └── memstore. go     
├── server/                // HTTP 服务器模块
│   ├── middleware/
│   │   └── middleware. go
│   └── server. go          
└── store/                 // 图书数据存储模块
    ├── factory/
    │   └── factory. go
└── store. go
</code></pre><p>store. go 提供了 图书 和 接口的模板<br>factory. go 用于生产 接口实例<br>memstore. go 用于具体实现一个接口实例，实现其方法，并把样例发送到工厂<br>server. go 用于把路由和接口的方法对接起来</p><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><h4 id="什么是空导入"><a href="#什么是空导入" class="headerlink" title="什么是空导入"></a>什么是空导入</h4><p>像下面代码这样的包导入方式被称为“空导入”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;foo&quot;</span> <br></code></pre></td></tr></table></figure><p>空导入也是导入，意味着我们将依赖 foo 这个路径下的包。但由于是空导入，我们并没有显式使用这个包中的任何语法元素。<br>那么空导入的意义是什么呢？</p><p>由于依赖 foo 包，程序初始化的时候会沿着包的依赖链初始化 foo 包，包的初始化会按照常量-&gt;变量-&gt;init 函数的次序进行。通常实践中空导入意味着期望依赖包的 init 函数得到执行，这个 init 函数中有我们需要的逻辑。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Go/" class="category-chain-item">Go</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Go/" class="print-no-link">#Go</a></div></div><div class="license-box my-3"><div class="license-title"><div>【Go基础】未整理合集</div><div>https://zyweven.github.io/2023/03/17/【Go基础】未整理合集/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>even zhang</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年3月17日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/03/17/%E3%80%90Go%E5%88%B7%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3/" title="【Go刷题】字符串处理相关"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">【Go刷题】字符串处理相关</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/03/17/%E3%80%90Go%E5%88%B7%E9%A2%98%E3%80%91ACM%E8%BE%93%E5%85%A5/" title="【Go刷题】ACM输入输出"><span class="hidden-mobile">【Go刷题】ACM输入输出</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{t=t.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback(function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())})</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>