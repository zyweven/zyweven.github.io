<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mac电脑配置</title>
    <link href="/2025/06/21/Mac%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/06/21/Mac%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>前段时间运气好抽中了公司的电脑，以1600元的价格买了2020年的intel 芯片的Mac Pro<br><img src="/Mac%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/file-20250621220956864.png"></p><p>本来想要卖出去的，可能可以挣个几百元钱。不过有点懒，就暂时留手上自用了。自己也从来没有拥有过属于自己的Mac，而且我的2020年的y7000笔记本已经无法同时满足游戏+开发学习的需求了，所以想着这个Mac自己用来写东西搞开发也不错，win笔记本就纯拿来玩了。</p><h2 id="Mac-配置"><a href="#Mac-配置" class="headerlink" title="Mac 配置"></a>Mac 配置</h2><p>下面记录一下拿到新的Mac电脑进行的一些必要配置。</p><h3 id="常用软件下载"><a href="#常用软件下载" class="headerlink" title="常用软件下载"></a>常用软件下载</h3><p>QQ，微信，百度网盘，有道云笔记，chrome，cursor</p><h4 id="clash"><a href="#clash" class="headerlink" title="clash"></a>clash</h4><p>安装：<a href="https://github.com/clash-verge-rev/clash-verge-rev">https://github.com/clash-verge-rev/clash-verge-rev</a></p><h4 id="hapigo"><a href="#hapigo" class="headerlink" title="hapigo"></a>hapigo</h4><p>主要用截图功能</p><p><a href="https://www.hapigo.com/">https://www.hapigo.com/</a></p><h3 id="开发相关配置"><a href="#开发相关配置" class="headerlink" title="开发相关配置"></a>开发相关配置</h3><h4 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h4><p>安装参考如下</p><p><a href="https://brew.idayer.com/guide/change-source/">https://brew.idayer.com/guide/change-source/</a></p><p>brew 一些常用命令：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span>search <br><span class="hljs-keyword">brew </span>info <br><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span><br><span class="hljs-keyword">brew </span>remove <br><span class="hljs-keyword">brew </span>update <span class="hljs-comment">#更新 Homebrew </span><br><span class="hljs-keyword">brew </span>outdated <span class="hljs-comment">#查看是否需要更新包 </span><br><span class="hljs-keyword">brew </span>upgrade <span class="hljs-comment">#更新包</span><br></code></pre></td></tr></table></figure><h4 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h4><p>用于管理host配置</p><p><a href="https://github.com/oldj/SwitchHosts/releases">https://github.com/oldj/SwitchHosts/releases</a></p><p>使用：<a href="https://mp.weixin.qq.com/s/A37XnD3HdcGSWUflj6JujQ">https://mp.weixin.qq.com/s/A37XnD3HdcGSWUflj6JujQ</a></p><h4 id="bash自动补全"><a href="#bash自动补全" class="headerlink" title="bash自动补全"></a>bash自动补全</h4><p><a href="https://sourabhbajaj.com/mac-setup/BashCompletion/">https://sourabhbajaj.com/mac-setup/BashCompletion/</a><a href="https://link.juejin.cn/?target=https://sourabhbajaj.com/mac-setup/BashCompletion/"></a></p><p>使用 homebrew 来安装，执行以下命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span><span class="hljs-keyword">bash-completion</span><br></code></pre></td></tr></table></figure><p>安装完成，需要在.bash_profile文件中添加代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[ -f <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/etc/</span>bash_completion ] &amp;&amp; . <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/etc/</span>bash_completion<br></code></pre></td></tr></table></figure><p>或者用下面这个方式添加到.bash_profile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[ -f /usr/local/etc/bash_completion ] &amp;&amp; . /usr/local/etc/bash_completion&quot;</span> &gt;&gt; ~/.bash_profile<br></code></pre></td></tr></table></figure><p>添加后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><p>最后重启一下iterm2，即可</p><h4 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h4><p>先复制一份vim配置模板到个人目录下，然后用vi打开这个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /usr/share/vim/vimrc ~/.vimrc  #复制文件<br>vi ~/.vimrc  #打开文件<br></code></pre></td></tr></table></figure><p>在文件中追加一下语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">set nu! #行号 <br>syntax on #语法高亮 <br>set mouse=a #设置支持鼠标<br></code></pre></td></tr></table></figure><p>保存退出，即完成配置</p><h4 id="访达配置"><a href="#访达配置" class="headerlink" title="访达配置"></a>访达配置</h4><ul><li>在 Finder 标题栏显示完整路径</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">defaults write com.apple.finder _FXShowPosixPathInTitle -<span class="hljs-type">bool</span> YES;killall Finder<br></code></pre></td></tr></table></figure><ul><li>还原</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">defaults <span class="hljs-keyword">delete</span> com.apple.<span class="hljs-keyword">finder</span> _FXShowPosixPathInTitle;killall Finder<br></code></pre></td></tr></table></figure><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p>brew install mysql</p><p>使用mysql_secure_installation 指令开始mysql 密码等配置。</p><p><a href="https://cloud.tencent.com/developer/article/1868895">https://cloud.tencent.com/developer/article/1868895</a></p><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><p>1.安装jdk 17, 8 在官网上仔细看，还是可以找到安装入口的</p><p><a href="https://www.oracle.com/cn/java/technologies/downloads/#jdk24-mac">https://www.oracle.com/cn/java/technologies/downloads/#jdk24-mac</a></p><p>2.使用jenv管理jdk</p><p><a href="https://jasonkayzk.github.io/2023/12/17/%E4%BD%BF%E7%94%A8jenv%E7%AE%A1%E7%90%86jdk%E7%89%88%E6%9C%AC/">https://jasonkayzk.github.io/2023/12/17/%E4%BD%BF%E7%94%A8jenv%E7%AE%A1%E7%90%86jdk%E7%89%88%E6%9C%AC/</a></p><p><a href="https://developer.aliyun.com/article/634454">https://developer.aliyun.com/article/634454</a></p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客迁移记录</title>
    <link href="/2025/06/21/hexo%E5%8D%9A%E5%AE%A2%E4%BB%8Ewindows%E8%BF%81%E7%A7%BB%E5%88%B0mac%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/06/21/hexo%E5%8D%9A%E5%AE%A2%E4%BB%8Ewindows%E8%BF%81%E7%A7%BB%E5%88%B0mac%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br>hexo cl<br>hexo g<br>npm install<br>npm install --save hexo-theme-fluid<br><br>// 遇上执行hexo g的时候出现 ERROR Deployer not found: git<br>npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://blog.csdn.net/soyawww/article/details/118147820">https://blog.csdn.net/soyawww/article/details/118147820</a></p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾博客写作</title>
    <link href="/2024/09/21/%E3%80%90%E6%9D%82%E3%80%91%E9%87%8D%E6%8B%BE%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/"/>
    <url>/2024/09/21/%E3%80%90%E6%9D%82%E3%80%91%E9%87%8D%E6%8B%BE%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>一转眼已经毕业有 3 个多月了。目前远离家乡来到了上海，开始在得物工作。</p><p>目前周末常常找不到事情做，想想应该重拾一下博客写作吧，也算是程序员应该的技能了。</p><p>强迫自己输出一些东西总比漫无目的的刷手机强。希望可以坚持下去，不求质量但求有意义，目前暂定一个月至少一篇。</p><p>从十月开始。</p><p>[[创建博客过程简记#常用指令]]</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【杂】博客收集</title>
    <link href="/2023/06/08/%E3%80%90%E6%9D%82%E3%80%91%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/"/>
    <url>/2023/06/08/%E3%80%90%E6%9D%82%E3%80%91%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>之前收集了一些不错的博客，真心希望自己能够多看看这些博客，而不是就只是收藏在这里。</p><h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><ul><li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a> 里面的科技爱好者周刊还挺有意思的。有公众号，可以通过公众号看。  #综合博客 </li><li><a href="https://ruanyf-weekly.flowus.cn/">FlowUs 息流 - 新一代生产力工具</a> 同上，是科技爱好者的专栏，旁边有《谁在招人》可能以后会用到。</li><li><a href="https://tech.meituan.com/">美团技术团队</a> 美团的技术博客  #综合博客 </li><li><a href="https://www.liaoxuefeng.com/">首页 - 廖雪峰的官方网站</a> 里面有很多学习教程 #综合博客 </li><li><a href="https://jenny42.com/">jenny42’s life</a> 搜索观星偶然发现的博客，少见的女博客主，pi-review 导师评价网的创始人，博主叙述能力让我佩服。   #综合博客</li></ul><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul><li><a href="https://crossoverjie.top/">crossoverJie’s Blog</a> #Java博客  </li><li><a href="https://strrl.dev/">STRRL’s backyard</a> 经常更新  #Java博客 </li><li><a href="https://liuyanzhao.com/">言曌博客 | 学如逆水行舟，不进则退</a> Java 相关，经常更新 #Java博客 </li><li><a href="http://lihengxu.cn/">LihengXu’s Blog</a> 西安交通大学 ，里面有一点点的面经，base 成都 #Java博客</li></ul><h2 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h2><ul><li><a href="https://geektutu.com/">极客兔兔</a>  Go 语言学习博客 #Go博客 </li><li><a href="https://eddycjy.com/">煎鱼</a> 一个 go 大佬的博客，写了很多书。 #Go博客 </li><li><a href="https://lailin.xyz/">Mohuishou</a>   Go 语言学习博客，有公众号，写了 go 设计模式 #Go博客 </li><li><a href="https://www.liwenzhou.com/">李文周的博客 | 总结Go语言学习之路，提供免费的Go语言学习教程，希望与大家一起学习进步。</a> Go 语言学习博客 #Go博客</li><li><a href="http://v5blog.cn/">不做大哥好多年</a> 里面有 Go，python 的一些资料和面试题 可能有用。 #Go博客  #Python博客 </li><li><a href="https://www.qiyacloud.cn/">奇伢云存储</a> 一般是先博客再开公众号，这个是先公众号再开博客的，所以里面就只有技术类文章  #Go博客 #云原生 </li><li><a href="https://xargin.com/">No Headback</a> 曹大，好像挺厉害的, readings 部分有点意思，这博客居然没有标签功能  #Go博客 </li><li><a href="https://qcrao.com/">qcrao 的博客 | 专注于 Go 语言(golang)、后端架构、个人成长</a> go 博客博主很喜欢曹大 #Go博客 </li><li><a href="https://nova.moe/">Nova Kwok’s Awesome Blog</a>  经常更新的博客  #Go博客 </li><li><a href="https://www.pseudoyu.com/zh/">Pseudoyu</a> 文科生转码，经常更新 #Go博客 </li><li><a href="https://www.syst.top/">是不是很酷</a> go 博客 #Go博客 </li><li><a href="https://erdengk.top/archives">归档 | Forever Young</a> 一个喜欢开源的博主，里面有有关开源项目的资料，应该和我是同一个年龄段 #Go博客 </li><li><a href="https://www.cnblogs.com/Finley/category/1598973.html">用 Golang 实现 Redis - 随笔分类 - -Finley- - 博客园</a> 用 go 语言实现了一个 redis。 #Go博客 </li><li><a href="https://colobu.com/">https://colobu.com</a> 一个大佬的播客，在极客上有课，很厉害的感觉 #Go博客 </li><li><a href="https://imageslr.com/">Images’ Blog</a> 一个字节的大佬的播客，里面一些八股挺不错的  #Go博客</li></ul><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li><a href="https://catcoding.me/">程序员的喵</a> 前端相关 #前端博客</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul><li><a href="https://caojie.blog/">草结笔记</a>　python Web 相关的博客 #Python博客 </li><li><a href="https://fanyublog.com/">Dynamics and Python | Talk is cheap, show me the code</a>   里面有很多有意思的文章, 信号相关 #Python博客</li></ul><h2 id="Cpp"><a href="#Cpp" class="headerlink" title="Cpp"></a>Cpp</h2><ul><li><a href="https://www.fluentcpp.com/">Fluent C++ - Jonathan Boccara’s blog</a> 一个 Cpp 相关的网站更新的比较多 #Cpp博客 </li><li><a href="https://wyqz.top/">行码棋</a>   C++ STL 总结对我挺有用的 #Cpp博客</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li><a href="http://catkang.github.io/">Welcome | CatKang的博客</a> 阿里数据库内容团队  #数据库博客</li></ul><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><ul><li><a href="https://blog.youxu.info/">4G Spaces</a> 创业大佬年代很久的播客 #创业博客 </li><li><a href="https://www.desgard.com/">瓜田不纳履</a> 区域块链，量化交易， 博客里面有买房的文章值得一看 #区域块链 #买房</li></ul><h2 id="英文博客"><a href="#英文博客" class="headerlink" title="英文博客"></a>英文博客</h2><ul><li><a href="https://machinethink.net/blog/">Machine, Think!</a> 深度学习 ios 一个会深度学习和 ios 开发的大佬 #iOS #深度学习博客  </li><li><a href="https://zepto.page/">Zepto’s</a> 原本是因为 acm 算法相关的博文收藏的, 不过博主现在用英文写文章了, 多是些随笔.</li></ul><h2 id="深度学习-机器学习"><a href="#深度学习-机器学习" class="headerlink" title="深度学习&#x2F;机器学习"></a>深度学习&#x2F;机器学习</h2><ul><li><a href="https://www.cnblogs.com/pinard/">刘建平Pinard - 博客园</a> 里面有些机器学习的好文章, 但是很久没有更新了 #机器学习博客</li><li><a href="https://a-suozhang.xyz/">天辰的博客 | Tianchen’s Blog</a> #深度学习博客 </li><li><a href="https://spaces.ac.cn/">科学空间|Scientific Spaces</a> 　深度学习相关 #深度学习博客</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go刷题】字符串处理相关</title>
    <link href="/2023/03/17/%E3%80%90Go%E5%88%B7%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3/"/>
    <url>/2023/03/17/%E3%80%90Go%E5%88%B7%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串处理相关"><a href="#字符串处理相关" class="headerlink" title="字符串处理相关"></a>字符串处理相关</h1><p><a href="https://blog.csdn.net/zhangkaixuan456/article/details/128274921?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-128274921-blog-127093434.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-128274921-blog-127093434.pc_relevant_default&utm_relevant_index=2">Site Unreachable</a><br><a href="https://blog.csdn.net/laopeter0/article/details/127093434?spm=1001.2014.3001.5502">go语言字符串常用方法_go 字符串方法_ALIN琳的博客-CSDN博客</a></p><p>Go 中遍历字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;nihao&quot;</span>  <br>sChar := []<span class="hljs-type">byte</span>(s)  <br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sChar); i++ &#123;  <br>    fmt.Println(<span class="hljs-type">string</span>(sChar[i]))  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// strconv包，字符串和其他类型的相互转换</span><br>strconv.Itoa(<span class="hljs-type">int</span>)  <span class="hljs-comment">// int -&gt; string</span><br>strconv.Atoi(str)  <span class="hljs-comment">// string -&gt; int</span><br><br>strconv.ParseInt(str, , ) <span class="hljs-comment">// str-&gt;int 可以指定进制、类型.还有float\bool等</span><br>strconv.FormatInt(<span class="hljs-type">int</span>, , ) <span class="hljs-comment">// int-&gt;str。还有其他float等函数</span><br><br><span class="hljs-comment">// strings包，字符串的查找</span><br>strings.IndexByte(str, <span class="hljs-type">byte</span>) <span class="hljs-comment">// 查找字符串中字符的第一个位置。LastIndexByte是最后一个</span><br>strings.Index(str,str2)  <span class="hljs-comment">// 查找子串str2的第一个位置</span><br><br><span class="hljs-comment">// 字符串分割</span><br>strings.Splie(str, str2) <span class="hljs-comment">// 将str按str2作为分隔符进行分割，返回字符串切片</span><br><br><span class="hljs-comment">// 大小写切换</span><br>strings.ToLower(str) <span class="hljs-comment">// string全部转为小写</span><br>strings.ToUppe(str)  <span class="hljs-comment">// str全部转为大写</span><br><br><span class="hljs-comment">// 字符串删除</span><br>strings.Trim(str, str2) <span class="hljs-comment">// 将str中首位包含的str2全部删除</span><br><br><span class="hljs-comment">// 强制类型转换</span><br>x := []<span class="hljs-type">rune</span>(str)  <span class="hljs-comment">// 字符串转rune切片</span><br>str := <span class="hljs-type">string</span>(x)  <span class="hljs-comment">// rune切片转为字符串</span><br></code></pre></td></tr></table></figure><h1 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h1><h2 id="func-ParseInt"><a href="#func-ParseInt" class="headerlink" title="func ParseInt"></a>func <a href="https://github.com/golang/go/blob/master/src/strconv/atoi.go?name=release#150" title="View Source">ParseInt</a></h2><p>func ParseInt(s <a href="go/builtin.htm#string">string</a>, base <a href="go/builtin.htm#int">int</a>, bitSize <a href="go/builtin.htm#int">int</a>) (i <a href="go/builtin.htm#int64">int64</a>, err <a href="go/builtin.htm#error">error</a>)</p><p>返回字符串表示的整数值，接受正负号。</p><p>base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；</p><p>bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；返回的 err 是*NumErr 类型的，如果语法有误，err. Error &#x3D; ErrSyntax；如果结果超出类型范围 err. Error &#x3D; ErrRange</p><h2 id="func-FormatInt"><a href="#func-FormatInt" class="headerlink" title="func FormatInt"></a>func <a href="https://github.com/golang/go/blob/master/src/strconv/itoa.go?name=release#18" title="View Source">FormatInt</a></h2><p>func FormatInt(i <a href="go/builtin.htm#int64">int64</a>, base <a href="go/builtin.htm#int">int</a>) <a href="go/builtin.htm#string">string</a></p><p>返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//使用strconv包</span><br><br><span class="hljs-comment">//string to int  </span><br>strconv.Itoa(<span class="hljs-number">12</span>)  <span class="hljs-comment">// int -&gt; string</span><br>strconv.Atoi(<span class="hljs-string">&quot;-42&quot;</span>)  <span class="hljs-comment">// string -&gt; int</span><br><br><span class="hljs-comment">//string到int</span><br><span class="hljs-type">int</span>,_:=strconv.Atoi(<span class="hljs-string">&quot;123&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;type:%T;值:%v&quot;</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)<br><br><span class="hljs-comment">//string到int64</span><br><span class="hljs-type">int64</span>, _ := strconv.ParseInt(<span class="hljs-string">&quot;456&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<br>fmt.Printf(<span class="hljs-string">&quot;type:%T;值:%v&quot;</span>,<span class="hljs-type">int64</span>,<span class="hljs-type">int64</span>)<br><br><span class="hljs-comment">//int到string</span><br><span class="hljs-type">string</span>:=strconv.Itoa(<span class="hljs-type">int</span>)<br>fmt.Printf(<span class="hljs-string">&quot;type:%T;值:%v&quot;</span>,<span class="hljs-type">string</span>,<span class="hljs-type">string</span>)<br><br><span class="hljs-comment">//int64到string</span><br>str10:=strconv.FormatInt(<span class="hljs-number">160</span>,<span class="hljs-number">10</span>)<br>fmt.Printf(<span class="hljs-string">&quot;type:%T;值:%v&quot;</span>,str10,str10)<br><br><span class="hljs-comment">//string到float32(float64)</span><br>float,_ := strconv.ParseFloat(<span class="hljs-string">&quot;165.34&quot;</span>,<span class="hljs-number">32</span>/<span class="hljs-number">64</span>)<br>fmt.Printf(<span class="hljs-string">&quot;type:%T;值:%v&quot;</span>,float,float)<br><br><span class="hljs-comment">//float到string</span><br>fts32 := strconv.FormatFloat(<span class="hljs-number">3.1415926</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">32</span>)<br>fts64 := strconv.FormatFloat(<span class="hljs-number">3.1415926</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">64</span>)<br>fmt.Printf(<span class="hljs-string">&quot;type:%T;值:%v&quot;</span>,fts32,fts32)<br><br>fmt.Printf(<span class="hljs-string">&quot;type:%T;值:%v&quot;</span>,fts64,fts64)<br><br></code></pre></td></tr></table></figure><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Compare(a, b)<span class="hljs-comment">//比较a,b，a大为1，b大为-1，相等为0</span><br><br>fmt.Println(strings.Compare(<span class="hljs-type">string</span>(<span class="hljs-string">&quot;hello&quot;</span>), <span class="hljs-type">string</span>(<span class="hljs-string">&quot;haha&quot;</span>)))  <span class="hljs-comment">// 1</span><br>fmt.Println(strings.Compare(<span class="hljs-type">string</span>(<span class="hljs-string">&quot;hello&quot;</span>), <span class="hljs-type">string</span>(<span class="hljs-string">&quot;world&quot;</span>))) <span class="hljs-comment">// -1</span><br>fmt.Println(strings.Compare(<span class="hljs-type">string</span>(<span class="hljs-string">&quot;hello&quot;</span>), <span class="hljs-type">string</span>(<span class="hljs-string">&quot;helloworld&quot;</span>)))  <span class="hljs-comment">// -1</span><br>fmt.Println(strings.Compare(<span class="hljs-type">string</span>(<span class="hljs-string">&quot;hello&quot;</span>), <span class="hljs-type">string</span>(<span class="hljs-string">&quot;hello&quot;</span>)))  <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Split(a, <span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="字符串第一次出现的位置"><a href="#字符串第一次出现的位置" class="headerlink" title="字符串第一次出现的位置"></a>字符串第一次出现的位置</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Index(s, sub_s)<br></code></pre></td></tr></table></figure><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">n是替换的次数，负数表示全部替换  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Replace</span><span class="hljs-params">(s, old, <span class="hljs-built_in">new</span> <span class="hljs-type">string</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span>  <br>  <br>strings.Replace(<span class="hljs-string">&quot;nihao&quot;</span>, <span class="hljs-string">&quot;ni&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>, <span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h2 id="字符串大小写"><a href="#字符串大小写" class="headerlink" title="字符串大小写"></a>字符串大小写</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 给定字符串转换为英文标题的首字母大写的格式(不能正确处理unicode标点)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Title</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 所有字母转换为小写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ToLower</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 所有字母转换为大写</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ToUpper</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><br>fmt.Println(strings.Title(<span class="hljs-string">&quot;her royal highness&quot;</span>))  <span class="hljs-comment">// Her Royal Highness</span><br>fmt.Println(strings.ToLower(<span class="hljs-string">&quot;Gopher123&quot;</span>))  <span class="hljs-comment">// gopher123</span><br>fmt.Println(strings.ToUpper(<span class="hljs-string">&quot;Gopher&quot;</span>))  <span class="hljs-comment">// GOPHER</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go基础】未整理合集</title>
    <link href="/2023/03/17/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E6%9C%AA%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86/"/>
    <url>/2023/03/17/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E6%9C%AA%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>学习 go 写的笔记，后续整理一下</p><h2 id="go-变量声明"><a href="#go-变量声明" class="headerlink" title="go 变量声明"></a>go 变量声明</h2><p><img src="/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E6%9C%AA%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86/image-20230317155751372.png"></p><p>go 语言变量声明特点：</p><ul><li>变量类型是在后面</li><li>即使没有显式初始化，Go 语言也会给变量赋予初始零值</li></ul><p>编程原则：</p><ul><li>让变量的作用域最小化</li><li>良好的函数 &#x2F; 方法设计都讲究“单一职责”，所以每个函数 &#x2F; 方法规模都不大<br>变量声明原则：</li></ul><ol><li>就近原则：尽可能在靠近第一次使用变量的位置声明这个变量。<ul><li>就近原则实际上也是对变量的作用域最小化的一种实现手段。</li><li>如果一个包级变量在包内部被多处使用，那么这个变量还是放在源文件头部声明比较适合的。</li></ul></li></ol><h2 id="go-包管理"><a href="#go-包管理" class="headerlink" title="go 包管理"></a>go 包管理</h2><h4 id="Go-构建模式的演化"><a href="#Go-构建模式的演化" class="headerlink" title="Go 构建模式的演化"></a>Go 构建模式的演化</h4><p>Go 程序的构建过程就是确定包版本、编译包以及将编译后得到的目标文件链接在一起的过程。<br>演变过程：<strong>GOPATH</strong>  -&gt; <strong>Vendor</strong> -&gt; <strong>GO Module</strong></p><h5 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h5><p>Go 编译器可以在本地 GOPATH 环境变量配置的路径下，搜寻 Go 程序依赖的第三方包。如果存在，就使用这个本地包进行编译；如果不存在，就会报编译错误。</p><p><strong>GOPATH 如何使用？</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">如果当前的 GOPATH 为：<br>export GOPATH=/usr/local/goprojects:/home/tonybai/go<br><br>那么Go 编译器在编译 Go 程序时，就会在下面两个路径下搜索第三方依赖包是否存在：<br>/usr/local/goprojects/src/github.com/user/repo<br>/home/tonybai/go/src/github.com/user/repo<br><br>如果没有找到的话，就需要程序员使用go get来将本地缺失的第三方依赖包下载到本地<br>如：<br><span class="hljs-meta prompt_">$</span><span class="language-bash">go get github.com/sirupsen/logrus</span><br>这里的 go get 命令，不仅能将 logrus 包下载到 GOPATH 环境变量配置的目录下，它还会检查 logrus 的依赖包在本地是否存在，如果不存在，go get 也会一并将它们下载到本地。<br>但是，go get 下载的包只是那个时刻各个依赖包的最新主线版本。而依赖包是会持续演进的，这就不能保证程序的可重现的构建（Reproduceable Build）。<br></code></pre></td></tr></table></figure><h6 id="GOPATH-的问题"><a href="#GOPATH-的问题" class="headerlink" title="GOPATH 的问题"></a>GOPATH 的问题</h6><p>在 GOPATH 构建模式下，&#x3D;&#x3D;Go 编译器实质上并没有关注 Go 项目所依赖的第三方包的版本。&#x3D;&#x3D;<br>但 Go 开发者希望自己的 Go 项目所依赖的第三方包版本能受到自己的控制，而不是随意变化。于是 Go 核心开发团队引入了 Vendor 机制试图解决上面的问题。</p><h5 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h5><p>Go 在 1.5 版本中引入 vendor 机制。vendor 机制本质上就是在 Go 项目的某个特定目录下，将项目的所有依赖包缓存起来，这个特定目录名就是 vendor。<br>Go 编译器会优先感知和使用 <strong>vendor 目录</strong>下缓存的第三方包版本，而不是 GOPATH 环境变量所配置的路径下的第三方包版本。这样，无论第三方依赖包自己如何变化，无论 GOPATH 环境变量所配置的路径下的第三方包是否存在、版本是什么，都不会影响到 Go 程序的构建。<br>这样，只要将 vendor 目录和项目源码一样提交到代码仓库，那么其他开发者下载你的项目后，就可以实现可重现的构建。因此，如果使用 vendor 机制管理第三方依赖包，最佳实践就是将 vendor 一并提交到代码仓库中。<br>不过，要想开启 vendor 机制，你的 <strong>Go 项目必须位于 GOPATH 环境变量配置的某个路径的 src 目录下面</strong>。如果不满足这一路径要求，那么 Go 编译器是不会理会 Go 项目目录下的 vendor 目录的</p><h6 id="vendor-的问题"><a href="#vendor-的问题" class="headerlink" title="vendor 的问题"></a>vendor 的问题</h6><p>一方面，Go 项目必须放在 GOPATH 环境变量配置的路径下，庞大的 vendor 目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度，而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响。（感觉就像是把 vue 项目里面的 module 给一起上传到 GitHub 一样）<br>另一方面，还需要手工管理 vendor 下面的 Go 依赖包，包括项目依赖包的分析、版本的记录、依赖包获取和存放，等等。</p><h5 id="⭐Go-Module"><a href="#⭐Go-Module" class="headerlink" title="⭐Go Module"></a>⭐Go Module</h5><p>从 Go 1.11 版本开始有 Go Module<br>一个 Go Module 是一个 Go 包的集合。module 是有版本的，所以 module 下的包也就有了版本属性。这个 module 与这些包会组成一个独立的版本单元，它们一起打版本、发布和分发。<br>在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。一个 Go Module 的顶层目录下会放置一个 go. mod 文件，每个 go. mod 文件会定义唯一一个 module，它们是一一对应的关系。<br>go. mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。</p><h6 id="如何创建一个-Go-module"><a href="#如何创建一个-Go-module" class="headerlink" title="如何创建一个 Go module"></a>如何创建一个 Go module</h6><p>第一步，通过 go mod init 创建 go. mod 文件，将当前项目变为一个 Go Module；<br>第二步，通过 go mod tidy 命令自动更新当前 module 的依赖信息；<br>第三步，执行 go build，执行新 module 的构建。</p><p><font color=" #2DC26B ">指令解析：</font><br><font color=" #4f81bd ">go mod init </font><br>go mod init 会在当前项目目录下创建了一个 go. mod 文件。</p><p><font color=" #4f81bd ">go mod tidy</font><br>go mod tidy 命令会扫描 Go 源码，并自动找出项目依赖的外部 Go Module 以及版本，下载这些依赖并更新本地的 go. mod 文件。<br>执行完 go mod tidy 后，当前项目除了 go. mod 文件外，还多了一个新文件 go. sum，它同样是由 go mod 相关命令维护的一个文件，它存放了特定版本 module 内容的哈希值，它可以确保项目所依赖的 module 内容，不会被恶意或意外篡改。<br>由 go mod tidy 下载的依赖 module 会被放置在本地的 module 缓存路径下，默认值为 $GOPATH[0]&#x2F;pkg&#x2F;mod，Go 1.15 及以后版本可以通过 GOMODCACHE 环境变量，自定义本地 module 的缓存路径。</p><p><font color=" #4f81bd ">go build</font><br>go build 命令会读取 go. mod 中的依赖及版本信息，并在本地 module 缓存路径下找到对应版本的依赖 module，执行编译和链接。如果顺利的话，我们会在当前目录下看到一个新生成的可执行文件 module-mode，执行这个文件我们就能得到正确结果了。</p><h6 id="Go-Module-构建模式的特点"><a href="#Go-Module-构建模式的特点" class="headerlink" title="Go Module 构建模式的特点"></a>Go Module 构建模式的特点</h6><p>####### <strong>一、 语义导入版本”机制</strong><br>![[【Go基础】未整理合集&#x2F;Pasted image 20230209170742.png|750]]<br>如上图，语义版本号分成 3 部分：主版本号 (major)、次版本号 (minor) 和补丁版本号 (patch)。例如 logrus module 的版本号是 v1.8.1，这就表示它的主版本号为 1，次版本号为 8，补丁版本号为 1。<br>按照语义版本规范，主版本号不同的两个版本是相互不兼容的。而且，在主版本号相同的情况下，次版本号大都是向后兼容次版本号小的版本。补丁版本号也不影响兼容性。<br><strong>Go Module 规定：如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的。</strong><br>那么如果之前我们一直使用的是 logrus v1 的版本，而 logrus 发布了和 v1 不兼容的 v2 版本时我们应该使用什么方式导入 logrus v2.0.0 版本呢？<br>Go Module 创新性地给出了一个方法：<strong>将包主版本号引入到包导入路径中。</strong> 这就是 Go 的“语义导入版本”机制，也就是说<strong>通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本，这样一来我们甚至可以同时依赖一个包的两个不兼容版本</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/sirupsen/logrus&quot;</span> <span class="hljs-comment">//导入 v1</span><br>    logv2 <span class="hljs-string">&quot;github.com/sirupsen/logrus/v2&quot;</span> <span class="hljs-comment">//导入 v2</span><br>)<br></code></pre></td></tr></table></figure><p><strong>二、 最小版本选择原则</strong><br>![[【Go基础】未整理合集&#x2F;Pasted image 20230209172101.png|1000]]</p><p>在这张图中，myproject 有两个直接依赖 A 和 B，A 和 B 有一个共同的依赖包 C，但 A 依赖 C 的 v1.1.0 版本，而 B 依赖的是 C 的 v1.3.0 版本，并且此时 C 包的最新发布版为 C v1.7.0 。那么我们应该使用 C 的哪个版本？<br>对于一些其他依赖管理工具可能会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 v1.7.0。<br>而对于 <strong>Go</strong> 会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本”。<br>这个例子中，C v1.3.0 是符合项目整体要求的版本集合中的版本最小的那个，于是 <strong>Go 命令选择了 C v1.3.0</strong>，而不是最新最大的 C v1.7.0。并且，<br>Go 团队认为“最小版本选择”为 Go 程序实现持久的和可重现的构建提供了最佳的方案。<br>注意：Go Module 将 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径。</p><h6 id="Go-各版本构建模式机制和切换"><a href="#Go-各版本构建模式机制和切换" class="headerlink" title="Go 各版本构建模式机制和切换"></a>Go 各版本构建模式机制和切换</h6><p>可以通过设置 GO111MODULE 的值来进行切换。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230209172602.png|1450]]</p><h4 id="包管理实践"><a href="#包管理实践" class="headerlink" title="包管理实践"></a>包管理实践</h4><h5 id="为当前-module-添加一个依赖"><a href="#为当前-module-添加一个依赖" class="headerlink" title="为当前 module 添加一个依赖"></a>为当前 module 添加一个依赖</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">方法一<br><span class="hljs-meta prompt_">$</span><span class="language-bash">go get github.com/google/uuid  //手动添加</span><br>go: downloading github.com/google/uuid v1.3.0<br>go get: added github.com/google/uuid v1.3.0<br>方法二<br><span class="hljs-meta prompt_">$</span><span class="language-bash">go mod tidy  //自动检测</span><br>go: finding module for package github.com/google/uuid<br>go: found github.com/google/uuid in github.com/google/uuid v1.3.0<br></code></pre></td></tr></table></figure><p>手工执行 go get 新增依赖项，和执行 go mod tidy 自动分析和下载依赖项的最终效果，是等价的。但对于复杂的项目变更而言，逐一手工添加依赖项显然很没有效率，go mod tidy 是更佳的选择。</p><h5 id="升级-降级依赖的版本"><a href="#升级-降级依赖的版本" class="headerlink" title="升级 &#x2F; 降级依赖的版本"></a>升级 &#x2F; 降级依赖的版本</h5><p>以 logrus 为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">//使用一下指令可以查询logrus的多个发布版本<br><span class="hljs-meta prompt_">$</span><span class="language-bash">go list -m -versions github.com/sirupsen/logrus</span><br><br>github.com/sirupsen/logrus v0.1.0 v0.1.1 v0.2.0 v0.3.0 v0.4.0 v0.4.1 v0.5.0 v0.5.1 v0.6.0 v0.6.1 v0.6.2 v0.6.3 v0.6.4 v0.6.5 v0.6.6 v0.7.0 v0.7.1 v0.7.2 ...<br></code></pre></td></tr></table></figure><p>如果我们想从 v1.8.1 降到 v1.7.0，可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go get github.com/sirupsen/logrus@v1.7.0</span><br><br>go: downloading github.com/sirupsen/logrus v1.7.0<br>go get: downgraded github.com/sirupsen/logrus v1.8.1 =&gt; v1.7.0<br></code></pre></td></tr></table></figure><p>或者使用 go mod tidy 也可以，但是要先编辑 go mod 明确告知我们要依赖 v1.7.0 版本，而不是 v1.8.1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go mod edit -require=github.com/sirupsen/logrus@v1.7.0</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">go mod tidy</span>       <br><br>go: downloading github.com/sirupsen/logrus v1.7.0<br></code></pre></td></tr></table></figure><h5 id="添加一个主版本号大于-1-的依赖"><a href="#添加一个主版本号大于-1-的依赖" class="headerlink" title="添加一个主版本号大于 1 的依赖"></a>添加一个主版本号大于 1 的依赖</h5><p>语义导入版本机制有一个原则：如果新旧版本的包使用相同的导入路径，那么新包与旧包是兼容的。也就是说，<strong>如果新旧两个包不兼容，那么我们就应该采用不同的导入路径。</strong><br>如果我们要为 Go 项目添加主版本号大于 1 的依赖，我们就需要使用“语义导入版本”机制，在声明它的导入路径的基础上，加上版本号信息。<br>比如 redis 的导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>  _ <span class="hljs-string">&quot;github.com/go-redis/redis/v7&quot;</span> <span class="hljs-comment">// “_”为空导入</span><br>  <span class="hljs-string">&quot;github.com/google/uuid&quot;</span><br>  <span class="hljs-string">&quot;github.com/sirupsen/logrus&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  logrus.Println(<span class="hljs-string">&quot;hello, go module mode&quot;</span>)<br>  logrus.Println(uuid.NewString())<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go get github.com/go-redis/redis/v7</span><br><br>go: downloading github.com/go-redis/redis/v7 v7.4.1<br>go: downloading github.com/go-redis/redis v6.15.9+incompatible<br>go get: added github.com/go-redis/redis/v7 v7.4.1<br></code></pre></td></tr></table></figure><h5 id="升级依赖版本到一个不兼容版本"><a href="#升级依赖版本到一个不兼容版本" class="headerlink" title="升级依赖版本到一个不兼容版本"></a>升级依赖版本到一个不兼容版本</h5><p>假如我们想把 redis v7 升级到 v8<br>首先在代码中把 v7 改成 v8</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>  _ <span class="hljs-string">&quot;github. com/go-redis/redis/v8&quot;</span><br>  <span class="hljs-string">&quot;github. com/google/uuid&quot;</span><br>  <span class="hljs-string">&quot;github.com/sirupsen/logrus&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go get github.com/go-redis/redis/v8</span><br>go: downloading github.com/go-redis/redis/v8 v8.11.1<br>go: downloading github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f<br>go: downloading github.com/cespare/xxhash/v2 v2.1.1<br>go get: added github.com/go-redis/redis/v8 v8.11.1<br></code></pre></td></tr></table></figure><p>就可以了</p><h5 id="移除一个依赖"><a href="#移除一个依赖" class="headerlink" title="移除一个依赖"></a>移除一个依赖</h5><p>要想彻底从项目中移除 go. mod 中的依赖项，仅从源码中删除对依赖项的导入语句还不够。这是因为如果源码满足成功构建的条件，go build 命令是不会“多管闲事”地清理 go. mod 中多余的依赖项的。<br>那正确的做法是怎样的呢？我们还得用 go mod tidy 命令，将这个依赖项彻底从 Go Module 构建上下文中清除掉。go mod tidy 会自动分析源码依赖，而且将不再使用的依赖从 go. mod 和 go. sum 中移除。<br>也就是使用 go build 无效 而要用一次 go mod tidy 才行。</p><h5 id="特殊情况：使用-vendor"><a href="#特殊情况：使用-vendor" class="headerlink" title="特殊情况：使用 vendor"></a>特殊情况：使用 vendor</h5><p>在 Go Module 构建模式下，vendor 依旧被保留了下来，并且成为了 Go Module 构建机制的一个很好的补充。<br>特别是在一些不方便访问外部网络，并且对 Go 应用构建性能敏感的环境，比如在一些内部的持续集成或持续交付环境（CI&#x2F;CD）中，使用 vendor 机制可以实现与 Go Module 等价的构建。<br>和 GOPATH 构建模式不同，Go Module 构建模式下，我们再也无需手动维护 vendor 目录下的依赖包了，Go 提供了可以快速建立和更新 vendor 的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go mod vendor  //使用该指令</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -LF 2 vendor</span><br>vendor<br>├── github.com/<br>│   ├── google/<br>│   ├── magefile/<br>│   └── sirupsen/<br>├── golang.org/<br>│   └── x/<br>└── modules.txt<br></code></pre></td></tr></table></figure><p>go mod vendor 命令在 vendor 目录下，创建了一份这个项目的依赖包的副本，并且通过 vendor&#x2F;modules. txt 记录了 vendor 下的 module 以及版本。<br>如果我们要基于 vendor 构建，而不是基于本地缓存的 Go Module 构建，我们需要在 go build 后面加上 -mod&#x3D;vendor 参数。<br>在 Go 1.14 及以后版本中，如果 Go 项目的顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非你给 go build 传入 -mod&#x3D;mod 的参数。</p><h2 id="Go-语言的设计哲学"><a href="#Go-语言的设计哲学" class="headerlink" title="Go 语言的设计哲学"></a>Go 语言的设计哲学</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>简单是指 Go 语言特性始终保持在少且足够的水平，不走语言特性融合的道路，但又不乏生产力。简单是 Go 生产力的源泉，也是 Go 对开发者的最大吸引力；</p><h3 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h3><p>显式是指任何代码行为都需开发者明确知晓，不存在因“暗箱操作”而导致可维护性降低和不安全的结果；</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合是构建 Go 程序骨架的主要方式，它可以大幅降低程序元素间的耦合，提高程序的可扩展性和灵活性；</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发是 Go 敏锐地把握了 CPU 向多核方向发展这一趋势的结果，可以让开发人员在多核时代更容易写出充分利用系统资源、支持性能随 CPU 核数增加而自然提升的应用程序；</p><h3 id="面向工程"><a href="#面向工程" class="headerlink" title="面向工程"></a>面向工程</h3><p>面向工程是 Go 语言在语言设计上的一个重大创新，它将语言要解决的问题域扩展到那些原本并不是由编程语言去解决的领域，从而覆盖了更多开发者在开发过程遇到的“痛点”，为开发者提供了更好的使用体验。</p><h2 id="Go-程序认知"><a href="#Go-程序认知" class="headerlink" title="Go 程序认知"></a>Go 程序认知</h2><p>Go 源文件总是用<strong>全小写字母形式的短小单词命名</strong>，并且以. go 扩展名结尾。<br>如果要在源文件的名字中使用多个单词，我们通常直接是将多个单词连接起来作为源文件名，而不是使用其他分隔符，比如下划线。也就是说，我们通常使用 <strong>helloworld. go</strong> 作为文件名而不是 hello_world. go。这是因为下划线这种分隔符，在 Go 源文件命名中有特殊作用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;hello, world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个 main，main 包在 Go 中是一个特殊的包，整个 Go 程序中仅允许存在一个名为 main 的包。<br>包是 Go 语言的基本组成单元，通常使用单个的小写单词命名，一个 Go 程序本质上就是一组包的集合。<br>Go 语言内置了一套 Go 社区约定俗称的代码风格，并随安装包提供了一个名为 Gofmt 的工具，这个工具可以帮助你将代码自动格式化为约定的风格。作为 Go 开发人员，请在提交你的代码前使用 Gofmt 格式化你的 Go 源码。<br><strong>注意：</strong></p><ul><li>import “fmt” 一行中“fmt”代表的是<strong>包的导入路径</strong>（Import），它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包；通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的“fmt”指的是包名，其实并不是这样的。</li><li>fmt. Println 函数调用一行中的“fmt”代表的则是包名。<br>main 包是不可以像标准库 fmt 包那样被导入（Import）<br>Go 源码文件本身采用的是 Unicode 字符集，而且用的是 UTF-8 标准的字符编码方式，这与编译后的程序所运行的环境所使用的字符集和字符编码方式是一致的。</li></ul><p>Go 是一种编译型语言，这意味着只有你编译完 Go 程序之后，才可以将生成的可执行文件交付于其他人，并运行在没有安装 Go 的环境中。<br>而如果你交付给其他人的是一份. rb、. py 或. js 的动态语言的源文件，那么他们的目标环境中就必须要拥有对应的 Ruby、Python 或 JavaScript 实现才能解释执行这些源文件。</p><h2 id="Go-项目布局"><a href="#Go-项目布局" class="headerlink" title="Go 项目布局"></a>Go 项目布局</h2><h3 id="Go-语言项目自身的最初源码结构布局"><a href="#Go-语言项目自身的最初源码结构布局" class="headerlink" title="Go 语言项目自身的最初源码结构布局"></a>Go 语言项目自身的最初源码结构布局</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">cd</span> go // 进入 Go 语言项目根目录</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">git checkout go1.3 // 切换到go 1.3版本</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -LF 1 ./src // 查看src目录下的结构布局</span><br>./src<br>├── all.bash*<br>├── clean.bash*<br>├── cmd/<br>├── make.bash*<br>├── Make.dist<br>├── pkg/<br>├── race. bash*<br>├── run.bash*<br>... ...<br>└── sudo.bash*<br></code></pre></td></tr></table></figure><p>src 目录下面的结构有这三个特点。<br>首先，你可以看到，以 all. bash 为代表的代码构建的脚本源文件放在了 src 下面的顶层目录下。<br>第二，src 下的二级目录 cmd 下面存放着 Go 相关可执行文件的相关目录。<br>第三个特点， src 下的二级目录 pkg 下面存放着运行时实现、标准库包实现，这些包既可以被上面 cmd 下各程序所导入，也可以被 Go 语言项目之外的 Go 程序依赖并导入。<br>如今，这个布局经过了很多演进。<br><strong>演进一：Go 1.4 版本删除 pkg 这一中间层目录并引入 internal 目录</strong><br><strong>演进二：Go1.6 版本增加 vendor 目录</strong><br><strong>演进三：Go 1.13 版本引入 go. mod 和 go. sum</strong></p><h3 id="现在的-Go-项目的典型结构布局"><a href="#现在的-Go-项目的典型结构布局" class="headerlink" title="现在的 Go 项目的典型结构布局"></a>现在的 Go 项目的典型结构布局</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -F exe-layout</span> <br>exe-layout<br>├── cmd/<br>│   ├── app1/<br>│   │   └── main.go<br>│   └── app2/<br>│       └── main.go<br>├── go.mod<br>├── go.sum<br>├── internal/<br>│   ├── pkga/<br>│   │   └── pkg_a.go<br>│   └── pkgb/<br>│       └── pkg_b.go<br>├── pkg1/<br>│   └── pkg1.go<br>├── pkg2/<br>│   └── pkg2.go<br>└── vendor/<br></code></pre></td></tr></table></figure><h4 id="cmd-目录"><a href="#cmd-目录" class="headerlink" title="cmd 目录"></a><strong>cmd 目录</strong></h4><p>cmd 目录存放项目要编译构建的可执行文件对应的 main 包的源文件。如果你的项目中有多个可执行文件需要构建，每个可执行文件的 main 包单独放在一个子目录中，比如图中的 app1、app2，cmd 目录下的各 app 的 main 包将整个项目的依赖连接在一起。<br>通常来说，main 包应该很简洁。我们在 main 包中会做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象。另外，也有一些 Go 项目将 cmd 这个名字改为 app 或其他名字，但它的功能其实并没有变。</p><h4 id="pkgN-目录"><a href="#pkgN-目录" class="headerlink" title="pkgN 目录"></a><strong>pkgN 目录</strong></h4><p>pkgN 目录，这是一个存放项目自身要使用、同样也是可执行文件对应 main 包所要依赖的库文件，同时这些目录下的包还可以被外部项目引用。</p><h4 id="internal-目录"><a href="#internal-目录" class="headerlink" title="internal 目录"></a><strong>internal 目录</strong></h4><p> internal 目录下的 Go 包，只可以被本项目内部的包导入。项目外部是无法导入这个 internal 目录下面的包。</p><h4 id="go-mod-和-go-sum"><a href="#go-mod-和-go-sum" class="headerlink" title="go. mod 和 go. sum"></a><strong>go. mod 和 go. sum</strong></h4><p>们是 Go 语言包依赖管理使用的配置文件。</p><h4 id="vendor-目录"><a href="#vendor-目录" class="headerlink" title="vendor 目录"></a><strong>vendor 目录</strong></h4><p>vendor 目录可以视为一个可选目录。因为大多数项目使用 Go Module 构建。</p><h2 id="多-module-的目录"><a href="#多-module-的目录" class="headerlink" title="多 module 的目录"></a>多 module 的目录</h2><p>如果非要在一个代码仓库中存放多个 module，可以用如下的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree multi-modules</span><br>multi-modules<br>├── go.mod // mainmodule<br>├── module1<br>│   └── go.mod // module1<br>└── module2<br>    └── go.mod // module2<br></code></pre></td></tr></table></figure><h3 id="Go-可执行程序项目的典型布局-和早期布局"><a href="#Go-可执行程序项目的典型布局-和早期布局" class="headerlink" title="Go 可执行程序项目的典型布局 和早期布局"></a>Go 可执行程序项目的典型布局 和早期布局</h3><p>如果 Go 可执行程序项目有一个且只有一个可执行程序要构建:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -F -L 1 single-exe-layout</span><br>single-exe-layout<br>├── go.mod<br>├── internal/<br>├── main.go<br>├── pkg1/<br>├── pkg2/<br>└── vendor/<br></code></pre></td></tr></table></figure><p>早期布局:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -L 3 -F early-project-layout</span><br>early-project-layout<br>└── exe-layout/<br>    ├── cmd/<br>    │   ├── app1/<br>    │   └── app2/<br>    ├── go.mod<br>    ├── internal/<br>    │   ├── pkga/<br>    │   └── pkgb/<br>    ├── pkg/<br>    │   ├── pkg1/<br>    │   └── pkg2/<br>    └── vendor/<br></code></pre></td></tr></table></figure><p>原本放在项目顶层目录下的 pkg1 和 pkg2 公共包被统一聚合到 pkg 目录下了。而且，这种早期 Go 可执行程序项目的典型布局在 Go 社区内部也不乏受众，很多新建的 Go 项目依然采用这样的项目布局。</p><h3 id="Go-库项目的典型结构布局"><a href="#Go-库项目的典型结构布局" class="headerlink" title="Go 库项目的典型结构布局"></a>Go 库项目的典型结构布局</h3><p>Go 库项目仅对外暴露 Go 包，这类项目的典型布局形式是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -F lib-layout</span> <br>lib-layout<br>├── go.mod<br>├── internal/<br>│   ├── pkga/<br>│   │   └── pkg_a.go<br>│   └── pkgb/<br>│       └── pkg_b.go<br>├── pkg1/<br>│   └── pkg1.go<br>└── pkg2/<br>    └── pkg2.go<br></code></pre></td></tr></table></figure><p>库类型项目相比于 Go 可执行程序项目的布局要简单一些。因为这类项目不需要构建可执行程序，所以去除了 cmd 目录。<br>而且，在这里，vendor 也不再是可选目录了。对于库类型项目而言，我们并不推荐在项目中放置 vendor 目录去缓存库自身的第三方依赖，库项目仅通过 go. mod 文件明确表述出该项目依赖的 module 或包以及版本要求就可以了。<br>Go 库项目的初衷是为了对外部（开源或组织内部公开）暴露 API，对于仅限项目内部使用而不想暴露到外部的包，可以放在项目顶层的 internal 目录下面。当然 internal 也可以有多个并存在于项目结构中的任一目录层级中，关键是项目结构设计人员要明确各级 internal 包的应用层次和范围。</p><p>对于有一个且仅有一个包的 Go 库项目来说，可以将上面的布局做进一步简化，简化的布局如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">tree -L 1 -F single-pkg-lib-layout</span><br>single-pkg-lib-layout<br>├── feature1. go<br>├── feature2. go<br>├── go.mod<br>└── internal/<br></code></pre></td></tr></table></figure><p>简化后，我们将这唯一包的所有源文件放置在项目的顶层目录下（比如上面的 feature1. go 和 feature2. go），其他布局元素位置和功用不变。</p><h2 id="Go-程序执行次序"><a href="#Go-程序执行次序" class="headerlink" title="Go 程序执行次序"></a>Go 程序执行次序</h2><p>在一个 go 文件内，按照“常量 -&gt; 变量 -&gt; init 函数-&gt; main 函数”的顺序进行初始化。<br>如果有其他包的话，就是“其他 pkg 包-&gt; 常量 -&gt; 变量 -&gt; init 函数-&gt; main 函数”。</p><h3 id="main-main-函数：Go-应用的入口函数"><a href="#main-main-函数：Go-应用的入口函数" class="headerlink" title="main. main 函数：Go 应用的入口函数"></a>main. main 函数：Go 应用的入口函数</h3><p>Go 语言中有一个特殊的函数：main 包中的 main 函数，也就是 main. main，它是所有 Go 可执行程序的用户层执行逻辑的入口函数。Go 程序在用户层面的执行逻辑，会在这个函数内按照它的调用顺序展开。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 用户层执行逻辑</span><br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>可执行程序的 main 包必须定义 main 函数，否则 Go 编译器会报错。在启动了多个 Goroutine（Go 语言的轻量级用户线程）的 Go 应用中，main. main 函数将在 Go 应用的主 Goroutine 中执行。<br>在多 Goroutine 的 Go 应用中，相较于 main. main 作为 Go 应用的入口，main. main 函数返回的意义其实更大，因为 main 函数返回就意味着整个 Go 程序的终结，而且你也不用管这个时候是否还有其他子 Goroutine 正在执行。<br>除了 main 包外，<strong>其他包也可以拥有自己的名为 main 的函数或方法</strong>。但按照 Go 的可见性规则（小写字母开头的标识符为非导出标识符），非 main 包中自定义的 main 函数仅限于包内使用。</p><h3 id="init-函数：Go-包的初始化函数"><a href="#init-函数：Go-包的初始化函数" class="headerlink" title="init 函数：Go 包的初始化函数"></a>init 函数：Go 包的初始化函数</h3><p>init 函数：进行包的初始化。<br>和 main. main 函数一样，init 函数也是一个无参数无返回值的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 包初始化逻辑</span><br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>main 函数不一定是用户层第一个被执行的函数，因为，如果 main 包依赖的包中定义了 init 函数，或者是 main 包自身定义了 init 函数，那么 Go 程序在这个包初始化的时候，就会自动调用它的 init 函数，因此这些 init 函数的执行就都会发生在 main 函数之前。<br>并且在 Go 程序中我们不能手工显式地调用 init，否则就会收到编译错误，init 函数会在运行时自动执行。<br>Go 包可以拥有不止一个 init 函数，每个组成 Go 包的 Go 源文件中，也可以定义多个 init 函数。<br>在初始化 Go 包时，Go 会按照一定的次序，逐一、顺序地调用这个包的 init 函数。一般来说，先传递给 Go 编译器的源文件中的 init 函数，会先被执行；而同一个源文件中的多个 init 函数，会按声明顺序依次执行。当我们要在 main. main 函数执行之前，执行一些函数或语句的时候，我们只需要将它放入 init 函数中就可以了。</p><h3 id="Go-包的初始化次序"><a href="#Go-包的初始化次序" class="headerlink" title="Go 包的初始化次序"></a>Go 包的初始化次序</h3><p>Go 包是程序逻辑封装的基本单元，每个包都可以理解为是一个“自治”的、封装良好的、对外部暴露有限接口的基本单元。一个 Go 程序就是由一组包组成的，程序的初始化就是这些包的初始化。每个 Go 包还会有自己的依赖包、常量、变量、init 函数（其中 main 包有 main 函数）等。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230209214825.png]]<br>上图程序的初始化步骤：<br>首先，main 包依赖 pkg1 和 pkg4 两个包，所以第一步，<strong>Go 会根据包导入的顺序</strong>，先去初始化 main 包的第一个依赖包 pkg1。<br>第二步，Go 在进行包初始化的过程中，会采用“深度优先”的原则，递归初始化各个包的依赖包。在上图里，pkg1 包依赖 pkg2 包，pkg2 包依赖 pkg3 包，pkg3 没有依赖包，于是 Go 在 pkg3 包中按照“常量 -&gt; 变量 -&gt; init 函数”的顺序先对 pkg3 包进行初始化；<br>在 pkg3 包初始化完毕后，Go 会回到 pkg2 包并对 pkg2 包进行初始化，接下来再回到 pkg1 包并对 pkg1 包进行初始化。在调用完 pkg1 包的 init 函数后，Go 就完成了 main 包的第一个依赖包 pkg1 的初始化。<br>接下来，Go 会初始化 main 包的第二个依赖包 pkg4，pkg4 包的初始化过程与 pkg1 包类似，也是先初始化它的依赖包 pkg5，然后再初始化自身；<br>然后，当 Go 初始化完 pkg4 包后也就完成了对 main 包所有依赖包的初始化，接下来初始化 main 包自身。<br>最后，在 main 包中，Go 同样会按照“常量 -&gt; 变量 -&gt; init 函数”的顺序进行初始化，执行完这些初始化工作后才正式进入程序的入口函数 main 函数。</p><p>另外一个例子：</p><ul><li>main 包依赖 pkg1 包和 pkg2 包；</li><li>pkg1 包和 pkg2 包都依赖 pkg3 包。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">go run main.go</span><br>//首先初始化最深层的pkg3 包<br>pkg3: const c has been initialized  //初始化常量<br>pkg3: var v has been initialized    //初始化变量<br>pkg3: init func invoked             //初始化init函数<br>//然后按顺序依次初始化 pkg1 包和 pkg2 包<br>pkg1: const c has been initialized  //初始化常量<br>pkg1: var v has been initialized<br>pkg1: init func invoked<br>pkg2: const c has been initialized<br>pkg2: var v has been initialized<br>pkg2: init func invoked<br>//然后开始初始化这个程序<br>main: const c1 has been initialized<br>main: const c2 has been initialized<br>main: var v1 has been initialized<br>main: var v2 has been initialized<br>main: first init func invoked<br>main: second init func invoked<br></code></pre></td></tr></table></figure><p>pkg1 包和 pkg2 包都依赖 pkg3 包，但根据 Go 语言规范，<strong>一个被多个包依赖的包仅会初化一次</strong>，因此这里的 pkg3 包仅会被初始化了一次。</p><p>同一个包内有多个源文件的话，go 会先按文件传入顺序，分别初始化常量与变量，然后在分别调用各个文件中的 init 函数。比如说如果一个 pkg1 有两个文件 file1. go 和 file2. go，那么初始化顺序是：file1 中的常量 -&gt; file1 中的变量 -&gt; file2 中常量 -&gt; file2 中变量 -&gt; file1 中 init 函数 -&gt; file2 中 init 函数。</p><p>&#x3D;&#x3D;<strong>简而言之，就这三点：</strong>&#x3D;&#x3D;</p><ul><li>依赖包按“深度优先”的次序进行初始化；</li><li>每个包内按以“包级常量 -&gt; 包级变量 -&gt; init 函数”的顺序进行初始化；</li><li>包内的多个 init 函数按出现次序进行自动调用。</li><li></li></ul><h3 id="init-函数的用途"><a href="#init-函数的用途" class="headerlink" title="init 函数的用途"></a>init 函数的用途</h3><p>Go 包初始化时，init 函数的初始化次序在变量之后，这给了开发人员在 init 函数中对包级变量进行进一步检查与操作的机会。</p><h4 id="常用用途-1：重置包级变量值"><a href="#常用用途-1：重置包级变量值" class="headerlink" title="常用用途 1：重置包级变量值"></a>常用用途 1：重置包级变量值</h4><p>init 函数就好比 Go 包真正投入使用之前唯一的“质检员”，负责对包内部以及暴露到外部的包级数据（主要是包级变量）的初始状态进行检查。<br>？这部分不是太明白</p><h4 id="常用用途-2：实现对包级变量的复杂初始化"><a href="#常用用途-2：实现对包级变量的复杂初始化" class="headerlink" title="常用用途 2：实现对包级变量的复杂初始化"></a>常用用途 2：实现对包级变量的复杂初始化</h4><p>有些包级变量需要一个比较复杂的初始化过程，有些时候，使用它的类型零值（每个 Go 类型都具有一个零值定义）或通过简单初始化表达式不能满足业务逻辑要求，而 init 函数则非常适合完成此项工作，标准库 http 包中就有这样一个典型示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    http2VerboseLogs    <span class="hljs-type">bool</span> <span class="hljs-comment">// 初始化时默认值为false</span><br>    http2logFrameWrites <span class="hljs-type">bool</span> <span class="hljs-comment">// 初始化时默认值为false</span><br>    http2logFrameReads  <span class="hljs-type">bool</span> <span class="hljs-comment">// 初始化时默认值为false</span><br>    http2inTests        <span class="hljs-type">bool</span> <span class="hljs-comment">// 初始化时默认值为false</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    e := os.Getenv(<span class="hljs-string">&quot;GODEBUG&quot;</span>)<br>    <span class="hljs-keyword">if</span> strings.Contains(e, <span class="hljs-string">&quot;http2debug=1&quot;</span>) &#123;<br>        http2VerboseLogs = <span class="hljs-literal">true</span> <span class="hljs-comment">//在init中对http2VerboseLogs的值进行重置</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> strings.Contains(e, <span class="hljs-string">&quot;http2debug=2&quot;</span>) &#123;<br>        http2VerboseLogs = <span class="hljs-literal">true</span> <span class="hljs-comment">//在init中对http2VerboseLogs的值进行重置</span><br>        http2logFrameWrites = <span class="hljs-literal">true</span> <span class="hljs-comment">//在 init 中对 http2logFrameWrites 的值进行重置</span><br>        http2logFrameReads = <span class="hljs-literal">true</span> <span class="hljs-comment">//在init中对http2logFrameReads的值进行重置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>标准库 http 包 (也就是上面这段代码) 定义了一系列布尔类型的特性开关变量，它们默认处于关闭状态（即值为 false），但我们可以通过 GODEBUG 环境变量的值，开启相关特性开关。<br>可是这样一来，简单地将这些变量初始化为类型零值，就不能满足要求了，所以 http 包在 init 函数中，就根据环境变量 GODEBUG 的值，对这些包级开关变量进行了复杂的初始化，从而保证了这些开关变量在 http 包完成初始化后，可以处于合理状态。</p><h4 id="常用用途-3-在-init-函数中实现“注册模式”"><a href="#常用用途-3-在-init-函数中实现“注册模式”" class="headerlink" title="常用用途 3 在 init 函数中实现“注册模式”"></a>常用用途 3 在 init 函数中实现“注册模式”</h4><p>注册器模式是一种基础常见的设计模式，它的主要意思是把多个类的实例注册到一个注册器类中去，然后需要哪个类，由这个注册器类统一调取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;image&quot;</span><br>    _ <span class="hljs-string">&quot;image/gif&quot;</span> <span class="hljs-comment">// 以空导入方式注入gif图片格式驱动</span><br>    _ <span class="hljs-string">&quot;image/jpeg&quot;</span> <span class="hljs-comment">// 以空导入方式注入jpeg图片格式驱动</span><br>    _ <span class="hljs-string">&quot;image/png&quot;</span> <span class="hljs-comment">// 以空导入方式注入png图片格式驱动</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 支持png, jpeg, gif</span><br>    width, height, err := imageSize(os.Args[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 获取传入的图片文件的宽与高</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;get image size error:&quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;image size: [%d, %d]\n&quot;</span>, width, height)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">imageSize</span><span class="hljs-params">(imageFile <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    f, _ := os.Open(imageFile) <span class="hljs-comment">// 打开图文文件</span><br>    <span class="hljs-keyword">defer</span> f.Close()<br><br>    img, _, err := image.Decode(f) <span class="hljs-comment">// 对文件进行解码，得到图片实例</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, err<br>    &#125;<br><br>    b := img.Bounds() <span class="hljs-comment">// 返回图片区域</span><br>    <span class="hljs-keyword">return</span> b.Max.X, b.Max.Y, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个示例程序支持 png、jpeg、gif 三种格式的图片，而达成这一目标的原因，正是 image&#x2F;png、image&#x2F;jpeg 和 image&#x2F;gif 包都在各自的 init 函数中，将自己“注册”到 image 的支持格式列表中了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// $GOROOT/src/image/png/reader.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    image.RegisterFormat(<span class="hljs-string">&quot;png&quot;</span>, pngHeader, Decode, DecodeConfig)<br>&#125;<br><br><span class="hljs-comment">// $GOROOT/src/image/jpeg/reader.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    image.RegisterFormat(<span class="hljs-string">&quot;jpeg&quot;</span>, <span class="hljs-string">&quot;\xff\xd8&quot;</span>, Decode, DecodeConfig)<br>&#125;<br><br><span class="hljs-comment">// $GOROOT/src/image/gif/reader.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span> <span class="hljs-params">()</span></span> &#123;<br>    image.RegisterFormat(<span class="hljs-string">&quot;gif&quot;</span>, <span class="hljs-string">&quot;GIF8?a&quot;</span>, Decode, DecodeConfig)<br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="当-init-函数在检查包数据初始状态时遇到失败或错误的情况，我们该如何处理呢？"><a href="#当-init-函数在检查包数据初始状态时遇到失败或错误的情况，我们该如何处理呢？" class="headerlink" title="当 init 函数在检查包数据初始状态时遇到失败或错误的情况，我们该如何处理呢？"></a>当 init 函数在检查包数据初始状态时遇到失败或错误的情况，我们该如何处理呢？</h3><p>要分情况而定</p><ol><li>初始化失败的是必要的数据 panic 处理 结束进程 </li><li>初始化失败的是对业务没影响，可成功可失败的 输出 warn 或 error 日志 方便定位</li></ol><h2 id="Go-变量声明"><a href="#Go-变量声明" class="headerlink" title="Go 变量声明"></a>Go 变量声明</h2><p>在编程语言中，为了方便操作内存特定位置的数据，我们用一个特定的名字与位于特定位置的内存块绑定在一起，这个名字被称为<strong>变量</strong>。而变量所绑定的内存区域是要有一个<strong>明确的边界</strong>的。</p><p><font color=" #9bbb59 ">编程语言的编译器或解释器是如何知道一个变量所能引用的内存区域边界呢？</font><br><strong>动态语言</strong>和<strong>静态语言</strong>有不同的处理方式。<br>动态语言（比如 Python、Ruby 等）的解释器可以在运行时通过对变量赋值的分析，自动确定变量的边界。并且在动态语言中，一个变量可以在运行时被赋予大小不同的边界。<br>而静态编程语言在这方面的“体验略差”。静态类型语言编译器必须明确知道一个变量的边界才允许使用这个变量，但静态语言编译器又没能力自动提供这个信息，这个边界信息必须由这门语言的使用者提供，于是就有了“<strong>变量声明</strong>”。通过变量声明，语言使用者可以显式告知编译器一个变量的边界信息。在具体实现层面呢，这个边界信息由变量的<strong>类型属性</strong>赋予。<br>作为身处静态编程语言阵营的 Go 语言，它沿袭了静态语言的这一要求：使用变量之前需要先进行变量声明。<br>也就是对于静态语言，用户想要使用一个变量，需要使用<strong>变量声明</strong>来告知编译器变量所能引用的内存区域边界，而变量的边界信息又是由<strong>类型属性</strong>提供。</p><h3 id="Go-语言的变量声明方法"><a href="#Go-语言的变量声明方法" class="headerlink" title="Go 语言的变量声明方法"></a>Go 语言的变量声明方法</h3><p>![[【Go基础】未整理合集&#x2F;Pasted image 20230210131449.png|800]]<br>这个变量声明分为四个部分：</p><ul><li>var 是修饰变量声明的关键字；</li><li>a 为变量名；</li><li>int 为该变量的类型；</li><li>10 是变量的初值。<br>在 Go 语言中，无论什么类型的变量，都可以使用这种形式进行变量声明。如果没有显式的为变量赋予初值，<strong>Go 编译器会自动为变量赋予这个类型的零值，也就是这个类型的默认值</strong>。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230210131732.png]]<br>另外，像数组、结构体这样复合类型变量的零值就是它们组成元素都为零值时的结果。</li></ul><p>Go 语言还提供了变量声明块（block）的语法形式，可以用一个 var 关键字将多个变量声明放在一起:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    a <span class="hljs-type">int</span> = <span class="hljs-number">128</span><br>    b <span class="hljs-type">int8</span> = <span class="hljs-number">6</span><br>    s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello&quot;</span><br>    c <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;A&#x27;</span><br>    t <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br>)<br></code></pre></td></tr></table></figure><p>Go 语言还支持在一行变量声明中同时声明多个变量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b, c <span class="hljs-type">int</span> = <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>上面两种声明方式也可以组合到一起</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    a, b, c <span class="hljs-type">int</span> = <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span><br>    c, d, e <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span><br>) <br></code></pre></td></tr></table></figure><h3 id="Go-的两种变量声明语法糖"><a href="#Go-的两种变量声明语法糖" class="headerlink" title="Go 的两种变量声明语法糖"></a>Go 的两种变量声明语法糖</h3><h4 id="1-省略类型信息的声明"><a href="#1-省略类型信息的声明" class="headerlink" title="1. 省略类型信息的声明"></a>1. 省略类型信息的声明</h4><p>在通用的变量声明的基础上，Go 编译器允许我们省略变量声明中的类型信息，它的标准范式是<br>“<strong>var varName &#x3D; initExpression</strong>”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = <span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><p><strong>Go 编译器在遇到这样的变量声明后是如何确定变量的类型信息呢？</strong><br>Go 编译器会根据右侧变量初值自动推导出变量的类型，并给这个变量赋予初值所对应的默认类型。比如，整型值的默认类型 int，浮点值的默认类型为 float64，复数值的默认类型为 complex128，布尔值的默认类型只能是 bool，字符值默认类型只能是 rune，字符串值的默认类型只能是 string 等。<br>这种省略类型信息声明的“语法糖”<strong>仅适用于在变量声明的同时显式赋予变量初值的情况</strong>，下面这种没有初值的声明形式是不被允许的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b<br></code></pre></td></tr></table></figure><p>结合多变量声明，我们可以使用这种变量声明“语法糖”声明多个不同类型的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b, c = <span class="hljs-number">12</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>在这个变量声明中，我们声明了三个变量 a、b 和 c，但它们分别具有不同的类型，分别为 int、rune 和 string。</p><p>如果我们不接受默认类型，而是要显式地为变量指定类型，除了通用的声明形式，我们还可以通过显式类型转型达到我们的目的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = <span class="hljs-type">int32</span>(<span class="hljs-number">13</span>) <span class="hljs-comment">//但是这种方式和正常的变量声明就区别不大了</span><br></code></pre></td></tr></table></figure><h4 id="2-短变量声明"><a href="#2-短变量声明" class="headerlink" title="2. 短变量声明"></a>2. 短变量声明</h4><p>Go 语言还为我们提供了最简化的变量声明形式：短变量声明。可以省去 var 关键字以及类型信息，它的标准范式是“<strong>varName :&#x3D; initExpression</strong>”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">12</span><br>b := <span class="hljs-string">&#x27;A&#x27;</span><br>c := <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>短变量声明也支持一次声明多个变量，而且形式更为简洁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a, b, c := <span class="hljs-number">12</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>但是，并不是所有变量都能用短变量声明来声明的。</p><h3 id="如何使用声明（何时用何种声明）"><a href="#如何使用声明（何时用何种声明）" class="headerlink" title="如何使用声明（何时用何种声明）"></a>如何使用声明（何时用何种声明）</h3><p><strong>Go 语言的两类变量</strong>：包级变量和局部变量</p><h4 id="包级变量-package-varible"><a href="#包级变量-package-varible" class="headerlink" title="包级变量 (package varible)"></a>包级变量 (package varible)</h4><p>在包级别可见的变量。如果是导出变量（大写字母开头），那么这个包级变量也可以被视为全局变量。</p><h5 id="包级变量的声明形式"><a href="#包级变量的声明形式" class="headerlink" title="包级变量的声明形式"></a>包级变量的声明形式</h5><p>包级变量只能使用带有 var 关键字的变量声明形式，<strong>不能使用短变量声明形式</strong>，但在形式细节上可以有一定灵活度。而这个灵活度从“<strong>变量声明时是否延迟初始化</strong>”这个角度来考虑。</p><h6 id="第一类：声明并同时显式初始化"><a href="#第一类：声明并同时显式初始化" class="headerlink" title="第一类：声明并同时显式初始化"></a>第一类：声明并同时显式初始化</h6><p>如果能够接受默认的类型，多使用省略类型信息的声明方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> varName = initExpression<br></code></pre></td></tr></table></figure><p>而如果不接受默认类型，则要显式地为包级变量指定类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//第一种：</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">13</span> <span class="hljs-comment">// 使用默认类型</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int32</span> = <span class="hljs-number">17</span>  <span class="hljs-comment">// 显式指定类型</span><br><span class="hljs-keyword">var</span> f <span class="hljs-type">float32</span> = <span class="hljs-number">3.14</span> <span class="hljs-comment">// 显式指定类型</span><br><br><span class="hljs-comment">//第二种：</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">13</span> <span class="hljs-comment">// 使用默认类型</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-type">int32</span>(<span class="hljs-number">17</span>) <span class="hljs-comment">// 显式指定类型</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-type">float32</span> (<span class="hljs-number">3.14</span>) <span class="hljs-comment">// 显式指定类型</span><br></code></pre></td></tr></table></figure><p>Go 更推荐我们使用第二种，这样能统一接受默认类型和显式指定类型这两种声明形式，方便浏览。</p><h6 id="第二类：声明但延迟初始化"><a href="#第二类：声明但延迟初始化" class="headerlink" title="第二类：声明但延迟初始化"></a>第二类：声明但延迟初始化</h6><p>对于声明时并不立即显式初始化的包级变量，使用通用变量声明形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span><br><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span><br></code></pre></td></tr></table></figure><h5 id="声明的聚类与就近原则"><a href="#声明的聚类与就近原则" class="headerlink" title="声明的聚类与就近原则"></a>声明的聚类与就近原则</h5><h6 id="聚类原则"><a href="#聚类原则" class="headerlink" title="聚类原则"></a>聚类原则</h6><p>声明聚类可以提升代码可读性。<br>将同一类的变量声明放在一个 var 变量声明块中，不同类的声明放在不同的 var 声明块中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net. go</span><br><span class="hljs-keyword">var</span> (<br>    netGo  <span class="hljs-type">bool</span> <br>    netCgo <span class="hljs-type">bool</span> <br>)<br><br><span class="hljs-keyword">var</span> (<br>    aLongTimeAgo = time.Unix(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>    noDeadline = time.Time&#123;&#125;<br>    noCancel   = (<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)(<span class="hljs-literal">nil</span>)<br>)<br></code></pre></td></tr></table></figure><p>将延迟初始化的变量声明放在一个 var 声明块 (比如上面的第一个 var 声明块)，然后将声明且显式初始化的变量放在另一个 var 块中（比如上面的第二个 var 声明块）</p><h6 id="就近原则"><a href="#就近原则" class="headerlink" title="就近原则"></a>就近原则</h6><p>就近原则是对变量的作用域最小化的一种实现手段。<br>尽可能在靠近第一次使用变量的位置声明这个变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/request.go</span><br><br><span class="hljs-keyword">var</span> ErrNoCookie = errors.New(<span class="hljs-string">&quot;http: named cookie not present&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Request)</span></span> Cookie(name <span class="hljs-type">string</span>) (*Cookie, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> readCookies(r.Header, name) &#123;<br>        <span class="hljs-keyword">return</span> c, <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrNoCookie<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码块，ErrNoCookie 这个变量在整个包中仅仅被用在了 Cookie 方法中，因此它被声明在紧邻 Cookie 方法定义的地方。当然了，<strong>如果一个包级变量在包内部被多处使用，那么这个变量还是放在源文件头部声明比较适合</strong>的。</p><h4 id="局部变量-local-varible"><a href="#局部变量-local-varible" class="headerlink" title="局部变量 (local varible)"></a>局部变量 (local varible)</h4><p>Go 函数或方法体内声明的变量，仅在函数或方法体内可见。</p><h5 id="局部变量的声明形式"><a href="#局部变量的声明形式" class="headerlink" title="局部变量的声明形式"></a>局部变量的声明形式</h5><p>和包级变量相比，局部变量又多了一种<strong>短变量声明</strong>形式，这是局部变量特有的一种变量声明形式，也是局部变量采用最多的一种声明形式。</p><h6 id="第一类：对于延迟初始化的局部变量声明，我们采用通用的变量声明形式"><a href="#第一类：对于延迟初始化的局部变量声明，我们采用通用的变量声明形式" class="headerlink" title="第一类：对于延迟初始化的局部变量声明，我们采用通用的变量声明形式"></a>第一类：对于延迟初始化的局部变量声明，我们采用通用的变量声明形式</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><h6 id="第二类：对于声明且显式初始化的局部变量，建议使用短变量声明形式"><a href="#第二类：对于声明且显式初始化的局部变量，建议使用短变量声明形式" class="headerlink" title="第二类：对于声明且显式初始化的局部变量，建议使用短变量声明形式"></a>第二类：对于声明且显式初始化的局部变量，建议使用短变量声明形式</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">17</span><br>f := <span class="hljs-number">3.14</span><br>s := <span class="hljs-string">&quot;hello, gopher!&quot;</span><br></code></pre></td></tr></table></figure><p>对于不接受默认类型的变量，我们依然可以使用短变量声明形式，只是在”:&#x3D;”右侧要做一个显式转型，以保持声明的一致性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-type">int32</span>(<span class="hljs-number">17</span>)<br>f := <span class="hljs-type">float32</span>(<span class="hljs-number">3.14</span>)<br>s := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;hello, gopher!&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>注意：尽量在分支控制时使用短变量声明形式，让变量的作用域最小化。</strong></p><p>虽然良好的函数 &#x2F; 方法设计都讲究“单一职责”，所以每个函数 &#x2F; 方法规模都不大，很少需要应用 var 块来聚类声明局部变量，但是如果你在声明局部变量时遇到了适合聚类的应用场景，也应该毫不犹豫地使用 var 声明块来声明多于一个的局部变量。</p><p><font color=" #76923c ">Go 语言的变量声明形式与其他主流静态语言有一个显著的差异，那就是它将变量名放在了类型的前面。这样做有什么好处呢？</font><br>为了提高代码可读性，和 C 相比，在当参数是指针的复杂情况下，这种声明格式会相对好理解一点，方便辨析指针类型。<br><a href="https://go.dev/blog/declaration-syntax">Go’s Declaration Syntax - The Go Programming Language</a></p><h2 id="代码块与作用域"><a href="#代码块与作用域" class="headerlink" title="代码块与作用域"></a>代码块与作用域</h2><p>变量遮蔽（Variable Shadowing）是 Go 开发人员在日常开发工作中最容易犯的编码错误之一，它低级又不容易查找，常常会让你陷入漫长的调试过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//变量遮蔽的例子</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">11</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>  a := <span class="hljs-number">1</span><br>  a += n<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;a =&quot;</span>, a) <span class="hljs-comment">// 11</span><br>  foo(<span class="hljs-number">5</span>)<br>  fmt.Println(<span class="hljs-string">&quot;after calling foo, a =&quot;</span>, a) <span class="hljs-comment">// 11</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，函数 foo 调用前后，包级变量 a 的值都没有发生变化。这是因为，虽然 foo 函数中也使用了变量 a，但是 foo 函数中的变量 a 遮蔽了外面的包级变量 a，这使得包级变量 a 没有参与到 foo 函数的逻辑中，所以就没有发生变化了。</p><p>暂时放到一边。</p><h2 id="Go-基本数据类型"><a href="#Go-基本数据类型" class="headerlink" title="Go 基本数据类型"></a>Go 基本数据类型</h2><p>Go 语言的类型大体可分为基本数据类型、复合数据类型和接口类型这三种。</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>可以分为平台无关整型和平台相关整型这两种，它们的区别主要就在，这些整数类型在不同 CPU 架构或操作系统下面，它们的长度是否是一致的。</p><h4 id="平台无关整型"><a href="#平台无关整型" class="headerlink" title="平台无关整型"></a>平台无关整型</h4><p>下面是平台无关整型：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230211152317.png]]<br>这些平台无关的整型也可以分成两类：有符号整型（int8<del>int64）和无符号整型（uint8</del>uint64）。两者的本质差别在于最高二进制位（bit 位）是否被解释为符号位，这点会影响到无符号整型与有符号整型的取值范围。<br>以下图中的这个 8 比特（一个字节）的整型值为例，当它被解释为无符号整型 uint8 时，和它被解释为有符号整型 int8 时表示的值是不同的：</p><p>![[【Go基础】未整理合集&#x2F;Pasted image 20230211152534.png]]<br>为什么上图中 int8 对应的是-127 而不是-1? 这是因为 Go 采用 2 的补码（Two’s Complement）作为整型的比特位编码方法。它是通过原码逐位取反后再加 1 得到的。<br>-127 得到的过程如下：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230211153258.png]]</p><h4 id="平台相关整型"><a href="#平台相关整型" class="headerlink" title="平台相关整型"></a>平台相关整型</h4><p>Go 语言原生提供了三个平台相关整型，它们是 int、uint 与 uintptr。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230211152734.png]]<br>由于这三个类型的长度是平台相关的，所以我们在编写有移植性要求的代码时，千万不要强依赖这些类型的长度。<br>如果不知道这三个类型在目标运行平台上的长度，可以通过 unsafe 包提供的 SizeOf 函数来获取，比如在 x86-64 平台上，它们的长度均为 8：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b = <span class="hljs-type">int</span>(<span class="hljs-number">5</span>), <span class="hljs-type">uint</span>(<span class="hljs-number">6</span>)<br><span class="hljs-keyword">var</span> p <span class="hljs-type">uintptr</span> = <span class="hljs-number">0x12345678</span><br>fmt.Println(<span class="hljs-string">&quot;signed integer a&#x27;s length is&quot;</span>, unsafe.Sizeof(a)) <span class="hljs-comment">// 8</span><br>fmt.Println(<span class="hljs-string">&quot;unsigned integer b&#x27;s length is&quot;</span>, unsafe.Sizeof(b)) <span class="hljs-comment">// 8</span><br>fmt.Println(<span class="hljs-string">&quot;uintptr&#x27;s length is&quot;</span>, unsafe.Sizeof(p)) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><h4 id="整型的溢出问题"><a href="#整型的溢出问题" class="headerlink" title="整型的溢出问题"></a>整型的溢出问题</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">int8</span> = <span class="hljs-number">127</span><br>s += <span class="hljs-number">1</span> <span class="hljs-comment">// 预期128，实际结果-128</span><br><br><span class="hljs-keyword">var</span> u <span class="hljs-type">uint8</span> = <span class="hljs-number">1</span><br>u -= <span class="hljs-number">2</span> <span class="hljs-comment">// 预期-1，实际结果255</span><br></code></pre></td></tr></table></figure><p>解决方法：记住使用的整数类型的取值范围。</p><h4 id="字面值与格式化输出"><a href="#字面值与格式化输出" class="headerlink" title="字面值与格式化输出"></a>字面值与格式化输出</h4><p>Go 语言继承了 C 语言关于数值字面值（Number Literal）的语法形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">53</span>        <span class="hljs-comment">// 十进制</span><br>b := <span class="hljs-number">0700</span>      <span class="hljs-comment">// 八进制，以&quot;0&quot;为前缀</span><br>c1 := <span class="hljs-number">0xaabbcc</span> <span class="hljs-comment">// 十六进制，以&quot;0x&quot;为前缀</span><br>c2 := <span class="hljs-number">0Xddeeff</span> <span class="hljs-comment">// 十六进制，以&quot;0X&quot;为前缀</span><br><span class="hljs-comment">//go 1.13版本后增加对二进制字面值的支持和两种八进制字面值的形式</span><br>d1 := <span class="hljs-number">0</span>b10000001 <span class="hljs-comment">// 二进制，以&quot;0b&quot;为前缀</span><br>d2 := <span class="hljs-number">0</span>B10000001 <span class="hljs-comment">// 二进制，以&quot;0B&quot;为前缀</span><br>e1 := <span class="hljs-number">0o700</span>      <span class="hljs-comment">// 八进制，以&quot;0o&quot;为前缀</span><br>e2 := <span class="hljs-number">0O700</span>      <span class="hljs-comment">// 八进制，以&quot;0O&quot;为前缀</span><br><span class="hljs-comment">//还增加了在字面值中增加数字分隔符“_”,用来将数字分组以提高可读性</span><br>a := <span class="hljs-number">5_3_7</span>   <span class="hljs-comment">// 十进制: 537</span><br>b := <span class="hljs-number">0</span>b_1000_0111  <span class="hljs-comment">// 二进制位表示为10000111 </span><br>c1 := <span class="hljs-number">0_700</span>  <span class="hljs-comment">// 八进制: 0700</span><br>c2 := <span class="hljs-number">0o_700</span> <span class="hljs-comment">// 八进制: 0700</span><br>d1 := <span class="hljs-number">0x_5c_6d</span> <span class="hljs-comment">// 十六进制：0x5c6d</span><br></code></pre></td></tr></table></figure><p>Go 语言整数类型使用 fmt 标准化输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">59</span><br>fmt.Printf(<span class="hljs-string">&quot;%b\n&quot;</span>, a) <span class="hljs-comment">//输出二进制：111011</span><br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, a) <span class="hljs-comment">//输出十进制：59</span><br>fmt.Printf(<span class="hljs-string">&quot;%o\n&quot;</span>, a) <span class="hljs-comment">//输出八进制：73</span><br>fmt.Printf(<span class="hljs-string">&quot;%O\n&quot;</span>, a) <span class="hljs-comment">//输出八进制(带0o前缀)：0o73</span><br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, a) <span class="hljs-comment">//输出十六进制(小写)：3b</span><br>fmt.Printf(<span class="hljs-string">&quot;%X\n&quot;</span>, a) <span class="hljs-comment">//输出十六进制(大写)：3B</span><br></code></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>和使用广泛的整型相比，浮点型的使用场景就相对聚焦了，主要集中在科学数值计算、图形图像处理和仿真、多媒体游戏以及人工智能等领域。<br><strong>注意：Go 提供的浮点类型都是平台无关的。</strong><br>它只提供了 float32 与 float64 两种浮点类型，它们分别对应的就是 IEEE 754 中的单精度与双精度浮点数值类型。Go 语言中没有提供 float 类型。这不像整型那样，Go 既提供了 int16、int32 等类型，又有 int 类型。<br><font color=" #8064a2 ">（跳过一部分关于 IEEE 浮点数标准的知识）</font><br>因为双精度浮点类型（float64）阶码与尾数使用的比特位数更多，它可以表示的精度要远超单精度浮点类型，所以在日常开发中，我们使用双精度浮点类型（float64）的情况更多，这也是 Go 语言中浮点常量或字面值的默认类型。<br>而 float32 由于表示范围与精度有限，经常会给开发者造成一些困扰。比如我们可能会因为 float32 精度不足，导致输出结果与常识不符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f1 <span class="hljs-type">float32</span> = <span class="hljs-number">16777216.0</span><br><span class="hljs-keyword">var</span> f2 <span class="hljs-type">float32</span> = <span class="hljs-number">16777217.0</span><br>fmt.Println(f1 == f2) <span class="hljs-comment">// true</span><br><span class="hljs-comment">//f1 与 f2 两个浮点类型变量被两个不同的浮点字面值初始化，但逻辑比较的结果却是两个变量的值相等。</span><br></code></pre></td></tr></table></figure><p><strong>上面 f1, f2 为什么相等？</strong><br>f1 转换成二进制是：1266679808<br>f2 转换成二进制也是：1266679808<br>是因为转换成二进制的数据是相等的。</p><h4 id="字面值与格式化输出-1"><a href="#字面值与格式化输出-1" class="headerlink" title="字面值与格式化输出"></a>字面值与格式化输出</h4><p>Go 浮点类型字面值大体可分为两类，一类是直白地用十进制表示的浮点值形式。这一类，我们通过字面值就可直接确定它的浮点值，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">3.1415</span><br><span class="hljs-number">.15</span>  <span class="hljs-comment">// 整数部分如果为0，整数部分可以省略不写</span><br><span class="hljs-number">81.80</span><br><span class="hljs-number">82.</span> <span class="hljs-comment">// 小数部分如果为0，小数点后的0可以省略不写</span><br></code></pre></td></tr></table></figure><p>另一类则是科学计数法形式。采用科学计数法表示的浮点字面值，我们需要通过一定的换算才能确定其浮点值。而且在这里，科学计数法形式又分为十进制形式表示的，和十六进制形式表示的两种。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//十进制科学计数法形式的浮点数字面值</span><br><span class="hljs-number">6674.28e-2</span> <span class="hljs-comment">// 6674.28 * 10^(-2) = 66.742800</span><br><span class="hljs-number">.12345E+5</span>  <span class="hljs-comment">// 0.12345 * 10^5 = 12345.000000</span><br><br><span class="hljs-comment">//十六进制科学计数法形式的浮点数</span><br><span class="hljs-number">0x2.p10</span>  <span class="hljs-comment">// 2.0 * 2^10 = 2048.000000</span><br><span class="hljs-number">0x1.Fp+0</span> <span class="hljs-comment">// 1.9375 * 2^0 = 1.937500</span><br><span class="hljs-comment">//注意，十六进制科学计数法的整数部分、小数部分用的都是十六进制形式，但指数部分依然是十进制形式，并且字面值中的 p/P 代表的幂运算的底数为 2。</span><br></code></pre></td></tr></table></figure><p>fmt 格式化输出浮点类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-number">123.45678</span><br>fmt.Printf(<span class="hljs-string">&quot;%f\n&quot;</span>, f) <span class="hljs-comment">// 123.456780</span><br><span class="hljs-comment">//科学计数法形式</span><br>fmt.Printf(<span class="hljs-string">&quot;%e\n&quot;</span>, f) <span class="hljs-comment">// 1.234568e+02</span><br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, f) <span class="hljs-comment">// 0x1.edd3be22e5de1p+06</span><br><span class="hljs-comment">//其中 %e 输出的是十进制的科学计数法形式，而 %x 输出的则是十六进制的科学计数法形式。</span><br></code></pre></td></tr></table></figure><h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><p>复数类型在 Go 中的应用就更为局限和小众，主要用于专业领域的计算，比如矢量计算等。<br>Go 提供两种复数类型，它们分别是 complex64 和 complex128，complex64 的实部与虚部都是 float32 类型，而 complex128 的实部与虚部都是 float64 类型。如果一个复数没有显示赋予类型，那么它的默认类型为 complex128。<br><strong>复数字面值的表示 (三种)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//第一种 通过复数字面值直接初始化一个复数类型变量</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-number">5</span> + <span class="hljs-number">6i</span><br><span class="hljs-keyword">var</span> d = <span class="hljs-number">0o123</span> + <span class="hljs-number">.12345E+5i</span> <span class="hljs-comment">// 83+12345i</span><br><br><span class="hljs-comment">//第二种，通过complex 函数</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">complex</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 5 + 6i</span><br><span class="hljs-keyword">var</span> d = <span class="hljs-built_in">complex</span>(<span class="hljs-number">0o123</span>, <span class="hljs-number">.12345E+5</span>) <span class="hljs-comment">// 83+12345i</span><br><br><span class="hljs-comment">//第三种 通过 Go 提供的预定义的函数 real 和 imag，来获取一个复数的实部与虚部，返回值为一个浮点类型</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">complex</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 5 + 6i</span><br>r := <span class="hljs-built_in">real</span>(c) <span class="hljs-comment">// 5.000000</span><br>i := <span class="hljs-built_in">imag</span>(c) <span class="hljs-comment">// 6.000000</span><br></code></pre></td></tr></table></figure><h3 id="创建自定义的数值类型"><a href="#创建自定义的数值类型" class="headerlink" title="创建自定义的数值类型"></a>创建自定义的数值类型</h3><p>通过 Go 提供的类型定义语法，可以使用 type 关键字基于原生数值类型来声明一个新类型。<br>但是自定义的数值类型，在和其他类型相互赋值时容易出现一些问题。<br>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义了一个MyInt类型。</span><br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int32</span><br></code></pre></td></tr></table></figure><p>虽然 MyInt 类型的底层类型是 int32，它的数值性质与 int32 完全相同，但它们仍然是完全不同的两种类型。根据 Go 的类型安全规则，我们无法直接让它们相互赋值，或者是把它们放在同一个运算中直接计算，这样编译器就会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-type">int</span> = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int32</span> = <span class="hljs-number">6</span><br><span class="hljs-keyword">var</span> a MyInt = m <span class="hljs-comment">// 错误：在赋值中不能将m（int类型）作为MyInt类型使用</span><br><span class="hljs-keyword">var</span> a MyInt = n <span class="hljs-comment">// 错误：在赋值中不能将n（int32类型）作为MyInt类型使用</span><br></code></pre></td></tr></table></figure><p>要避免这个错误，我们需要借助显式转型，让赋值操作符左右两边的操作数保持类型一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-type">int</span> = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int32</span> = <span class="hljs-number">6</span><br><span class="hljs-keyword">var</span> a MyInt = MyInt(m) <span class="hljs-comment">// ok</span><br><span class="hljs-keyword">var</span> a MyInt = MyInt(n) <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>可以集体声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>   T1 <span class="hljs-type">int</span><br>   T2 T1<br>   T3 <span class="hljs-type">string</span><br>)<br></code></pre></td></tr></table></figure><p><strong>也可以通过 Go 提供的类型别名（Type Alias）语法来自定义数值类型。</strong><br>和上面使用标准 type 语法的定义不同的是，通过类型别名语法定义的新类型与原类型别无二致，可以完全相互替代。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt = <span class="hljs-type">int32</span><br><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int32</span> = <span class="hljs-number">6</span><br><span class="hljs-keyword">var</span> a MyInt = n <span class="hljs-comment">// ok</span><br><br><span class="hljs-comment">//辨析：</span><br><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int32</span> <span class="hljs-comment">//新的类型，与int32不一样 </span><br><span class="hljs-keyword">type</span> myInt = <span class="hljs-type">int32</span> <span class="hljs-comment">// int32的别名，与int32一模一样</span><br></code></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>Go 不像 C 语言，Go 原生支持字符串类型。<br><strong>非原生字符串会造成的问题：</strong></p><ul><li>不是原生类型，编译器不会对它进行类型校验，导致类型安全性差；</li><li>字符串操作时要时刻考虑结尾的’\0’，防止缓冲区溢出；</li><li>以字符数组形式定义的“字符串”，</li><li>它的值是可变的，在并发场景中需要考虑同步问题；</li><li>获取一个字符串的长度代价较大，通常是 O (n) 时间复杂度；</li><li>C 语言没有内置对非 ASCII 字符（如中文字符）的支持。</li></ul><p>在 Go 中，字符串类型为 string。Go 语言通过 string 类型统一了对“字符串”的抽象。这样无论是字符串常量、字符串变量或是代码中出现的字符串字面值，它们的类型都被统一设置为 string，</p><h4 id="Go-原生支持-string-带来的好处"><a href="#Go-原生支持-string-带来的好处" class="headerlink" title="Go 原生支持 string 带来的好处"></a>Go 原生支持 string 带来的好处</h4><p><strong>第一点：string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率。</strong><br>Go 语言规定，字符串类型的值在它的生命周期内是不可改变的。<br>如果我们声明了一个字符串类型的变量，那我们是无法通过这个变量改变它对应的字符串值的，但这并不是说我们不能为一个字符串类型变量进行二次赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello&quot;</span><br>s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;k&#x27;</span>   <span class="hljs-comment">// 错误：字符串的内容是不可改变的</span><br>s = <span class="hljs-string">&quot;gopher&quot;</span> <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Go 这样的“字符串类型数据不可变”的性质给开发人员带来的最大好处，就是我们不用再担心字符串的并发安全问题。这样，Go 字符串可以被多个 Goroutine（Go 语言的轻量级用户线程，后面我们会详细讲解）共享，开发者不用因为担心并发安全问题，使用会带来一定开销的同步机制。<br>另外，也由于字符串的不可变性，针对同一个字符串值，无论它在程序的几个位置被使用，Go 编译器只需要为它分配一块存储就好了，大大提高了存储利用率。</p><p><strong>第二点：没有结尾’\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。</strong><br>Go 字符串中没有结尾’\0’，获取字符串长度更不需要结尾’\0’作为结束标志。并且，Go 获取字符串长度是一个常数级时间复杂度，无论字符串中字符个数有多少，我们都可以快速得到字符串的长度值。而 C 语言中的 strlen 函数是一个线性时间复杂度的算法。</p><p><strong>第三点：原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担。</strong><br>在 C 语言中构造多行字符串，一般就是两个方法：要么使用多个字符串的自然拼接，要么需要结合续行符””。而在 GO 中就简单多了，通过一对反引号原生支持构造“所见即所得”的原始字符串（Raw String）。而且，Go 语言原始字符串中的任意转义字符都不会起到转义的作用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">`         ,_---~~~~~----._</span><br><span class="hljs-string">    _,,_,*^____      _____*g*\&quot;*,--,</span><br><span class="hljs-string">   / __/ /&#x27;     ^.  /      \ ^@q   f</span><br><span class="hljs-string">  [  @f | @))    |  | @))   l  0 _/</span><br><span class="hljs-string">   \/   \~____ / __ \_____/     \</span><br><span class="hljs-string">    |           _l__l_           I</span><br><span class="hljs-string">    &#125;          [______]           I</span><br><span class="hljs-string">    ]            | | |            |</span><br><span class="hljs-string">    ]             ~ ~             |</span><br><span class="hljs-string">    |                            |</span><br><span class="hljs-string">     |                           |`</span><br>fmt.Println(s)<br></code></pre></td></tr></table></figure><p><strong>第四点：对非 ASCII 字符提供原生支持，消除了源码在不同环境下显示乱码的可能。</strong><br>Go 语言源文件默认采用的是 Unicode 字符集，Unicode 字符集是目前市面上最流行的字符集，它囊括了几乎所有主流非 ASCII 字符（包括中文字符）。Go 字符串中的每个字符都是一个 Unicode 字符，并且这些 Unicode 字符是以 UTF-8 编码格式存储在内存当中的。</p><h4 id="Go-字符串的组成"><a href="#Go-字符串的组成" class="headerlink" title="Go 字符串的组成"></a>Go 字符串的组成</h4><p>可以使用两个视角来看待 Go 字符串的组成，一种是字节视角。Go 字符串是由一个可空的字节序列组成，字节的个数称为字符串的长度；另外一种是字符视角。Go 字符串是由一个可空的字符序列构成。Go 字符串中的每个字符都是一个 Unicode 字符。</p><p>Go 语言中的字符串值也是一个可空的字节序列，字节序列中的字节个数称为该字符串的长度。一个个的字节只是孤立数据，不表意。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//字节视角</span><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;the length of s = %d\n&quot;</span>, <span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">// 9</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, s[i]) <span class="hljs-comment">// 0xe4 0xb8 0xad 0xe5 0x9b 0xbd 0xe4 0xba 0xba</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment">//字符视角</span><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;the character count in s is&quot;</span>, utf8.RuneCountInString(s)) <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, c) <span class="hljs-comment">// 0x4e2d 0x56fd 0x4eba</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><p>Go 采用的是 Unicode 字符集，每个字符都是一个 Unicode 字符，那么这里输出的 0x4e2d、0x56fd 和 0x4eba 就应该是某种 Unicode 字符的表示了。没错，以 0x4e2d 为例，它是汉字“中”在 Unicode 字符集表中的<strong>码点</strong>（Code Point）。</p><p>什么是 Unicode 码点呢？</p><p>Unicode 字符集中的每个字符，都被分配了统一且唯一的字符编号。所谓 Unicode 码点，就是指将 Unicode 字符集中的所有字符“排成一队”，字符在这个“队伍”中的位次，就是它在 Unicode 字符集中的码点。也就说，一个码点唯一对应一个字符。“码点”的概念和我们马上要讲的 rune 类型有很大关系。</p><h4 id="rune-类型与字符字面值"><a href="#rune-类型与字符字面值" class="headerlink" title="rune 类型与字符字面值"></a>rune 类型与字符字面值</h4><p>Go 使用 rune 这个类型来表示一个 Unicode 码点。rune 本质上是 int32 类型的别名类型，它与 int32 类型是完全等价的，在 Go 源码中我们可以看到它的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/builtin.go</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">rune</span> = <span class="hljs-type">int32</span><br></code></pre></td></tr></table></figure><p>一个 rune 实例就是一个 Unicode 字符，一个 Go 字符串也可以被视为 rune 实例的集合。我们可以通过字符字面值来初始化一个 rune 变量。(感觉 rune 和 char 有点像)</p><p>在 Go 中，字符字面值有多种表示法，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//最常见的是通过单引号括起的字符字面值</span><br><span class="hljs-string">&#x27;a&#x27;</span>  <span class="hljs-comment">// ASCII字符</span><br><span class="hljs-string">&#x27;中&#x27;</span> <span class="hljs-comment">// Unicode字符集中的中文字符</span><br><span class="hljs-string">&#x27;\n&#x27;</span> <span class="hljs-comment">// 换行字符</span><br><span class="hljs-string">&#x27;\&#x27;&#x27;</span> <span class="hljs-comment">// 单引号字符</span><br><br><span class="hljs-comment">//还可以使用 Unicode 专用的转义字符\u 或\U 作为前缀，来表示一个 Unicode 字符</span><br><span class="hljs-string">&#x27;\u4e2d&#x27;</span>     <span class="hljs-comment">// 字符：中</span><br><span class="hljs-string">&#x27;\U00004e2d&#x27;</span> <span class="hljs-comment">// 字符：中</span><br><span class="hljs-string">&#x27;\u0027&#x27;</span>     <span class="hljs-comment">// 单引号字符</span><br><span class="hljs-comment">//要注意，\u 后面接四个十六进制数。如果是用四个十六进制数无法表示的 Unicode 字符，我们可以使用\U，\U 后面可以接八个十六进制数来表示一个 Unicode 字符。</span><br><br><span class="hljs-comment">//由于表示码点的 rune 本质上就是一个整型数，所以我们还可用整型值来直接作为字符字面值给 rune 变量赋值</span><br><span class="hljs-string">&#x27;\x27&#x27;</span>  <span class="hljs-comment">// 使用十六进制表示的单引号字符</span><br><span class="hljs-string">&#x27;\047&#x27;</span>  <span class="hljs-comment">// 使用八进制表示的单引号字符</span><br></code></pre></td></tr></table></figure><h4 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h4><p>字符串是字符的集合，了解了字符字面值后，字符串的字面值也就很简单了。<br>将单个 Unicode 字符字面值一个接一个地连在一起，并用双引号包裹起来就构成了字符串字面值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">&quot;abc\n&quot;</span><br><span class="hljs-string">&quot;中国人&quot;</span><br><span class="hljs-string">&quot;\u4e2d\u56fd\u4eba&quot;</span> <span class="hljs-comment">// 中国人</span><br><span class="hljs-string">&quot;\U00004e2d\U000056fd\U00004eba&quot;</span> <span class="hljs-comment">// 中国人</span><br><span class="hljs-string">&quot;中\u56fd\u4eba&quot;</span> <span class="hljs-comment">// 中国人，不同字符字面值形式混合在一起</span><br><span class="hljs-string">&quot;\xe4\xb8\xad\xe5\x9b\xbd\xe4\xba\xba&quot;</span> <span class="hljs-comment">// 十六进制表示的字符串字面值：中国人</span><br></code></pre></td></tr></table></figure><h4 id="什么是-UTF-8-编码方案"><a href="#什么是-UTF-8-编码方案" class="headerlink" title="什么是 UTF-8 编码方案"></a>什么是 UTF-8 编码方案</h4><p>UTF-8 编码解决的是 Unicode 码点值在计算机中如何存储和表示（位模式）的问题。<br>像 UTF-32 编码标准就是直接固定使用 4 个字节表示每个 Unicode 字符码点。它的好处是编解码简单，而缺点如下：</p><ul><li>这种编码方案使用 4 个字节存储和传输一个整型数的时候，需要考虑不同平台的字节序问题 ;</li><li>由于采用 4 字节的固定长度编码，与采用 1 字节编码的 ASCII 字符集无法兼容；</li><li>所有 Unicode 字符码点都用 4 字节编码，显然空间利用率很差。</li></ul><p>针对这些问题，Go 语言之父 Rob Pike 发明了 UTF-8 编码方案。UTF-8 方案使用变长度字节，对 Unicode 字符的码点进行编码。编码采用的字节数量与 Unicode 字符在码点表中的序号有关：表示序号（码点）小的字符使用的字节数量少，表示序号（码点）大的字符使用的字节数多。<br>UTF-8 编码方案是兼容 ASCII 字符内存表示的，这意味着采用 UTF-8 方案在内存中表示 Unicode 字符时，已有的 ASCII 字符可以被直接当成 Unicode 字符进行存储和传输，不用再做任何改变。<br>总结：<br>UTF-32 编码方案，将所有 Unicode 字符的码点都按照 4 字节编码。<br>UTF-8 编码方案：根据 Unicode 字符的码点序号不同，所编码的字节数不同。1~4 个字节</p><p>使用 Go 在标准库中提供的 UTF-8 包，对 Unicode 字符（rune）进行编解码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// rune -&gt; []byte </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">encodeRune</span><span class="hljs-params">()</span></span> &#123; <br><span class="hljs-keyword">var</span> r <span class="hljs-type">rune</span> = <span class="hljs-number">0x4E2D</span> <br>fmt.Printf(<span class="hljs-string">&quot;the unicode charactor is %c\n&quot;</span>, r) <span class="hljs-comment">// 中 </span><br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">3</span>)<br> _ = utf8.EncodeRune(buf, r) <span class="hljs-comment">// 对rune进行utf-8编码 </span><br>fmt.Printf(<span class="hljs-string">&quot;utf-8 representation is 0x%X\n&quot;</span>, buf) <span class="hljs-comment">// 0xE4B8AD </span><br>&#125;<br><span class="hljs-comment">// []byte -&gt; rune </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeRune</span><span class="hljs-params">()</span></span> &#123; <br><span class="hljs-keyword">var</span> buf = []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0xE4</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0xAD</span>&#125; <br>r, _ := utf8.DecodeRune(buf) <span class="hljs-comment">// 对buf进行utf-8解码 </span><br>fmt.Printf(<span class="hljs-string">&quot;the unicode charactor after decoding [0xE4, 0xB8, 0xAD] is %s\n&quot;</span>, <span class="hljs-type">string</span>(r)) <span class="hljs-comment">// 中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，encodeRune 通过调用 UTF-8 的 EncodeRune 函数实现了对一个 rune，也就是一个 Unicode 字符的编码，decodeRune 则调用 UTF-8 包的 decodeRune，将一段内存字节转换回一个 Unicode 字符。</p><h4 id="Go-字符串类型的内部表示"><a href="#Go-字符串类型的内部表示" class="headerlink" title="Go 字符串类型的内部表示"></a>Go 字符串类型的内部表示</h4><p>Go 字符串类型的内部表示究竟是什么样的?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/reflect/value.go</span><br><br><span class="hljs-comment">// StringHeader是一个string的运行时表示</span><br><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>    Data <span class="hljs-type">uintptr</span><br>    Len  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>string 类型的本质其实是一个“描述符”，它本身并不真正存储字符串数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成的。</strong><br>![[【Go基础】未整理合集&#x2F;Pasted image 20230211165806.png|975]]<br>go 中的字符串的底层存储是二元组——字节数组指针+长度常量，所以获取字符串长度是 log (1) 时间；另外由于字符串保存的是字节数组的指针，所以函数&#x2F;方法间传递字符串时的开销也很小，因为并没有真的传递字符串的数据。</p><p>下面代码利用了 unsafe. Pointer 的通用指针转型能力，按照 StringHeader 给出的结构内存布局，“顺藤摸瓜”，一步步找到了底层数组的地址，并输出了底层数组内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dumpBytesArray</span><span class="hljs-params">(arr []<span class="hljs-type">byte</span>)</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;[&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, b := <span class="hljs-keyword">range</span> arr &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, b)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;]\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello&quot;</span><br>    hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) <span class="hljs-comment">// 将string类型变量地址显式转型为reflect.StringHeader</span><br>    fmt.Printf(<span class="hljs-string">&quot;0x%x\n&quot;</span>, hdr.Data) <span class="hljs-comment">// 0x10a30e0</span><br>    p := (*[<span class="hljs-number">5</span>]<span class="hljs-type">byte</span>)(unsafe.Pointer(hdr.Data)) <span class="hljs-comment">// 获取Data字段所指向的数组的指针</span><br>    dumpBytesArray((*p)[:]) <span class="hljs-comment">// [h e l l o ]   // 输出底层数组的内容</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go-字符串类型的常见操作"><a href="#Go-字符串类型的常见操作" class="headerlink" title="Go 字符串类型的常见操作"></a>Go 字符串类型的常见操作</h4><p>由于字符串的不可变性，针对字符串，我们更多是尝试对其进行读取，或者将它作为一个组成单元去构建其他字符串，又或是转换为其他类型。</p><p><strong>第一个操作：下标操作。</strong><br>在字符串的实现中，真正存储数据的是底层的数组。字符串的下标操作本质上等价于底层数组的下标操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;0x_%x\n&quot;</span>, s[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 0x_e4：字符“中” utf-8编码的第一个字节</span><br></code></pre></td></tr></table></figure><p>通过下标操作，我们获取的是字符串中特定下标上的字节，而不是字符。</p><p><strong>第二个操作：字符迭代。</strong><br>Go 有两种迭代形式：常规 for 迭代与 for range 迭代。但是要<strong>注意，通过这两种形式的迭代对字符串进行操作得到的结果是不同的。</strong></p><p><strong>for 迭代：字节形式    for range 迭代：字符形式。</strong></p><p>常规 for 迭代对字符串进行的操作是一种字节视角的迭代，每轮迭代得到的的结果都是组成字符串内容的一个字节，以及该字节所在的下标值，这也等价于对字符串底层数组的迭代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, s[i])<br>&#125;<br><span class="hljs-comment">//输出</span><br>index: <span class="hljs-number">0</span>, value: <span class="hljs-number">0xe4</span><br>index: <span class="hljs-number">1</span>, value: <span class="hljs-number">0xb8</span><br>index: <span class="hljs-number">2</span>, value: <span class="hljs-number">0xad</span><br>index: <span class="hljs-number">3</span>, value: <span class="hljs-number">0xe5</span><br>index: <span class="hljs-number">4</span>, value: <span class="hljs-number">0x9b</span><br>index: <span class="hljs-number">5</span>, value: <span class="hljs-number">0xbd</span><br>index: <span class="hljs-number">6</span>, value: <span class="hljs-number">0xe4</span><br>index: <span class="hljs-number">7</span>, value: <span class="hljs-number">0xba</span><br>index: <span class="hljs-number">8</span>, value: <span class="hljs-number">0xba</span><br></code></pre></td></tr></table></figure><p>而通过 for range 迭代，我们每轮迭代得到的是字符串中 Unicode 字符的码点值，以及该字符在字符串中的偏移值。我们可以通过这样的迭代，获取字符串中的字符个数（或者使用调用标准库 UTF-8 包中的 RuneCountInString 函数），而通过 Go 提供的内置函数 len，我们只能获取字符串内容的长度（字节个数）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, v)<br>&#125;<br><span class="hljs-comment">//输出</span><br>index: <span class="hljs-number">0</span>, value: <span class="hljs-number">0x4e2d</span><br>index: <span class="hljs-number">3</span>, value: <span class="hljs-number">0x56fd</span><br>index: <span class="hljs-number">6</span>, value: <span class="hljs-number">0x4eba</span><br></code></pre></td></tr></table></figure><p><strong>第三个操作：字符串连接。</strong><br>Go 原生支持通过 +&#x2F;+&#x3D; 操作符进行字符串连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;Rob Pike, &quot;</span><br>s = s + <span class="hljs-string">&quot;Robert Griesemer, &quot;</span><br>s += <span class="hljs-string">&quot; Ken Thompson&quot;</span><br><br>fmt.Println(s) <span class="hljs-comment">// Rob Pike, Robert Griesemer, Ken Thompson</span><br></code></pre></td></tr></table></figure><p>虽然通过 +&#x2F;+&#x3D; 进行字符串连接的开发体验是最好的，但连接性能就未必是最快的了。除了这个方法外，Go 还提供了 strings. Builder、strings. Join、fmt. Sprintf 等函数来进行字符串连接操作。</p><p><strong>第四个操作：字符串比较。</strong><br>在字符串的比较上，Go 采用字典序的比较策略，分别从每个字符串的起始处，开始逐个<strong>字节</strong>地对两个字符串类型变量进行比较（字符串比较会进行从左到右做逐字节比较，而不是码点）。当两个字符串之间出现了第一个不相同的元素，比较就结束了，这两个元素的比较结果就会做为串最终的比较结果。如果出现两个字符串长度不同的情况，长度比较小的字符串会用空元素补齐，空元素比其他非空元素都小。<a href="https://tonybai.com/2022/04/18/inside-go-string-comparison">Fetching Title#ln3o</a><br>鉴于 Go string 类型是不可变的，所以说如果两个字符串的长度不相同，那么我们不需要比较具体字符串数据，也可以断定两个字符串是不同的。但是如果两个字符串长度相同，就要进一步判断，数据指针是否指向同一块底层存储数据。如果还相同，那么我们可以说两个字符串是等价的，如果不同，那就还需要进一步去比对实际的数据内容（虽然内存地址不同，也可能值相同，所以，需要进一步比较。）。</p><p><strong>第五个操作：字符串转换。</strong><br>Go 支持字符串与字节切片、字符串与 rune 切片的双向转换，并且这种转换无需调用任何函数，只需使用显式类型转换就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;中国人&quot;</span><br>                      <br><span class="hljs-comment">// string -&gt; []rune</span><br>rs := []<span class="hljs-type">rune</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, rs) <span class="hljs-comment">// [4e2d 56fd 4eba]</span><br>                <br><span class="hljs-comment">// string -&gt; []byte</span><br>bs := []<span class="hljs-type">byte</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, bs) <span class="hljs-comment">// e4b8ade59bbde4baba</span><br>                <br><span class="hljs-comment">// []rune -&gt; string</span><br>s1 := <span class="hljs-type">string</span>(rs)<br>fmt.Println(s1) <span class="hljs-comment">// 中国人</span><br>                <br><span class="hljs-comment">// []byte -&gt; string</span><br>s2 := <span class="hljs-type">string</span>(bs)<br>fmt.Println(s2) <span class="hljs-comment">// 中国人</span><br></code></pre></td></tr></table></figure><p>这样的转型看似简单，但无论是 string 转切片，还是切片转 string，这类转型背后也是有着一定开销的。这些开销的根源就在于 string 是不可变的，运行时要为转换后的类型分配新内存。</p><h5 id="那种连接方式是性能最高的？"><a href="#那种连接方式是性能最高的？" class="headerlink" title="那种连接方式是性能最高的？"></a>那种连接方式是性能最高的？</h5><p>如果能知道拼接字符串的个数，那么使用 bytes. Buffer 和 strings. Builder 的 Grows 申请空间后，性能是最好的；<br>如果不能确定长度，那么 bytes. Buffer 和 strings. Builder 也比“+”和 fmt. Sprintf 性能好很多。 bytes. Buffer 与 strings. Builder 相比的话，strings. Builder 更合适，因为 bytes. Buffer 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 strings. Builder 直接将底层的 []byte 转换成了字符串类型返回了回来。</p><h3 id="Go-常量"><a href="#Go-常量" class="headerlink" title="Go 常量"></a>Go 常量</h3><p>（暂时跳过）</p><h2 id="Go-复合类型"><a href="#Go-复合类型" class="headerlink" title="Go 复合类型"></a>Go 复合类型</h2><h3 id="同构复合类型"><a href="#同构复合类型" class="headerlink" title="同构复合类型"></a>同构复合类型</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>Go 语言的数组是一个长度固定的、由同构类型元素组成的连续序列。<br>Go 的数组类型包含两个重要属性：<strong>元素的类型</strong>和<strong>数组长度</strong>（元素的个数）。这两个属性也直接构成了 Go 语言中数组类型变量的声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [N]T<br></code></pre></td></tr></table></figure><p>这里我们声明了一个数组变量 arr，它的类型为[N]T，其中元素的类型为 T，数组的长度为 N。<br>数组元素的类型可以为任意的 Go 原生类型或自定义类型，而且数组的长度必须在声明数组变量时提供，Go 编译器需要在编译阶段就知道数组类型的长度，所以，我们只能用整型数字面值或常量表达式作为 N 值。<br><strong>如果两个数组类型的元素类型 T 与数组长度 N 都是一样的，那么这两个数组类型是等价的，如果有一个属性不同，它们就是两个不同的数组类型。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(arr [5]<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> arr2 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> arr3 [<span class="hljs-number">5</span>]<span class="hljs-type">string</span><br><br>    foo(arr1) <span class="hljs-comment">// ok</span><br>    foo(arr2) <span class="hljs-comment">// 错误：[6]int与函数foo参数的类型[5]int不是同一数组类型</span><br>    foo(arr3) <span class="hljs-comment">// 错误：[5]string与函数foo参数的类型[5]int不是同一数组类型</span><br>&#125;  <br></code></pre></td></tr></table></figure><p>数组类型不仅是逻辑上的连续序列，而且在实际内存分配时也占据着一整块内存。Go 编译器在为数组类型的变量实际分配内存时，会为 Go 数组分配一整块、可以容纳它所有元素的连续内存，如下图所示：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213121345.png]]<br>Go 提供了预定义函数 len 可以用于获取一个数组类型变量的长度，通过 unsafe 包提供的 Sizeof 函数，我们可以获得一个数组变量的总大小.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;数组长度：&quot;</span>, <span class="hljs-built_in">len</span>(arr))           <span class="hljs-comment">// 6</span><br>fmt.Println(<span class="hljs-string">&quot;数组大小：&quot;</span>, unsafe.Sizeof(arr)) <span class="hljs-comment">// 48</span><br></code></pre></td></tr></table></figure><p>数组大小就是所有元素的大小之和，这里数组元素的类型为 int。在 64 位平台上，int 类型的大小为 8，数组 arr 一共有 6 个元素，因此它的总大小为 6x8&#x3D;48 个字节。</p><p>和基本数据类型一样，我们声明一个数组类型变量的同时，也可以显式地对它进行初始化。如果不进行显式初始化，那么数组中的元素值就是它类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// [0 0 0 0 0 0]</span><br></code></pre></td></tr></table></figure><p>如果要显式地对数组初始化，我们需要在右值中显式放置数组类型，并通过大括号的方式给各个元素赋值（如下面代码中的 arr2）。我们也可以忽略掉右值初始化表达式中数组类型的长度，用“…”替代，Go 编译器会根据数组元素的个数，自动计算出数组长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>,<br>&#125; <span class="hljs-comment">// [11 12 13 14 15 16]</span><br><br><span class="hljs-keyword">var</span> arr3 = [...]<span class="hljs-type">int</span> &#123; <br>    <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>,<br>&#125; <span class="hljs-comment">// [21 22 23]</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, arr3) <span class="hljs-comment">// [3]int</span><br></code></pre></td></tr></table></figure><p>如果我们要对一个长度较大的稀疏数组进行显式初始化, 可以通过使用下标赋值的方式对它进行初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr4 = [...]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-number">99</span>: <span class="hljs-number">39</span>, <span class="hljs-comment">// 将第100个元素(下标值为99)的值赋值为39，其余元素值均为0</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, arr4) <span class="hljs-comment">// [100]int</span><br></code></pre></td></tr></table></figure><p>这种赋值方式有点怪，和 python 的逻辑是完全不同的。</p><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>数组类型自身也可以作为数组元素的类型，这样就会产生<strong>多维数组</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mArr [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>![[【Go基础】未整理合集&#x2F;Pasted image 20230213123358.png]]<br>从左到右看，[2][3][4]int 可以把这个多维数组拆分。无论多维数组究竟有多少维，我们都可以将它从左到右逐一展开，最终化为我们熟悉的一维数组。</p><p>数组类型变量是一个整体，这就意味着一个数组变量表示的是整个数组，因此在 Go 语言中，无论是参与迭代，还是作为实际参数传给一个函数 &#x2F; 方法，Go 传递数组的方式都是纯粹的值拷贝，这会带来较大的内存拷贝开销。这点与 C 语言完全不同，在 C 语言中，数组变量可视为指向数组第一个元素的指针，而 Go 语言对这个问题的解决方式为使用一个新的数据类型<strong>切片</strong>，来解决这个问题。</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>数组在使用上确有两点不足：<br>1、元素的个数是固定的，不可变<br>2、默认只传递值（需要显示指定传递指针），有内存拷贝的开销。<br>于是 Go 设计者们又引入了另外一种同构复合类型：切片（slice），来弥补数组的这两处不足。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<span class="hljs-comment">//初始化一个切片变量</span><br>fmt.Println(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 6</span><br>nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">7</span>) <span class="hljs-comment">// 切片变为[1 2 3 4 5 6 7]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 7</span><br></code></pre></td></tr></table></figure><p>与数组声明相比，切片声明仅仅是少了一个“长度”属性.<br>虽然不需要像数组那样在声明时指定长度，但切片也有自己的长度，只不过这个长度不是固定的，而是随着切片中元素个数的变化而变化的。通过 Go 内置函数 append，我们可以动态地向切片中添加元素。</p><h5 id="切片类型组成"><a href="#切片类型组成" class="headerlink" title="切片类型组成"></a>切片类型组成</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>    array unsafe.Pointer<br>    <span class="hljs-built_in">len</span>   <span class="hljs-type">int</span><br>    <span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每个切片包含三个字段：</p><ul><li>array: 是指向底层数组的指针；</li><li>len: 是切片的长度，即切片中当前元素的个数；</li><li>cap: 是底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len 值。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213125017.png]]</li></ul><p>Go 编译器会自动为每个新创建的切片，建立一个底层数组，默认底层数组的长度与切片初始元素个数相同。我们还可以用以下几种方法创建切片，并指定它底层数组的长度。</p><h5 id="创建切片的方法"><a href="#创建切片的方法" class="headerlink" title="创建切片的方法"></a>创建切片的方法</h5><p><a href="https://qcrao.com/post/dive-into-go-slice/">深度解密 Go 语言之 slice | qcrao 的博客</a><br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213145059.png]]</p><p><strong>方法一：通过 make 函数来创建切片，并指定底层数组的长度</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">sl := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 6为切片的初始长度,10为cap值，即底层数组长度，</span><br></code></pre></td></tr></table></figure><p>如果没有在 make 中指定 cap 参数，那么底层数组长度 cap 就等于 len，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">sl := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// cap = len = 6</span><br></code></pre></td></tr></table></figure><p><strong>方法二：采用 array[low : high : max]语法基于一个已存在的数组创建切片。这种方式被称为数组的切片化，</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;<br>sl := arr[<span class="hljs-number">3</span>:<span class="hljs-number">7</span>:<span class="hljs-number">9</span>]<span class="hljs-comment">//sl是一个指向arr, len为4, cap为6的切片</span><br><br>sl[<span class="hljs-number">0</span>] += <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;arr[3] =&quot;</span>, arr[<span class="hljs-number">3</span>]) <span class="hljs-comment">// 14</span><br></code></pre></td></tr></table></figure><p>基于数组创建的切片，它的起始元素从 low 所标识的下标值开始，切片的长度（len）是 high - low，它的容量是 max - low。由于切片 sl 的底层数组就是数组 arr，对切片 sl 中元素的修改将直接影响数组 arr 变量。比如，如果我们将切片的第一个元素加 10，那么数组 arr 的第四个元素将变为 14：<br>这个切片 sl 在运行时中的表示是这样：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213125334.png]]<br><strong>切片好比打开了一个访问与修改数组的“窗口”，通过这个窗口，我们可以直接操作底层数组中的部分元素。</strong><br>这有些类似于我们操作文件之前打开的“文件描述符”（Windows 上称为句柄），通过文件描述符我们可以对底层的真实文件进行相关操作。可以说，切片之于数组就像是文件描述符之于文件。<br>在 Go 语言中，数组更多是“退居幕后”，承担的是底层存储空间的角色。切片就是数组的“描述符”，也正是因为这一特性，切片才能在函数参数传递时避免较大性能开销。因为我们传递的并不是数组本身，而是数组的“描述符”，这个描述符的大小是固定的（见上面的三元组结构），无论底层的数组有多大，切片打开的“窗口”长度有多长，它都是不变的。此外，<strong>我们在进行数组切片化的时候，通常省略 max，而 max 的默认值为数组的长度。</strong><br>可以为同一个内存分配多个”描述符”也就是多个切片。这样的情况下，无论我们通过哪个切片对数组进行的修改操作，都会反映到另一个切片中。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213130856.png]]<br>比如，将 sl2[2]置为 14，那么 sl1[0]也会变成 14，因为 sl2[2]直接操作的是底层数组 arr 的第四个元素 arr[3]。</p><p><strong>方法三：基于切片创建切片。</strong><br>和前面是一样的。</p><h5 id="切片的动态扩容"><a href="#切片的动态扩容" class="headerlink" title="切片的动态扩容"></a>切片的动态扩容</h5><p>“动态扩容”指的就是，当我们通过 append 操作向切片追加数据的时候，如果这时切片的 len 值和 cap 值是相等的，也就是说切片底层数组已经没有空闲空间再来存储追加的值了，Go 运行时就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br>s = <span class="hljs-built_in">append</span> (s, <span class="hljs-number">11</span>) <br>fmt. Println (<span class="hljs-built_in">len</span> (s), <span class="hljs-built_in">cap</span> (s)) <span class="hljs-comment">//1 1</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">12</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//2 2</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">13</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//3 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">14</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//4 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">15</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//5 8</span><br></code></pre></td></tr></table></figure><p>append 会根据切片的需要，在当前底层数组容量无法满足的情况下，动态分配新的数组，新数组长度会按一定规律扩展。<br>在上面这段代码中，针对元素是 int 型的数组，新数组的容量是当前数组的 2 倍。新数组建立后，append 会把旧数组中的数据拷贝到新数组中，之后新数组便成为了切片的底层数组，旧数组会被垃圾回收掉。</p><h5 id="关于扩容的小坑"><a href="#关于扩容的小坑" class="headerlink" title="关于扩容的小坑"></a>关于扩容的小坑</h5><p>append 操作的这种自动扩容行为，有些时候会给我们开发者带来一些困惑，比如基于一个已有数组建立的切片，一旦追加的数据操作触碰到切片的容量上限（实质上也是数组容量的上界)，切片就会和原数组解除“绑定”，后续对切片的任何修改都不会反映到原数组中了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">u := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;array:&quot;</span>, u) <span class="hljs-comment">// [11, 12, 13, 14, 15]</span><br>s := u[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>fmt.Printf(<span class="hljs-string">&quot;slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><span class="hljs-comment">// slice(len=2, cap=4): [12 13]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">24</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 24, array:&quot;</span>, u)<br><span class="hljs-comment">// after append 24, array: [11 12 13 24 15]</span><br>fmt.Printf(<span class="hljs-string">&quot;after append 24, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><span class="hljs-comment">// after append 24, slice(len=3, cap=4): [12 13 24]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">25</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 25, array:&quot;</span>, u)<br><span class="hljs-comment">// after append 25, array: [11 12 13 24 25]</span><br>fmt.Printf(<span class="hljs-string">&quot;after append 25, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><span class="hljs-comment">// after append 25, slice(len=4, cap=4): [12 13 24 25]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">26</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 26, array:&quot;</span>, u)<br><span class="hljs-comment">// after append 26, array: [11 12 13 24 25]</span><br>fmt.Printf(<span class="hljs-string">&quot;after append 26, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><span class="hljs-comment">// after append 26, slice(len=5, cap=8): [12 13 24 25 26]</span><br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">22</span><br>fmt.Println(<span class="hljs-string">&quot;after reassign 1st elem of slice, array:&quot;</span>, u)<br><span class="hljs-comment">// after reassign 1st elem of slice, array: [11 12 13 24 25]</span><br>fmt.Printf(<span class="hljs-string">&quot;after reassign 1st elem of slice, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><span class="hljs-comment">// after reassign 1st elem of slice, slice(len=5, cap=8): [22 13 24 25 26]</span><br></code></pre></td></tr></table></figure><p>这里，在 append 25 之后，切片的元素已经触碰到了底层数组 u 的边界了。然后我们再 append 26 之后，append 发现底层数组已经无法满足 append 的要求，于是新创建了一个底层数组（数组长度为 cap (s) 的 2 倍，即 8），并将 slice 的元素拷贝到新数组中了。<br>在这之后，我们即便再修改切片的第一个元素值，原数组 u 的元素也不会发生改变了，因为这个时候切片 s 与数组 u 已经解除了“绑定关系”，s 已经不再是数组 u 的“描述符”。<br><strong>容易遇到的问题</strong><br>切片做入参，本质还是值传递，构建一个新变量接受内部字段值，所以函数内扩容后无法反应到函数外的切片。</p><h5 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h5><p><a href="https://qcrao.com/post/dive-into-go-slice/">深度解密 Go 语言之 slice | qcrao 的博客</a></p><h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>map 是 Go 语言提供的一种抽象数据类型，它表示一组无序的键值对。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230213140031.png]]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">map</span>[key_type]value_type<br><span class="hljs-comment">//key 与 value 的类型可以相同，也可以不同：</span><br><br><span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span> <span class="hljs-comment">// key与value元素的类型相同</span><br><span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>    <span class="hljs-comment">// key与value元素的类型不同</span><br></code></pre></td></tr></table></figure><p>如果两个 map 类型的 key 元素类型相同，value 元素类型也相同，那么我们可以说它们是同一个 map 类型，否则就是不同的 map 类型。<br>map 类型对 value 的类型没有限制，但是对 key 的类型却有严格要求，因为 map 类型要保证 key 的唯一性。<strong>Go 语言中要求，key 的类型必须支持“=&#x3D;”和“!&#x3D;”两种比较操作符。</strong> 而在 Go 语言中，函数类型、map 类型自身，以及切片只支持与 nil 的比较，而不支持同类型两个变量的比较。因此<strong>函数类型、map 类型自身，以及切片类型是不能作为 map 的 key 类型</strong>的。</p><h5 id="map-变量的声明和初始化"><a href="#map-变量的声明和初始化" class="headerlink" title="map 变量的声明和初始化"></a>map 变量的声明和初始化</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 一个 map[string]int 类型的变量</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 初值为零值 nil 的切片类型变量，可以借助内置的 append 的函数进行操作，这种在 Go 语言中被称为“零值可用”。但 map 类型，因为它内部实现的复杂性，无法“零值可用”。所以，如果我们对处于零值状态的 map 变量直接进行操作，就会导致运行时异常（panic），从而导致程序进程异常退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// m = nil</span><br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-number">1</span>         <span class="hljs-comment">// 发生运行时异常：panic: assignment to entry in nil map</span><br></code></pre></td></tr></table></figure><p>为 map 类型变量显式赋值有两种方式：一种是使用复合字面值；另外一种是使用 make 这个预声明的内置函数。</p><p><strong>方法一：使用复合字面值初始化 map 类型变量。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>此时 map 类型变量 m 中没有任何键值对，变量 m 也不等同于初值为 nil 的 map 变量。这个时候，我们对 m 进行键值对的插入操作，不会引发运行时异常。<br>复杂一些的复合字面值，对 map 类型变量进行初始化，不过这里能写的这么简单是因为 Go 提供了“语法糖”：<strong>Go 允许省略字面值中的元素类型</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Position <span class="hljs-keyword">struct</span> &#123; x <span class="hljs-type">float64</span> y <span class="hljs-type">float64</span>&#125;<br>m2 := <span class="hljs-keyword">map</span>[Position]<span class="hljs-type">string</span>&#123;<br>    &#123;<span class="hljs-number">29.935523</span>, <span class="hljs-number">52.568915</span>&#125;: <span class="hljs-string">&quot;school&quot;</span>,<br>    &#123;<span class="hljs-number">25.352594</span>, <span class="hljs-number">113.304361</span>&#125;: <span class="hljs-string">&quot;shopping-mall&quot;</span>,<br>    &#123;<span class="hljs-number">73.224455</span>, <span class="hljs-number">111.804306</span>&#125;: <span class="hljs-string">&quot;hospital&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：使用 make 为 map 类型变量进行显式初始化。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>) <span class="hljs-comment">// 未指定初始容量</span><br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 指定初始容量为8</span><br></code></pre></td></tr></table></figure><p>map 类型的容量不会受限于它的初始容量值，当其中的键值对数量超过初始容量后，Go 运行时会自动增加 map 类型的容量，保证后续键值对的正常插入。</p><h5 id="map-的基本操作"><a href="#map-的基本操作" class="headerlink" title="map 的基本操作"></a>map 的基本操作</h5><p>插入新键值对、获取当前键值对数量、查找特定键和读取对应值、删除键值对，以及遍历键值等操作<br><strong>操作一：插入新键值对。</strong><br>面对一个非 nil 的 map 类型变量，我们可以在其中插入符合 map 类型定义的任意新键值对。插入新键值对的方式很简单，我们只需要把 value 赋值给 map 中对应的 key 就可以了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;value1&quot;</span><br>m[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;value2&quot;</span><br>m[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;value3&quot;</span><br></code></pre></td></tr></table></figure><p>而且，我们不需要自己判断数据有没有插入成功，因为 Go 会保证插入总是成功的。这里，Go 运行时会负责 map 变量内部的内存管理，因此除非是系统内存耗尽，我们可以不用担心向 map 中插入新数据的数量和执行结果。<br>如果我们插入新键值对的时候，某个 key 已经存在于 map 中了，那我们的插入操作就会用新值覆盖旧值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>m[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-number">11</span> <span class="hljs-comment">// 11会覆盖掉&quot;key1&quot;对应的旧值1</span><br>m[<span class="hljs-string">&quot;key3&quot;</span>] = <span class="hljs-number">3</span>  <span class="hljs-comment">// 此时m为map[key1:11 key2:2 key3:3]</span><br></code></pre></td></tr></table></figure><p><strong>操作二：获取键值对数量。</strong><br>和切片一样，map 类型也可以通过内置函数 len，获取当前变量已经存储的键值对数量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>fmt.Println(<span class="hljs-built_in">len</span>(m)) <span class="hljs-comment">// 2</span><br>m[<span class="hljs-string">&quot;key3&quot;</span>] = <span class="hljs-number">3</span>  <br>fmt.Println(<span class="hljs-built_in">len</span>(m)) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>不过，这里要注意的是<strong>我们不能对 map 类型变量调用 cap，来获取当前容量，这是 map 类型与切片类型的一个不同点。</strong> (底层实现不同，切片连续数组，map 底层一般为 RBTree)</p><p><strong>操作三：查找和数据读取</strong><br>和写入相比，map 类型更多用在查找和数据读取场合。所谓查找，就是判断某个 key 是否存在于某个 map 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// 1 错误的查找方法 即使&quot;key1&quot;不在map中，v还是会得到一个int的零值、</span><br>v := m[<span class="hljs-string">&quot;key1&quot;</span>] <br></code></pre></td></tr></table></figure><p>上面 1 这样是无法确定键 key1 是否真实存在于 map 中的。如果这个键在 map 中并不存在，我们也会得到一个值，这个值是 value 元素类型的零值。 如果键 key1 在 map 中并不存在，那么 v 的值就会被赋予 value 元素类型 int 的零值，也就是 0。所以我们无法通过 v 值判断出，究竟是因为 key1 不存在返回的零值，还是因为 key1 本身对应的 value 就是 0。</p><p>正确姿势是：<strong>Go 语言的 map 类型支持通过用一种名为“comma ok”的惯用法，进行对某个 key 的查询。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 2 正确的方法</span><br>v, ok := m[<span class="hljs-string">&quot;key1&quot;</span>]<br><span class="hljs-keyword">if</span> !ok &#123;    <br><span class="hljs-comment">// &quot;key1&quot;不在map中</span><br>&#125;<br><span class="hljs-comment">// &quot;key1&quot;在map中，v将被赋予&quot;key1&quot;键对应的value</span><br></code></pre></td></tr></table></figure><p><strong>操作四：删除数据。</strong><br>在 Go 中，我们需要借助内置函数 delete 来从 map 中删除数据。<strong>delete 函数是从 map 中删除键的唯一方法。</strong> 使用 delete 函数的情况下，传入的第一个参数是我们的 map 类型变量，第二个参数就是我们想要删除的键。即便传给 delete 的键在 map 中并不存在，delete 函数的执行也不会失败，更不会抛出运行时的异常。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>fmt.Println(m) <span class="hljs-comment">// map[key1:1 key2:2]</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key2&quot;</span>) <span class="hljs-comment">// 删除&quot;key2&quot;</span><br>fmt.Println(m) <span class="hljs-comment">// map[key1:1]</span><br></code></pre></td></tr></table></figure><p><strong>操作五：遍历 map 中的键值数据</strong><br>遍历 map 的键值对只有一种方法，那就是像对待切片那样通过 for range 语句对 map 数据进行遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-number">1</span>: <span class="hljs-number">11</span>,<br>        <span class="hljs-number">2</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-number">3</span>: <span class="hljs-number">13</span>,<br>    &#125;<br><br>    fmt. Printf (<span class="hljs-string">&quot;&#123; &quot;</span>)<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;[%d, %d] &quot;</span>, k, v)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;&#125;\n&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是注意：<strong>对同一 map 做多次遍历的时候，每次遍历元素的次序都不相同。</strong> 因此，程序逻辑千万不要依赖遍历 map 所得到的的元素次序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doIteration</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;&#123; &quot;</span>)<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;[%d, %d] &quot;</span>, k, v)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;&#125;\n&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-number">1</span>: <span class="hljs-number">11</span>,<br>        <span class="hljs-number">2</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-number">3</span>: <span class="hljs-number">13</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>        doIteration(m)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出</span><br>&#123; [<span class="hljs-number">3</span>, <span class="hljs-number">13</span>] [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>] [<span class="hljs-number">2</span>, <span class="hljs-number">12</span>] &#125;<br>&#123; [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>] [<span class="hljs-number">2</span>, <span class="hljs-number">12</span>] [<span class="hljs-number">3</span>, <span class="hljs-number">13</span>] &#125;<br>&#123; [<span class="hljs-number">3</span>, <span class="hljs-number">13</span>] [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>] [<span class="hljs-number">2</span>, <span class="hljs-number">12</span>] &#125;<br></code></pre></td></tr></table></figure><h5 id="map-变量的传递开销"><a href="#map-变量的传递开销" class="headerlink" title="map 变量的传递开销"></a>map 变量的传递开销</h5><p>和切片类型一样，map 也是引用类型。这就意味着 map 类型变量作为参数被传递给函数或方法的时候，实质上传递的只是一个“描述符”，而不是整个 map 的数据拷贝，所以这个传递的开销是固定的，而且也很小。<br>并且，不同于切片，当 map 变量被传递到函数或方法内部后，我们在函数内部对 map 类型参数的修改在函数外部也是可见的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    m[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-number">11</span><br>    m[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-number">12</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-string">&quot;key1&quot;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&quot;key2&quot;</span>: <span class="hljs-number">2</span>,<br>    &#125;<br><br>    fmt.Println(m) <span class="hljs-comment">// map[key1:1 key2:2]  </span><br>    foo(m)<br>    fmt.Println(m) <span class="hljs-comment">// map[key1:11 key2:12] </span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="map-的内部实现"><a href="#map-的内部实现" class="headerlink" title="map 的内部实现"></a>map 的内部实现</h5><p>Go 运行时使用一张哈希表来实现抽象的 map 类型。运行时实现了 map 类型操作的所有功能，包括查找、插入、删除等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建map类型变量实例</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[keyType]valType, capacityhint)<br>→ m := runtime.makemap(maptype, capacityhint, m)<br><span class="hljs-comment">// 插入新键值对或给键重新赋值</span><br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span><br>→ v := runtime. mapassign (maptype, m, <span class="hljs-string">&quot;key&quot;</span>) v 是用于后续存储 value 的空间的地址<br><span class="hljs-comment">// 获取某键的值 </span><br>v := m[<span class="hljs-string">&quot;key&quot;</span>]      <br>→ v := runtime.mapaccess1(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br>v, ok := m[<span class="hljs-string">&quot;key&quot;</span>]  <br>→ v, ok := runtime.mapaccess2(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br><span class="hljs-comment">// 删除某键</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key&quot;</span>)   <br>→ runtime.mapdelete(maptype, m, “key”)<br></code></pre></td></tr></table></figure><p>（略）</p><h5 id="map-扩容"><a href="#map-扩容" class="headerlink" title="map 扩容"></a>map 扩容</h5><p>(略)</p><h5 id="map-与并发"><a href="#map-与并发" class="headerlink" title="map 与并发"></a>map 与并发</h5><p>map 实例不是并发写安全的，也不支持并发读写。如果我们对 map 实例进行并发读写，程序运行时就会抛出异常。<br>不过，如果我们仅仅是进行并发读，map 是没有问题的。而且，Go 1.9 版本中引入了支持并发写安全的 sync. Map 类型，可以在并发读写的场景下替换掉 map。</p><p>考虑到 map 可以自动扩容，map 中数据元素的 value 位置可能在这一过程中发生变化，所以 Go 不允许获取 map 中 value 的地址，这个约束是在编译期间就生效的。</p><h5 id="使用-map-的三个要点"><a href="#使用-map-的三个要点" class="headerlink" title="使用 map 的三个要点"></a>使用 map 的三个要点</h5><ul><li>不要依赖 map 的元素遍历顺序；</li><li>map 不是线程安全的，不支持并发读写；</li><li>不要尝试获取 map 中元素（value）的地址。</li></ul><h5 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h5><p><a href="https://www.qcrao.com/2019/05/22/dive-into-go-map/">https://www.qcrao.com/2019/05/22/dive-into-go-map/</a><br><a href="https://qcrao.com/2020/05/06/dive-into-go-sync-map/">https://qcrao.com/2020/05/06/dive-into-go-sync-map/</a><br><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/</a></p><h4 id="Struct-自定义类型"><a href="#Struct-自定义类型" class="headerlink" title="Struct 自定义类型"></a>Struct 自定义类型</h4><h5 id="如何自定义一个新类型？"><a href="#如何自定义一个新类型？" class="headerlink" title="如何自定义一个新类型？"></a>如何自定义一个新类型？</h5><p>自定义一个新类型一般有两种方法。<br><strong>第一种是类型定义（Type Definition</strong>），这也是我们最常用的类型定义方法。在这种方法中，我们会使用关键字 type 来定义一个新类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T S <span class="hljs-comment">// 定义一个新类型T</span><br></code></pre></td></tr></table></figure><p><strong>第二种自定义新类型的方式是使用类型别名（Type Alias）</strong>，这种类型定义方式通常用在项目的渐进式重构，还有对已有包的二次封装方面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T = S <span class="hljs-comment">// type alias</span><br></code></pre></td></tr></table></figure><h5 id="如何定义一个结构体类型？"><a href="#如何定义一个结构体类型？" class="headerlink" title="如何定义一个结构体类型？"></a>如何定义一个结构体类型？</h5><p>典型的结构体类型的定义形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    Field1 T1<br>    Field2 T2<br>    ... ...<br>    FieldN Tn<br>&#125;<br></code></pre></td></tr></table></figure><p>struct 关键字后面的大括号包裹的内容就是一个<strong>类型字面值</strong>。这个类型字面值由若干个字段（field）聚合而成，每个字段有自己的名字与类型，并且在一个结构体中，每个字段的名字应该都是唯一的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> book<br><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>     Title <span class="hljs-type">string</span>              <span class="hljs-comment">// 书名</span><br>     Pages <span class="hljs-type">int</span>                 <span class="hljs-comment">// 书的页数</span><br>     Indexes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>    <span class="hljs-comment">// 书的索引</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类型 Book 的类型名“Book”以及内部的各个字段中首字母大写的原因是这样类型 Book 以及它的各个字段都是导出标识符，只要其他包导入了包 book，我们就可以在这些包中直接引用类型名 Book，也可以通过 Book 类型变量引用 Name、Pages 等字段。<br>而如果结构体类型只在它定义的包内使用，那么我们可以将类型名的首字母小写；如果你不想将结构体类型中的某个字段暴露给其他包，那么我们同样可以把这个字段名字的首字母小写。<br>还可以用空标识符“_”作为结构体类型定义中的字段名称。这样以空标识符为名称的字段，不能被外部包引用，甚至无法被结构体所在的包使用。</p><h6 id="特殊情况-特殊但是不少见"><a href="#特殊情况-特殊但是不少见" class="headerlink" title="特殊情况 (特殊但是不少见)"></a>特殊情况 (特殊但是不少见)</h6><p><strong>第一种：定义一个空结构体。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// Empty是一个不包含任何字段的空结构体类型</span><br></code></pre></td></tr></table></figure><p>空结构体类型有什么用?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s Empty<br><span class="hljs-built_in">println</span>(unsafe.Sizeof(s)) <span class="hljs-comment">// 0 空结构体类型变量的内存占用为 0。</span><br></code></pre></td></tr></table></figure><p>基于空结构体类型内存零开销这样的特性，我们在日常 Go 开发中会经常使用空结构体类型元素，作为一种“事件”信息进行 Goroutine 之间的通信。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Empty) <span class="hljs-comment">// 声明一个元素类型为Empty的channel</span><br>c&lt;-Empty&#123;&#125;               <span class="hljs-comment">// 向channel写入一个“事件”</span><br></code></pre></td></tr></table></figure><p>这种以空结构体为元素类建立的 channel，是目前能实现的、内存占用最小的 Goroutine 间通信方式。</p><p><strong>第二种情况：使用其他结构体作为自定义结构体中字段的类型。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Phone <span class="hljs-type">string</span><br>    Addr <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span><br>    Author Person<br>    ... ...<br>&#125;<br><span class="hljs-comment">//如果我们要访问 Book 结构体字段 Author 中的 Phone 字段，我们可以这样操作</span><br><span class="hljs-keyword">var</span> book Book <br><span class="hljs-built_in">println</span>(book.Author.Phone)<br></code></pre></td></tr></table></figure><p>不过，对于包含结构体类型字段的结构体类型来说，Go 还提供了一种更为简便的定义方法，那就是我们可以无需提供字段的名字，只需要使用其类型就可以了，以上面的 Book 结构体定义的一个等价的定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span><br>    Person<br>    ... ...<br>&#125;<br><br><span class="hljs-keyword">var</span> book Book <br><span class="hljs-built_in">println</span>(book.Person.Phone) <span class="hljs-comment">// 将类型名当作嵌入字段的名字</span><br><span class="hljs-built_in">println</span>(book.Phone)        <span class="hljs-comment">// 支持直接访问嵌入字段所属类型中字段</span><br></code></pre></td></tr></table></figure><p>以这种方式定义的结构体字段，我们叫做<strong>嵌入字段（Embedded Field）</strong> 或者 <strong>匿名字段</strong>。<br>这样就可以把类型名当作嵌入字段的名字来进行操作的，而第二种方式更像是一种“语法糖”，我们可以“绕过”Person 类型这一层，直接访问 Person 中的字段。</p><p><strong>Go 语言不支持这种在结构体类型定义中，递归地放入其自身类型字段的定义方式</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第一种</span><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    t T  <br>    ... ...<br>&#125;<br><span class="hljs-comment">// 第二种</span><br><span class="hljs-keyword">type</span> T1 <span class="hljs-keyword">struct</span> &#123;<br>  t2 T2<br>&#125;<br><span class="hljs-keyword">type</span> T2 <span class="hljs-keyword">struct</span> &#123;<br>  t1 T1<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，虽然我们不能在结构体类型 T 定义中，拥有以自身类型 T 定义的字段，但却<strong>可以拥有自身类型的指针类型、以自身类型为元素类型的切片类型，以及以自身类型作为 value 类型的 map 类型的字段</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    t  *T           <span class="hljs-comment">// ok</span><br>    st []T          <span class="hljs-comment">// ok</span><br>    m  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]T <span class="hljs-comment">// ok</span><br>&#125;     <br></code></pre></td></tr></table></figure><h5 id="结构体变量的声明与初始化"><a href="#结构体变量的声明与初始化" class="headerlink" title="结构体变量的声明与初始化"></a>结构体变量的声明与初始化</h5><p>可以使用标准变量声明语句，或者是短变量声明语句声明一个结构体类型的变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">var</span> book Book<br><span class="hljs-keyword">var</span> book = Book&#123;&#125;<br>book := Book&#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>结构体类型的变量通常都要被赋予适当的初始值后，才会有合理的意义。</strong></p><h6 id="零值初始化"><a href="#零值初始化" class="headerlink" title="零值初始化"></a>零值初始化</h6><p>零值初始化说的是使用结构体的类型的默认值作为它的初始值。Go 结构体类型由若干个字段组成，当这个结构体类型变量的各个字段的值都是零值时，我们就说这个结构体类型变量处于零值状态。<br>虽然不是所有结构体的零值初始化有意义，但是如果一种类型采用零值初始化得到的零值变量，是有意义的，而且是直接可用的，我称这种类型为“零值可用”类型。可以说，定义零值可用类型是简化代码、改善开发者使用体验的一种重要的手段。<br>下面这个就是不适合零值初始化，因为没有意义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> book Book <span class="hljs-comment">// book 为零值结构体变量</span><br></code></pre></td></tr></table></figure><p>而在 Go 语言标准库和运行时的代码中，有很多践行“零值可用”理念的好例子，最典型的莫过于 sync 包的 Mutex 类型了。Mutex 是 Go 标准库中提供的、用于多个并发 Goroutine 之间进行同步的互斥锁。</p><p>运用“零值可用”类型，给 Go 语言中的线程互斥锁带来了什么好处呢？对比一下 C 语言就知道了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> mutex; <br>pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br><br>pthread_mutex_lock(&amp;mutex); <br>... ...<br>pthread_mutex_unlock(&amp;mutex); <br></code></pre></td></tr></table></figure><p>在 C 中使用互斥锁，我们需要首先声明一个 mutex 变量。但这个时候，我们不能直接使用声明过的变量，因为它的零值状态是不可用的，我们必须使用 pthread_mutex_init 函数对其进行专门的初始化操作后，它才能处于可用状态。再之后，我们才能进行 lock 与 unlock 操作。<br>但是在 Go 语言中，我们只需要这几行代码就可以了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex<br>mu.Lock()<br>mu.Unlock()<br></code></pre></td></tr></table></figure><p>Go 标准库的设计者很贴心地将 sync. Mutex 结构体的零值状态，设计为可用状态，这样开发者便可直接基于零值状态下的 Mutex 进行 lock 与 unlock 操作，而且不需要额外显式地对它进行初始化操作了。<br>Go 标准库中的 bytes. Buffer 结构体类型，也是一个零值可用类型的典型例子，这里我演示了 bytes. Buffer 类型的常规用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b bytes.Buffer<br>b.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, Go&quot;</span>))<br>fmt.Println(b.String()) <span class="hljs-comment">// 输出：Hello, Go</span><br></code></pre></td></tr></table></figure><p>我们不需要对 bytes. Buffer 类型的变量 b 进行任何显式初始化，就可以直接通过处于零值状态的变量 b，调用它的方法进行写入和读取操作。</p><h6 id="使用复合字面值"><a href="#使用复合字面值" class="headerlink" title="使用复合字面值"></a>使用复合字面值</h6><p>最简单的对结构体变量进行显式初始化的方式，就是按<strong>顺序依次给每个结构体字段进行赋值</strong>，比如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span>              <span class="hljs-comment">// 书名</span><br>    Pages <span class="hljs-type">int</span>                 <span class="hljs-comment">// 书的页数</span><br>    Indexes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>    <span class="hljs-comment">// 书的索引</span><br>&#125;<br><br><span class="hljs-keyword">var</span> book = Book&#123;<span class="hljs-string">&quot;The Go Programming Language&quot;</span>, <span class="hljs-number">700</span>, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)&#125;<br></code></pre></td></tr></table></figure><p>不过这种方式很麻烦，而且一旦结构体中包含非导出字段，那么这种逐一字段赋值的方式就不再被支持了，编译会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    F1 <span class="hljs-type">int</span><br>    F2 <span class="hljs-type">string</span><br>    f3 <span class="hljs-type">int</span><br>    F4 <span class="hljs-type">int</span><br>    F5 <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> t = T&#123;<span class="hljs-number">11</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">13</span>&#125; <span class="hljs-comment">// 错误：implicit assignment of unexported field &#x27;f3&#x27; in T literal</span><br>或<br><span class="hljs-keyword">var</span> t = T&#123;<span class="hljs-number">11</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125; <span class="hljs-comment">// 错误：implicit assignment of unexported field &#x27;f3&#x27; in T literal</span><br></code></pre></td></tr></table></figure><p>Go 语言并不推荐我们按字段顺序对一个结构体类型变量这样进行显式初始化。<br>Go 推荐我们用 <strong>“field: value”形式的复合字面值</strong>，对结构体类型变量进行显式初始化，这种方式可以降低结构体类型使用者和结构体类型设计者之间的耦合，这也是 Go 语言的惯用法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t = T&#123;<br>    F2: <span class="hljs-string">&quot;hello&quot;</span>,<br>    F1: <span class="hljs-number">11</span>,<br>    F4: <span class="hljs-number">14</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>复合字面值作为结构体类型变量初值被广泛使用，即便结构体采用类型零值时，我们也会使用复合字面值的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">t := T&#123;&#125;<br></code></pre></td></tr></table></figure><p>而比较少使用 new 这一个 Go 预定义的函数来创建结构体变量实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">tp := <span class="hljs-built_in">new</span>(T)<br></code></pre></td></tr></table></figure><p>如果一个结构体类型中包含未导出字段，并且这个字段的零值还不可用时，我们要如何初始化这个结构体类型的变量呢？又或是一个结构体类型中的某些字段，需要一个复杂的初始化逻辑，我们又该怎么做呢？这时我们就需要使用一个特定的构造函数，来创建并初始化结构体变量了。</p><h6 id="使用特定的构造函数"><a href="#使用特定的构造函数" class="headerlink" title="使用特定的构造函数"></a>使用特定的构造函数</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/time/sleep.go</span><br><span class="hljs-keyword">type</span> runtimeTimer <span class="hljs-keyword">struct</span> &#123;<br>    pp       <span class="hljs-type">uintptr</span><br>    when     <span class="hljs-type">int64</span><br>    period   <span class="hljs-type">int64</span><br>    f        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">uintptr</span>)</span></span> <br>    arg      <span class="hljs-keyword">interface</span>&#123;&#125;<br>    seq      <span class="hljs-type">uintptr</span><br>    nextwhen <span class="hljs-type">int64</span><br>    status   <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Timer <span class="hljs-keyword">struct</span> &#123;<br>    C &lt;-<span class="hljs-keyword">chan</span> Time<br>    r runtimeTimer<br>&#125;<br><br><span class="hljs-comment">// $GOROOT/src/time/sleep.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTimer</span><span class="hljs-params">(d Duration)</span></span> *Timer &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Time, <span class="hljs-number">1</span>)<br>    t := &amp;Timer&#123;<br>        C: c,<br>        r: runtimeTimer&#123;<br>            when: when(d),<br>            f:    sendTime,<br>            arg:  c,<br>        &#125;,<br>    &#125;<br>    startTimer(&amp;t.r)<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><p>NewTimer 这个函数只接受一个表示定时时间的参数 d，在经过一个复杂的初始化过程后，它返回了一个处于可用状态的 Timer 类型指针实例。<br>专用构造函数大多都符合以下模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewT</span><span class="hljs-params">(field1, field2, ...)</span></span> *T &#123;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>NewT 是结构体类型 T 的专用构造函数，它的参数列表中的参数通常与 T 定义中的导出字段相对应，返回值则是一个 T 指针类型的变量。T 的非导出字段在 NewT 内部进行初始化，一些需要复杂初始化逻辑的字段也会在 NewT 内部完成初始化。这样，我们只要调用 NewT 函数就可以得到一个可用的 T 指针类型变量了。</p><h5 id="结构体类型的内存布局（内存对齐）"><a href="#结构体类型的内存布局（内存对齐）" class="headerlink" title="结构体类型的内存布局（内存对齐）"></a>结构体类型的内存布局（内存对齐）</h5><p>我们可以借助标准库 unsafe 包提供的函数，获得结构体类型变量占用的内存大小，以及它每个字段在内存中相对于结构体变量起始地址的偏移量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t T<br>unsafe.Sizeof(t)      <span class="hljs-comment">// 结构体类型变量占用的内存大小</span><br>unsafe.Offsetof(t.Fn) <span class="hljs-comment">// 字段Fn在内存中相对于变量t起始地址的偏移量</span><br></code></pre></td></tr></table></figure><p>![[【Go基础】未整理合集&#x2F;Pasted image 20230214104520.png]]<br>在真实情况下，虽然 Go 编译器没有在结构体变量占用的内存空间中插入额外字段，但结构体字段实际上可能并不是紧密相连的，中间可能存在“缝隙”。这些“缝隙”同样是结构体变量占用的内存空间的一部分，它们是 Go 编译器插入的“填充物（Padding）”。<br>这因为需要<strong>内存对齐</strong>。所谓内存对齐，指的就是各种内存对象的内存地址不是随意确定的，必须满足特定要求。<br>对于各种基本数据类型来说，它的变量的内存地址值必须是其类型本身大小的整数倍，比如，一个 int64 类型的变量的内存地址，应该能被 int64 类型自身的大小，也就是 8 整除；一个 uint16 类型的变量的内存地址，应该能被 uint16 类型自身的大小，也就是 2 整除。<br>对于结构体而言，它的变量的内存地址，只要是它最长字段长度与系统对齐系数两者之间较小的那个的整数倍就可以了。但对于结构体类型来说，我们还要让它每个字段的内存地址都严格满足内存对齐要求。(省略了一些内存对齐的计算过程) 总结就是：结构体不仅内部字段需要进行内存对齐，结构体整体也要对齐，为了结构体整体的对齐，结构体尾部也会有些填充。</p><p>**Go 语言中结构体类型的大小受内存对齐约束的影响。**不同的字段排列顺序也会影响到“填充字节”的多少，从而影响到整个结构体大小。比如下面两个结构体类型表示的抽象是相同的，但正是因为字段排列顺序不同，导致它们的大小也不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    b <span class="hljs-type">byte</span><br>    i <span class="hljs-type">int64</span><br>    u <span class="hljs-type">uint16</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>    b <span class="hljs-type">byte</span><br>    u <span class="hljs-type">uint16</span><br>    i <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-built_in">println</span> (unsafe. Sizeof (t)) <span class="hljs-comment">// 24</span><br>    <span class="hljs-keyword">var</span> s S<br>    <span class="hljs-built_in">println</span>(unsafe.Sizeof(s)) <span class="hljs-comment">// 16</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了节省内存占用，当前结构体类型声明时须自行排位字段。总体原则是要么由小到大，要么由大到小，保持有序，避免随意排列。可以用 unsafe. Alignof 查看各类型的对齐系数。</p><p>通常的内存填充部分，是由编译器自动完成的。不过，有些时候，为了保证某个字段的内存地址有更为严格的约束，我们也会做主动填充。比如 runtime 包中的 mstats 结构体定义就采用了主动填充：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/runtime/mstats.go</span><br><span class="hljs-keyword">type</span> mstats <span class="hljs-keyword">struct</span> &#123;<br>    ... ...<br>    <span class="hljs-comment">// Add an uint32 for even number of size classes to align below fields</span><br>    <span class="hljs-comment">// to 64 bits for atomic operations on 32 bit platforms.</span><br>    _ [<span class="hljs-number">1</span> - _NumSizeClasses%<span class="hljs-number">2</span>]<span class="hljs-type">uint32</span> <span class="hljs-comment">// 这里做了主动填充</span><br><br>    last_gc_nanotime <span class="hljs-type">uint64</span> <span class="hljs-comment">// last gc (monotonic time)</span><br>    last_heap_inuse  <span class="hljs-type">uint64</span> <span class="hljs-comment">// heap_inuse at mark termination of the previous GC</span><br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体类型是既数组类型之后，又一个以平铺形式存放在连续内存块中的类型。不过与数组类型不同，由于内存对齐的要求，结构体类型各个相邻字段间可能存在“填充物”，结构体的尾部同样可能被 Go 编译器填充额外的字节，满足结构体整体对齐的约束。</p><h5 id="扩展阅读-2"><a href="#扩展阅读-2" class="headerlink" title="扩展阅读"></a>扩展阅读</h5><p><a href="https://geektutu.com/post/hpg-struct-alignment.html">Go struct 内存对齐 | Go 语言高性能编程 | 极客兔兔</a><br><a href="https://segmentfault.com/a/1190000017527311">php - 在 Go 中恰到好处的内存对齐 - 煎鱼的清汤锅 - SegmentFault 思否</a></p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>Go 提供了 if 和 switch-case 两种语句形式；而针对循环结构，Go 只保留了 for 这一种循环语句形式。<br>在 C 语言基础上 Go 的改进点：</p><ul><li>Go 坚持“一件事情仅有一种做法的理念”，只保留了 for 这一种循环结构，去掉了 C 语言中的 while 和 do-while 循环结构；</li><li>Go 填平了 C 语言中 switch 分支结构中每个 case 语句都要以 break 收尾的“坑”；</li><li>Go 支持了 type switch 特性，让“类型”信息也可以作为分支选择的条件；</li><li>Go 的 switch 控制结构的 case 语句还支持表达式列表，让相同处理逻辑的多个分支可以合并为一个分支，等等。</li></ul><h3 id="If-分支结构"><a href="#If-分支结构" class="headerlink" title="If 分支结构"></a>If 分支结构</h3><p><strong>虽然各种编程语言几乎都原生支持了 if 语句，但 Go 的 if 语句依然有着自己的特点：</strong><br>第一，和 Go 函数一样，if 语句的分支代码块的左大括号与 if 关键字在同一行上，这也是 Go 代码风格的统一要求，gofmt 工具会帮助我们实现这一点；<br>第二，if 语句的布尔表达式整体不需要用括号包裹，一定程度上减少了开发人员敲击键盘的次数。而且，if 关键字后面的条件判断表达式的求值结果必须是布尔类型，即要么是 true，要么是 false：</p><p>会用到的一些操作符：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230214130331.png]]<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230214130423.png]]<br>如果记不住优先级顺序也没有关系的，使用带有小括号的子布尔表达式来清晰地表达判断条件就可以。<br><strong>多分枝结构</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> boolean_expression1 &#123;<br>  <span class="hljs-comment">// 分支1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> boolean_expression2 &#123;<br>  <span class="hljs-comment">// 分支2</span><br>... ...<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> boolean_expressionN &#123;<br>  <span class="hljs-comment">// 分支N</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 分支N+1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以在 if 后的布尔表达式前，进行一些变量的声明，这些变量只可以在 if 语句的代码块范围内使用，比如下面代码中的变量 a、b 和 c：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a, c := f(), h(); a &gt; <span class="hljs-number">0</span> &#123;<span class="hljs-comment">//由于声明本身是一个语句，所以我们需要把它和后面的布尔表达式通过分号分隔开。</span><br>        <span class="hljs-built_in">println</span>(a)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> b := f(); b &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println</span>(a, b)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println</span>(a, b, c)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="if-语句的“快乐路径”原则"><a href="#if-语句的“快乐路径”原则" class="headerlink" title="if 语句的“快乐路径”原则"></a>if 语句的“快乐路径”原则</h5><p>从可读性上来看，单分支结构要优于二分支结构，二分支结构又优于多分支结构。那么显然，我们在日常编码中要减少多分支结构，甚至是二分支结构的使用，这会有助于我们编写出优雅、简洁、易读易维护且不易错的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">//伪代码段1：</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">if</span> errorCondition1 &#123;<br>    <span class="hljs-comment">// some error logic</span><br>    ... ...<br>    <span class="hljs-keyword">return</span> err1<br>  &#125;<br>  <br>  <span class="hljs-comment">// some success logic</span><br>  ... ...<br><br>  <span class="hljs-keyword">if</span> errorCondition2 &#123;<br>    <span class="hljs-comment">// some error logic</span><br>    ... ...<br>    <span class="hljs-keyword">return</span> err2<br>  &#125;<br><br>  <span class="hljs-comment">// some success logic</span><br>  ... ...<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 伪代码段 2：</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-keyword">if</span> successCondition1 &#123;<br>    <span class="hljs-comment">// some success logic</span><br>    ... ...<br><br>    <span class="hljs-keyword">if</span> successCondition2 &#123;<br>      <span class="hljs-comment">// some success logic</span><br>      ... ...<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// some error logic</span><br>      ... ...<br>      <span class="hljs-keyword">return</span> err2<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// some error logic</span><br>    ... ...<br>    <span class="hljs-keyword">return</span> err1<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的伪代码 1 比伪代码 2 易读。Go 社区把伪代码 1 的 if 语句的使用方式称为 if 语句的“<strong>快乐路径（Happy Path）</strong>”原则，所谓“快乐路径”也就是成功逻辑的代码执行路径，它的特点是这样的：</p><ul><li>仅使用单分支控制结构；</li><li>当布尔表达式求值为 false 时，也就是出现错误时，在单分支中快速返回；</li><li>正常逻辑在代码布局上始终“靠左”，这样读者可以从上到下一眼看到该函数正常逻辑的全貌；</li><li>函数执行到最后一行代表一种成功状态。<br>Go 社区推荐 Gopher 们在使用 if 语句时尽量符合这些原则，如果你的函数实现代码不符合“快乐路径”原则，你可以按下面步骤进行重构：</li><li>尝试将“正常逻辑”提取出来，放到“快乐路径”中；</li><li>如果无法做到上一点，很可能是函数内的逻辑过于复杂，可以将深度缩进到 else 分支中的代码析出到一个函数中，再对原函数实施“快乐路径”原则。</li></ul><h3 id="For-循环结构"><a href="#For-循环结构" class="headerlink" title="For 循环结构"></a>For 循环结构</h3><p>Go 只有 for 循环。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230214163055.png]]<br>在 C 语言基础上的突破和创新：<strong>Go 语言的 for 循环支持声明多循环变量，并且可以应用在循环体以及判断条件中</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, j, k := <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>; (i &lt; <span class="hljs-number">20</span>) &amp;&amp; (j &lt; <span class="hljs-number">10</span>) &amp;&amp; (k &lt; <span class="hljs-number">30</span>); i, j, k = i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>, k+<span class="hljs-number">5</span> &#123;<br>    sum += (i + j + k)<br>    <span class="hljs-built_in">println</span> (sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 for 循环中，循环体是必须，其他都可以省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10</span>; i++&#123;<br>    <span class="hljs-built_in">println</span>(i)<br>&#125;  <br><br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-built_in">println</span>(i)<br>    i++<br>&#125;  <br><br><br><span class="hljs-keyword">for</span> &#123; <br>   <span class="hljs-comment">// 循环体代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="for-range-循环形式"><a href="#for-range-循环形式" class="headerlink" title="for range 循环形式"></a>for range 循环形式</h5><p>Go 语言提供了一个方便的“语法糖”形式：for range</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;sl[%d] = %d\n&quot;</span>, i, sl[i])<br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> sl &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;sl[%d] = %d\n&quot;</span>, i, v)<br>&#125;<br><span class="hljs-comment">//　i和v分别为sl的下标值和元素值</span><br></code></pre></td></tr></table></figure><h6 id="For-range-的变种"><a href="#For-range-的变种" class="headerlink" title="For range 的变种"></a>For range 的变种</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//当我们不关心元素的值时，我们可以省略代表元素值的变量 v，只声明代表下标值的变量 i：</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br><br><span class="hljs-comment">// 如果我们不关心元素下标，只关心元素值，那么我们可以用空标识符替代代表下标值的变量 i。</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br><br><span class="hljs-comment">//既不关心下标值，也不关心元素值</span><br><span class="hljs-keyword">for</span> _, _ = <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br>或者更优雅的<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="一些类型的遍历"><a href="#一些类型的遍历" class="headerlink" title="一些类型的遍历"></a>一些类型的遍历</h6><p><strong>string 类型</strong><br>使用 for 经典形式与使用 for range 形式，对 string 类型进行循环操作的语义是不同的<br>for range 对于 string 类型来说，每次循环得到的 v 值是一个 <strong>Unicode 字符码点</strong>，也就是 rune 类型值，而不是一个字节，返回的第一个值 i 为该 Unicode 字符码点的内存编码（UTF-8）的第一个字节在字符串内存序列中的位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%d %s 0x%x\n&quot;</span>, i, <span class="hljs-type">string</span>(v), v)<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">0</span> 中 <span class="hljs-number">0x4e2d</span><br><span class="hljs-number">3</span> 国 <span class="hljs-number">0x56fd</span><br><span class="hljs-number">6</span> 人 <span class="hljs-number">0x4eba</span><br><span class="hljs-comment">//返回的 i 为该 Unicode 字符码点的内存编码（UTF-8）的字节在字符串内存序列中的位置。</span><br><span class="hljs-comment">//v 值是一个Unicode 字符码点</span><br></code></pre></td></tr></table></figure><p><strong>map</strong><br><strong>要对 map 进行循环操作，for range 是唯一的方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;Rob&quot;</span> : <span class="hljs-number">67</span>,<br>    <span class="hljs-string">&quot;Russ&quot;</span> : <span class="hljs-number">39</span>,<br>    <span class="hljs-string">&quot;John&quot;</span> : <span class="hljs-number">29</span>,<br>&#125;<br><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-built_in">println</span> (k, v)<br>&#125;<br><span class="hljs-comment">//输出</span><br>John <span class="hljs-number">29</span><br>Rob <span class="hljs-number">67</span><br>Russ <span class="hljs-number">39</span><br></code></pre></td></tr></table></figure><p><strong>channel</strong><br><strong>channel 是 Go 语言提供的并发设计的原语，它用于多个 Goroutine 之间的通信</strong><br>当 channel 类型变量作为 for range 语句的迭代对象时，for range 会尝试从 channel 中读取数据，使用形式是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> c &#123;<br>   <span class="hljs-comment">// ... </span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，for range 每次从 channel 中读取一个元素后，会把它赋值给循环变量 v，并进入循环体。当 channel 中没有数据可读的时候，for range 循环会阻塞在对 channel 的读操作上。直到 channel 关闭时，for range 循环才会结束，这也是 for range 循环与 channel 配合时隐含的循环判断条件。</p><h4 id="带-label-的-continue-语句"><a href="#带-label-的-continue-语句" class="headerlink" title="带 label 的 continue 语句"></a>带 label 的 continue 语句</h4><p>Go 语言中的 continue 在 C 语言 continue 语义的基础上又增加了对 label 的支持。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><br>loop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">if</span> sl[i]%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 忽略切片中值为偶数的元素</span><br>            <span class="hljs-keyword">continue</span> loop<br>        &#125;<br>        sum += sl[i]<br>    &#125;<br>    <span class="hljs-built_in">println</span>(sum) <span class="hljs-comment">// 9</span><br>&#125;<br></code></pre></td></tr></table></figure><p>带 label 的 continue 语句，通常出现于嵌套循环语句中，被<strong>用于跳转到外层循环并继续执行外层循环语句的下一个迭代</strong>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sl = [][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">26</span>, <span class="hljs-number">35</span>, <span class="hljs-number">78</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">45</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">99</span>&#125;,<br>        &#123;<span class="hljs-number">101</span>, <span class="hljs-number">13</span>, <span class="hljs-number">38</span>, <span class="hljs-number">7</span>, <span class="hljs-number">127</span>&#125;,<br>        &#123;<span class="hljs-number">54</span>, <span class="hljs-number">27</span>, <span class="hljs-number">40</span>, <span class="hljs-number">83</span>, <span class="hljs-number">81</span>&#125;,<br>    &#125;<br><br>outerloop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span> (sl); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(sl[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> sl[i][j] == <span class="hljs-number">13</span> &#123;<br>                fmt.Printf(<span class="hljs-string">&quot;found 13 at [%d, %d]\n&quot;</span>, i, j)<br>                <span class="hljs-keyword">continue</span> outerloop<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码段的逻辑就是在 sl 的每个元素切片中找到 13 这个数字，并输出它的具体位置信息。<br>它和 goto 是有区别的，如果换成 goto 那么不管是内层循环还是外层循环都会被终结，代码将会从 outerloop 这个 label 处，开始重新执行我们的嵌套循环语句，这与带 label 的 continue 的跳转语义是完全不同的。<br><strong>go 保留了 goto 但是最好不要用</strong></p><h4 id="break-语句的使用"><a href="#break-语句的使用" class="headerlink" title="break 语句的使用"></a>break 语句的使用</h4><p>Break 用于彻底跳出循环，和 continue 语句一样，break 语句增加了对 label 的支持。<br>而且，和前面 continue 语句一样，如果遇到嵌套循环，break 要想跳出外层循环，用不带 label 的 break 是不够，因为不带 label 的 break 仅能跳出其所在的最内层循环。要想实现外层循环的跳出，我们还需给 break 加上 label。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> gold = <span class="hljs-number">38</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sl = [][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">26</span>, <span class="hljs-number">35</span>, <span class="hljs-number">78</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">45</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">99</span>&#125;,<br>        &#123;<span class="hljs-number">101</span>, <span class="hljs-number">13</span>, <span class="hljs-number">38</span>, <span class="hljs-number">7</span>, <span class="hljs-number">127</span>&#125;,<br>        &#123;<span class="hljs-number">54</span>, <span class="hljs-number">27</span>, <span class="hljs-number">40</span>, <span class="hljs-number">83</span>, <span class="hljs-number">81</span>&#125;,<br>    &#125;<br><br>outerloop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(sl[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> sl[i][j] == gold &#123;<br>                fmt.Printf(<span class="hljs-string">&quot;found gold at [%d, %d]\n&quot;</span>, i, j)<br>                <span class="hljs-keyword">break</span> outerloop<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 sl 这个二维切片中找到 38 这个数字，并输出它的位置信息。整个二维切片中至多有一个值为 38 的元素，所以只要我们通过嵌套循环发现了 38，我们就不需要继续执行这个循环了。这时，我们通过带有 label 的 break 语句，就可以直接终结外层循环，从而从复杂多层次的嵌套循环中直接跳出，避免不必要的算力资源的浪费。</p><p>(感覺上面的这两个例子都可以直接用多个 continue 或者 break 就可以直接实现了。)</p><h4 id="for-语句的常见“坑”与避坑方法"><a href="#for-语句的常见“坑”与避坑方法" class="headerlink" title="for 语句的常见“坑”与避坑方法"></a>for 语句的常见“坑”与避坑方法</h4><h5 id="问题一：循环变量的重用"><a href="#问题一：循环变量的重用" class="headerlink" title="问题一：循环变量的重用"></a>问题一：循环变量的重用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;  <br>             <br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>            fmt.Println(i, v)<br>        &#125;()<br>    &#125;<br><br>    time.Sleep(time.Second * <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>示例是对一个整型切片进行遍历，并且在每次循环体的迭代中都会创建一个新的 Goroutine（Go 中的轻量级协程），输出这次迭代的元素的下标值与元素值。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">//预期结果</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-comment">//实际结果</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>i，v 在 for range 语句中仅会被声明一次，且在每次迭代中都会被重用。而不会次迭代都会重新声明两个新的变量 i 和 v。<br>出现与预期结果不符合的原因为：Goroutine 执行的闭包函数引用了它的外层包裹函数中的变量 i、v，这样，变量 i、v 在主 Goroutine 和新启动的 Goroutine 之间实现了共享，而 i, v 值在整个循环过程中是<strong>重用</strong>的，仅有一份。在 for range 循环结束后，i &#x3D; 4, v &#x3D; 5，因此各个 Goroutine 在等待 3 秒后进行输出的时候，输出的是 i, v 的最终值。</p><p>与预期相符的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, v <span class="hljs-type">int</span>)</span></span> &#123;<br>            time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>            fmt.Println(i, v)<br>        &#125;(i, v)<br>    &#125;<br><br>    time.Sleep(time.Second * <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="问题二：参与循环的是-range-表达式的副本"><a href="#问题二：参与循环的是-range-表达式的副本" class="headerlink" title="问题二：参与循环的是 range 表达式的副本"></a>问题二：参与循环的是 range 表达式的副本</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    <span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br>    fmt.Println(<span class="hljs-string">&quot;original a =&quot;</span>, a)<br><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>            a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>            a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>        &#125;<br>        r[i] = v<br>    &#125;<br><br>    fmt. Println (<span class="hljs-string">&quot;after for range loop, r =&quot;</span>, r)<br>    fmt.Println(<span class="hljs-string">&quot;after for range loop, a =&quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//预计输出</span><br>original a = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>after <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> loop, r = [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>after <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> loop, a = [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br><span class="hljs-comment">//实际输出</span><br>original a = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>after <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> loop, r = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]  <span class="hljs-comment">//这里很奇怪，r与未修改的a相同，而不是修改后的</span><br>after <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> loop, a = [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>发生这个误差的原因就是参与 for range 循环的是 range 表达式的副本，而不是它本身。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> aa &#123; <span class="hljs-comment">//aa是a的一个值拷贝</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>        a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>        a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>    &#125;<br>    r[i] = v<br>&#125;<br></code></pre></td></tr></table></figure><p>每次迭代的都是从数组 a 的值拷贝 a’中得到的元素。aa 是 Go 临时分配的连续字节序列，与 a 完全不是一块内存区域。因此无论 a 被如何修改，它参与循环的副本 aa 依旧保持原值，因此 v 从 aa 中取出的仍旧是 a 的原值，而不是修改后的值。</p><p><strong>避免方法就是使用切片</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    <span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br>    fmt.Println(<span class="hljs-string">&quot;original a =&quot;</span>, a)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a[:] &#123;  <span class="hljs-comment">//使用切片后，实际输出就和预期输出一样了 </span><br>    <span class="hljs-comment">//换成传数组地址&amp;a也行。</span><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>            a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>            a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>        &#125;<br>        r[i] = v<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;after for range loop, r =&quot;</span>, r)<br>    fmt.Println(<span class="hljs-string">&quot;after for range loop, a =&quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p>当进行 range 表达式复制时，我们实际上复制的是一个切片，也就是表示切片的结构体。表示切片副本的结构体中的 array，依旧指向原切片对应的底层数组，所以我们对切片副本的修改也都会反映到底层数组 a 上去。而 v 再从切片副本结构体中 array 指向的底层数组中，获取数组元素，也就得到了被修改后的元素值。</p><h5 id="问题三：遍历-map-中元素的随机性"><a href="#问题三：遍历-map-中元素的随机性" class="headerlink" title="问题三：遍历 map 中元素的随机性"></a>问题三：遍历 map 中元素的随机性</h5><p>如果我们在循环的过程中，对 map 进行了修改，那么这样修改的结果是否会影响后续迭代呢？<br>这个结果和我们遍历 map 一样，具有随机性。<br>这是因为对 map 迭代的实质是按顺序逐个 bucket 的遍历, 每个 bucket 也是逐个遍历其中的 key。如果在中途创建或删除的元素在第一个被遍历的元素之前了，那么后续就不会遍历它了。别忘了，key 存储在哪里是根据 hash 值来定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//例子一</span><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-string">&quot;tony&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-string">&quot;tom&quot;</span>:  <span class="hljs-number">22</span>,<br>    <span class="hljs-string">&quot;jim&quot;</span>:  <span class="hljs-number">23</span>,<br>&#125;<br><br>counter := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;tony&quot;</span>)<br>    &#125;<br>    counter++<br>    fmt.Println(k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;counter is &quot;</span>, counter)<br><br><span class="hljs-comment">//例子二</span><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-string">&quot;tony&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-string">&quot;tom&quot;</span>:  <span class="hljs-number">22</span>,<br>    <span class="hljs-string">&quot;jim&quot;</span>:  <span class="hljs-number">23</span>,<br>&#125;<br><br>counter := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123;<br>        m[<span class="hljs-string">&quot;lucy&quot;</span>] = <span class="hljs-number">24</span><br>    &#125;<br>    counter++<br>    fmt.Println(k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;counter is &quot;</span>, counter)<br></code></pre></td></tr></table></figure><p>以上的两个例子，运行的话都会有两个结果。</p><h3 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a>switch 结构</h3><p>暂时跳过</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数是唯一一种基于特定输入，实现特定任务并可返回任务执行结果的代码块（Go 语言中的方法本质上也是函数）</strong></p><h3 id="Go-函数与函数声明"><a href="#Go-函数与函数声明" class="headerlink" title="Go 函数与函数声明"></a>Go 函数与函数声明</h3><p><strong>普通 Go 函数的声明：</strong><br>![[【Go基础】未整理合集&#x2F;Pasted image 20230219191355.png]]</p><p>包含五个部分：</p><ul><li><strong>关键字 func</strong>，必需要以 func 开头</li><li><strong>函数名</strong>，在同一个 Go 包中，函数名应该是唯一的，遵守 Go 标识符的导出规则（首字母大小写）</li><li><strong>参数列表</strong>，参数列表紧接在函数名的后面，并用一个括号包裹，使用逗号作为参数间的分隔符</li><li><strong>返回值列表</strong>，返回值列表的位置紧接在参数列表后面，两者之间用一个空格隔开，Go 中不仅声明返回值的类型，还可以声明返回值的名称，声明名称的这种叫做<strong>具名返回值</strong></li><li><strong>函数体 (可选)</strong>，如果没有函数体，说明这个函数可能是在 Go 语言之外实现的</li></ul><p>把函数声明等价转换为变量声明的形式如下，可以发现：</p><ul><li>函数名其实就是变量名</li><li>函数声明中的 func 关键字、参数列表和返回值列表共同构成了<strong>函数类型</strong></li><li>参数列表与返回值列表的组合也被称为<strong>函数签名</strong></li><li><strong>函数签名</strong>是决定两个函数类型是否相同的决定因素。因此，函数类型也可以看成是由 func 关键字与函数签名组合而成的。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230219192429.png]]</li></ul><p>如果两个函数类型的函数签名是相同的，即便参数列表中的参数名，以及返回值列表中的返回值变量名都是不同的，那么这两个函数类型也是相同类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">string</span>)</span></span> (results []<span class="hljs-type">string</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c <span class="hljs-type">int</span>, d <span class="hljs-type">string</span>)</span></span> (sl []<span class="hljs-type">string</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-comment">//以上两个函数的函数签名相同，他们是相同类型的函数。</span><br></code></pre></td></tr></table></figure><p><strong>每个函数声明所定义的函数，仅仅是对应的函数类型的一个实例</strong>，就像 var a int &#x3D; 13 这个变量声明语句中 a 是 int 类型的一个实例一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := T&#123;&#125;      <span class="hljs-comment">// 使用复合类型字面值对结构体类型 T 的变量进行显式初始化</span><br>f := <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">// 使用变量声明形式的函数声明 这就是匿名函数</span><br></code></pre></td></tr></table></figure><p>上面的第二行特别像一个没有函数名的函数声明，因此我们叫它<strong>匿名函数</strong></p><h3 id="关于函数的参数"><a href="#关于函数的参数" class="headerlink" title="关于函数的参数"></a>关于函数的参数</h3><p>当我们实际调用函数的时候，实参会传递给函数，并和形式参数逐一绑定，编译器会根据各个形参的类型与数量，来检查传入的实参的类型与数量是否匹配。只有匹配，程序才能继续执行函数调用，否则编译器就会报错。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230219193032.png]]<br>】<br>Go 语言中，函数参数传递采用是<strong>值传递</strong>的方式。所谓“值传递”，就是将实际参数在内存中的表示逐位拷贝（Bitwise Copy）到形式参数中。<br>对于像整型、数组、结构体这类类型，它们的内存表示就是它们自身的数据内容，因此当这些类型作为实参类型时，值传递拷贝的就是它们自身，传递的开销也与它们自身的大小成正比。<br>但是像 string、切片、map 这些类型就不是了，它们的内存表示对应的是它们数据内容的“描述符”。当这些类型作为实参类型时，值传递拷贝的也是它们数据内容的“描述符”，不包括数据内容本身，所以这些类型传递的开销是固定的，与数据内容大小无关。这种只拷贝“描述符”，不拷贝实际数据内容的拷贝过程，也被称为“<strong>浅拷贝</strong>”。</p><p>不过函数参数的传递也有两个例外，当函数的形参为接口类型，或者形参是变长参数时，简单的值传递就不能满足要求了，这时 Go 编译器会介入：对于类型为接口类型的形参，Go 编译器会把传递的实参赋值给对应的接口类型形参；对于为变长参数的形参，Go 编译器会将零个或多个实参按一定形式转换为对应的变长形参。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAppend</span><span class="hljs-params">(sl []<span class="hljs-type">int</span>, elems ...<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, elems) <span class="hljs-comment">// []int   所以elems是个切片</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;no elems to append&quot;</span>)<br>        <span class="hljs-keyword">return</span> sl<br>    &#125;<br>    sl = <span class="hljs-built_in">append</span>(sl, elems...)<br>    <span class="hljs-keyword">return</span> sl<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    sl := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    sl = myAppend(sl) <span class="hljs-comment">// no elems to append</span><br>    fmt.Println(sl) <span class="hljs-comment">// [1 2 3]</span><br>    sl = myAppend(sl, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>    fmt.Println(sl) <span class="hljs-comment">// [1 2 3 4 5 6]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Go 中，<strong>变长参数实际上是通过切片来实现的</strong>。所以，我们在函数体中，就可以使用切片支持的所有操作来操作变长参数，这会大大简化了变长参数的使用复杂度。</p><h3 id="函数的多返回值"><a href="#函数的多返回值" class="headerlink" title="函数的多返回值"></a>函数的多返回值</h3><p>和其他主流静态类型语言，比如 C、C++ 和 Java 不同，Go 函数支持多返回值。多返回值可以让函数将更多结果信息返回给它的调用者。Go 语言的错误处理机制很大程度就是建立在多返回值的机制之上。<br>函数返回值列表从形式上看主要有三种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>                       <span class="hljs-comment">// 无返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>                 <span class="hljs-comment">// 仅有一个返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">string</span>, <span class="hljs-type">error</span>)  <span class="hljs-comment">// 有2或2个以上返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> (n <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>,err <span class="hljs-type">error</span>)  <span class="hljs-comment">// 多个具名返回值</span><br></code></pre></td></tr></table></figure><p>带有名字的返回值被称为<strong>具名返回值（Named Return Value）</strong>。<strong>这种具名返回值变量可以像函数体中声明的局部变量一样在函数体内使用。</strong><br>当函数的返回值个数较多时，每次显式使用 return 语句时都会接一长串返回值，这时，我们用具名返回值可以让函数实现的可读性更好一些</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/time/format.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseNanoseconds</span><span class="hljs-params">(value <span class="hljs-type">string</span>, nbytes <span class="hljs-type">int</span>)</span></span> (ns <span class="hljs-type">int</span>, rangeErrString <span class="hljs-type">string</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> !commaOrPeriod(value[<span class="hljs-number">0</span>]) &#123;<br>        err = errBad<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> ns, err = atoi(value[<span class="hljs-number">1</span>:nbytes]); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> ns &lt; <span class="hljs-number">0</span> || <span class="hljs-number">1e9</span> &lt;= ns &#123;<br>        rangeErrString = <span class="hljs-string">&quot;fractional second&quot;</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    scaleDigits := <span class="hljs-number">10</span> - nbytes<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; scaleDigits; i++ &#123;<br>        ns *= <span class="hljs-number">10</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数是“一等公民”（Go-函数的特征）"><a href="#函数是“一等公民”（Go-函数的特征）" class="headerlink" title="函数是“一等公民”（Go 函数的特征）"></a>函数是“一等公民”（Go 函数的特征）</h4><p><strong>一等公民的含义</strong>：如果一门编程语言对某种语言元素的创建和使用没有限制，我们可以像对待值（value）一样对待这种语法元素，那么我们就称这种语法元素是这门编程语言的“一等公民”。拥有“一等公民”待遇的语法元素可以存储在变量中，可以作为参数传递给函数，可以在函数内部创建并可以作为返回值从函数返回。</p><h5 id="特征一：Go-函数可以存储在变量中。"><a href="#特征一：Go-函数可以存储在变量中。" class="headerlink" title="特征一：Go 函数可以存储在变量中。"></a>特征一：Go 函数可以存储在变量中。</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    myFprintf = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w io.Writer, format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>        <span class="hljs-keyword">return</span> fmt.Fprintf(w, format, a...)<br>    &#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, myFprintf) <span class="hljs-comment">// func(io.Writer, string, ...interface &#123;&#125;) (int, error)</span><br>    myFprintf(os.Stdout, <span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Hello, Go&quot;</span>) <span class="hljs-comment">// 输出Hello，Go 和上一行的效果一致</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们把新创建的一个匿名函数赋值给了一个名为 myFprintf 的变量，通过这个变量，我们便可以调用刚刚定义的匿名函数。</p><h5 id="特征二：支持在函数内创建并通过返回值返回。"><a href="#特征二：支持在函数内创建并通过返回值返回。" class="headerlink" title="特征二：支持在函数内创建并通过返回值返回。"></a>特征二：支持在函数内创建并通过返回值返回。</h5><p>Go 函数不仅可以在函数外创建，还可以在函数内创建。而且由于函数可以存储在变量中，所以函数也可以在创建后，作为函数返回值返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span> <span class="hljs-params">(task <span class="hljs-type">string</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span> (<span class="hljs-string">&quot;do some setup stuff for&quot;</span>, task)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;do some teardown stuff for&quot;</span>, task)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    teardown := setup(<span class="hljs-string">&quot;demo&quot;</span>)<br>    <span class="hljs-keyword">defer</span> teardown()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;do some bussiness stuff&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子，模拟了执行一些重要逻辑之前的上下文建立（setup），以及之后的上下文拆除（teardown）。在一些单元测试的代码中，我们也经常会在执行某些用例之前，建立此次执行的上下文（setup），并在这些用例执行后拆除上下文（teardown），避免这次执行对后续用例执行的干扰。<br>在这个例子中，我们在 setup 函数中创建了这次执行的上下文拆除函数，并通过返回值的形式，将这个拆除函数返回给了 setup 函数的调用者。setup 函数的调用者，在执行完对应这次执行上下文的重要逻辑后，再调用 setup 函数返回的拆除函数，就可以完成对上下文的拆除了。<br><strong>(这部分不是很懂啊)</strong><br>setup 函数中创建的拆除函数也是一个匿名函数，但和前面我们看到的匿名函数有一个不同，这个不同就在于这个匿名函数使用了定义它的函数 setup 的局部变量 task，这样的匿名函数在 Go 中也被称为<strong>闭包（Closure）。</strong></p><p><strong>闭包</strong>本质上就是一个匿名函数或叫函数字面值，它们可以引用它的包裹函数，也就是创建它们的函数中定义的变量。然后，这些变量在包裹函数和匿名函数之间共享，只要闭包可以被访问，这些共享的变量就会继续存在。</p><h5 id="特征三：作为参数传入函数。"><a href="#特征三：作为参数传入函数。" class="headerlink" title="特征三：作为参数传入函数。"></a>特征三：作为参数传入函数。</h5><p>既然函数可以存储在变量中，也可以作为返回值返回，那我们可以理所当然地想到，把函数作为参数传入函数也是可行的。<br>这里通过 AfterFunc 函数设置了一个 2 秒的定时器，并传入了时间到了后要执行的函数。这里传入的就是一个匿名函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">time.AfterFunc(time.Second*<span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;timer fired&quot;</span>) &#125;)<br></code></pre></td></tr></table></figure><h5 id="特征四：拥有自己的类型。"><a href="#特征四：拥有自己的类型。" class="headerlink" title="特征四：拥有自己的类型。"></a>特征四：拥有自己的类型。</h5><p>每个函数都和整型值、字符串值等一等公民一样，拥有自己的类型，也就是我们讲过的<strong>函数类型</strong>。</p><p>我们甚至可以基于函数类型来自定义类型，就像基于整型、字符串类型等类型来自定义类型一样。下面代码中的 HandlerFunc、visitFunc 就是 Go 标准库中，基于函数类型进行自定义的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span></span><br><br><span class="hljs-comment">// $GOROOT/src/sort/genzfunc.go</span><br><span class="hljs-keyword">type</span> visitFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ast.Node)</span></span> ast.Visitor<br></code></pre></td></tr></table></figure><p><strong>这部分还是看不懂…</strong></p><h4 id="函数“一等公民”特性的高效运用"><a href="#函数“一等公民”特性的高效运用" class="headerlink" title="函数“一等公民”特性的高效运用"></a>函数“一等公民”特性的高效运用</h4><h5 id="应用一：函数类型的妙用"><a href="#应用一：函数类型的妙用" class="headerlink" title="应用一：函数类型的妙用"></a>应用一：函数类型的妙用</h5><p>Go 函数是“一等公民”，也就是说，它拥有自己的类型。而且，整型、字符串型等所有类型都可以进行的操作，比如显式转型，也就是说，<strong>函数也可以被显式转型</strong>。</p><p>函数的显式转形和整型变量是一样的, 都是要求底层类型相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">5</span><br>y := MyInt(x) <span class="hljs-comment">// MyInt的底层类型为int，类比HandlerFunc的底层类型为func(ResponseWriter, *Request)</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greeting</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome, Gopher!\n&quot;</span>)<br>&#125;                    <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, http.HandlerFunc(greeting))<span class="hljs-comment">//这里函数greeting被转换为了http.HandlerFunc类型</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="应用二：利用闭包简化函数调用。"><a href="#应用二：利用闭包简化函数调用。" class="headerlink" title="应用二：利用闭包简化函数调用。"></a>应用二：利用闭包简化函数调用。</h5><p>Go 闭包是在函数内部创建的匿名函数，这个匿名函数可以访问创建它的函数的参数与局部变量。我们可以利用闭包的这一特性来简化函数调用，这里我们看一个具体例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">times</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">return</span> x * y<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，times 函数用来进行两个整型数的乘法。我们使用 times 函数的时候需要传入两个实参，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">times(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算2 x 5</span><br>times(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算3 x 5</span><br>times(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算4 x 5</span><br></code></pre></td></tr></table></figure><p>不过，有些场景存在一些高频使用的乘数，这个时候我们就没必要每次都传入这样的高频乘数了。那我们怎样能省去高频乘数的传入呢? 我们看看下面这个新函数 partialTimes：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partialTimes</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> times(x, y)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，partialTimes 的返回值是一个接受单一参数的函数，这个由 partialTimes 函数生成的匿名函数，使用了 partialTimes 函数的参数 x。按照前面的定义，这个匿名函数就是一个闭包。partialTimes 实质上就是用来生成以 x 为固定乘数的、接受另外一个乘数作为参数的、闭包函数的函数。当程序调用 partialTimes (2) 时，partialTimes 实际上返回了一个调用 times (2, y) 的函数，这个过程的逻辑类似于下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">timesTwo = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> times(<span class="hljs-number">2</span>, y)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span> &#123;<br>  timesTwo := partialTimes(<span class="hljs-number">2</span>)   <span class="hljs-comment">// 以高频乘数2为固定乘数的乘法函数</span><br>  timesThree := partialTimes(<span class="hljs-number">3</span>) <span class="hljs-comment">// 以高频乘数3为固定乘数的乘法函数</span><br>  timesFour := partialTimes(<span class="hljs-number">4</span>)  <span class="hljs-comment">// 以高频乘数4为固定乘数的乘法函数</span><br>  fmt.Println(timesTwo(<span class="hljs-number">5</span>))   <span class="hljs-comment">// 10，等价于times(2, 5)</span><br>  fmt.Println(timesTwo(<span class="hljs-number">6</span>))   <span class="hljs-comment">// 12，等价于times(2, 6)</span><br>  fmt.Println(timesThree(<span class="hljs-number">5</span>)) <span class="hljs-comment">// 15，等价于times(3, 5)</span><br>  fmt.Println(timesThree(<span class="hljs-number">6</span>)) <span class="hljs-comment">// 18，等价于times(3, 6)</span><br>  fmt.Println(timesFour(<span class="hljs-number">5</span>))  <span class="hljs-comment">// 20，等价于times(4, 5)</span><br>  fmt.Println(timesFour(<span class="hljs-number">6</span>))  <span class="hljs-comment">// 24，等价于times(4, 6)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过 partialTimes，我们生成了三个带有固定乘数的函数。这样，我们在计算乘法时，就可以减少参数的重复输入。</p><p><strong>Go 语言中的函数可以理解为一种类型。</strong></p><h2 id="错误处理——结合函数的多返回值"><a href="#错误处理——结合函数的多返回值" class="headerlink" title="错误处理——结合函数的多返回值"></a>错误处理——结合函数的多返回值</h2><p>Go 语言错误处理机制是在 C 语言错误处理机制基础上的再创新。</p><p>在 C 语言中，我们通常用一个类型为整型的函数返回值作为错误状态标识，函数调用者会基于值比较的方式，对这一代表错误状态的返回值进行检视。通常，这个返回值为 0，就代表函数调用成功；如果这个返回值是其它值，那就代表函数调用出现错误。也就是说，函数调用者需要根据这个返回值代表的错误状态，来决定后续执行哪条错误处理路径上的代码。</p><p>C 语言错误处理的优点和缺点：<br><strong>优点</strong>：每个开发人员必须显式地去关注和处理每个错误，经过显式错误处理的代码会更健壮，也会让开发人员对这些代码更有信心。<br>错误就是普通的值，所以我们不需要用额外的语言机制去处理它们，我们只需利用已有的语言机制，像处理其他普通类型值一样的去处理错误就可以了，这也让代码更容易调试，更容易针对每个错误处理的决策分支进行测试覆盖。</p><p><strong>缺点</strong>：由于 C 语言中的函数最多仅支持一个返回值，很多开发者会把这单一的返回值“一值多用”。就是说，一个返回值，不仅要承载函数要返回给调用者的信息，又要承载函数调用的最终错误状态。<br>当返回值为其他类型，比如字符串的时候，我们还很难将它与错误状态融合到一起。这个时候，很多 C 开发人员要么使用输出参数，承载要返回给调用者的信息，要么自定义一个包含返回信息与错误状态的结构体，作为返回值类型。大家做法不一，就很难形成统一的错误处理策略。</p><p>在 Go 语言中，我们依然可以像传统的 C 语言那样，用一个整型值来表示错误状态，但 Go 语言惯用法，是使用 error 这个接口类型表示错误，并且按惯例，我们通常将 error 类型返回值放在返回值列表的末尾，就像 fmt. Fprintf 函数声明中这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// fmt包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprintf</span><span class="hljs-params">(w io.Writer, format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>另外我们还可以看到，fmt. Fprintf 函数声明中代表错误状态的变量 err 的类型，并不是一个传统使用的整数类型，而是用了一个名为 error 的类型。<br><strong>Go 语言惯用法</strong>：使用 error 这个接口类型表示错误，并将 error 类型返回值放在返回值列表的末。</p><h4 id="error-类型与错误值构造"><a href="#error-类型与错误值构造" class="headerlink" title="error 类型与错误值构造"></a>error 类型与错误值构造</h4><p>error 接口是 Go 原生内置的类型，它的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/builtin/builtin.go</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>任何实现了 error 的 Error 方法的类型的实例，都可以作为错误值赋值给 error 接口变量。<br>在标准库中提供了两种方便 Go 开发者构造错误值的方法： errors. New 和 fmt. Errorf。使用这两种方法，我们可以轻松构造出一个满足 error 接口的错误值，就像下面代码这样：    </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">err := errors.New(<span class="hljs-string">&quot;your first demo error&quot;</span>)<br>errWithCtx = fmt.Errorf(<span class="hljs-string">&quot;index %d is out of bounds&quot;</span>, i)<br></code></pre></td></tr></table></figure><p>这两种方法实际上返回的是同一个实现了 error 接口的类型的实例，这个未导出的类型就是 errors. errorString，它的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/errors/errors.go</span><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>    s <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></td></tr></table></figure><p>大多数情况下，使用这两种方法构建的错误值就可以满足我们的需求了。但我们也要看到，虽然这两种构建错误值的方法很方便，但它们<strong>给错误处理者提供的错误上下文（Error Context）只限于以字符串形式呈现的信息</strong>，也就是 Error 方法返回的信息。</p><p>在一些场景下，错误处理者需要从错误值中提取出更多信息，帮助他选择错误处理路径，显然这两种方法就不能满足了。这个时候，我们可以自定义错误类型来满足这一需求。比如：标准库中的 net 包就定义了一种携带额外错误上下文的错误类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> OpError <span class="hljs-keyword">struct</span> &#123;<br>    Op <span class="hljs-type">string</span><br>    Net <span class="hljs-type">string</span><br>    Source Addr<br>    Addr Addr<br>    Err <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，错误处理者就可以根据这个类型的错误值提供的额外上下文信息，比如 Op、Net、Source 等，做出错误处理路径的选择，比如下面标准库中的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isCommonNetReadError</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> err == io.EOF &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> oe, ok := err.(*net.OpError); ok &amp;&amp; oe.Op == <span class="hljs-string">&quot;read&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码利用类型断言，判断 error 类型变量 err 的动态类型是否为 *net. OpError 或 net. Error。如果 err 的动态类型是 *net. OpError，那么类型断言就会返回这个动态类型的值（存储在 oe 中），代码就可以通过判断它的 Op 字段是否为”read”来判断它是否为 CommonNetRead 类型的错误。不过这里，你不用过多了解类型断言（Type Assertion）到底是什么，你只需要知道通过类型断言，我们可以判断接口类型的动态类型，以及获取它动态类型的值接可以了。后面我们在讲解接口类型的时候还会再细讲。(还是没有怎么看懂…)<br>那么，使用 error 类型，而不是传统意义上的整型或其他类型作为错误类型，有什么好处呢？至少有这三点好处：<br><strong>第一点：统一了错误类型</strong>。<br>如果不同开发者的代码、不同项目中的代码，甚至标准库中的代码，都统一以 error 接口变量的形式呈现错误类型，就能在提升代码可读性的同时，还更容易形成统一的错误处理策略。这个我们下面会细讲。<br><strong>第二点：错误是值</strong><br>我们构造的错误都是值，也就是说，即便赋值给 error 这个接口类型变量，我们也可以像整型值那样对错误做“=&#x3D;”和“!&#x3D;”的逻辑比较，函数调用者检视错误时的体验保持不变。<br><strong>第三点：易扩展，支持自定义错误上下文。</strong><br>虽然错误以 error 接口变量的形式统一呈现，但我们很容易通过自定义错误类型来扩展我们的错误上下文，就像前面的 Go 标准库的 OpError 类型那样。error 接口是错误值的提供者与错误值的检视者之间的契约。error 接口的实现者负责提供错误上下文，供负责错误处理的代码使用。这种错误具体上下文与作为错误值类型的 error 接口类型的解耦，也体现了 Go 组合设计哲学中“正交”的理念。</p><p>Go 语言的几种错误处理的惯用策略：</p><h4 id="策略一：透明错误处理策略"><a href="#策略一：透明错误处理策略" class="headerlink" title="策略一：透明错误处理策略"></a>策略一：透明错误处理策略</h4><p>简单来说，Go 语言中的错误处理，就是根据函数 &#x2F; 方法返回的 error 类型变量中携带的错误值信息做决策，并选择后续代码执行路径的过程。</p><p><strong>最简单的错误策略</strong>莫过于完全不关心返回错误值携带的具体上下文信息，只要发生错误就进入唯一的错误处理执行路径，比如下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">err := doSomething ()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 不关心err变量底层错误值所携带的具体上下文信息</span><br>    <span class="hljs-comment">// 执行简单错误处理逻辑并返回</span><br>    ... ...<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>这也是 Go 语言中最常见的错误处理策略，80% 以上的 Go 错误处理情形都可以归类到这种策略下。<br>在这种策略下，由于错误处理方并不关心错误值的上下文，所以错误值的构造方（如上面的函数 doSomething）可以直接使用 Go 标准库提供的两个基本错误值构造方法 errors. New 和 fmt. Errorf 来构造错误值，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(...)</span></span> <span class="hljs-type">error</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;some error occurred&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样构造出的错误值代表的上下文信息，对错误处理方是透明的，因此这种策略称为“<strong>透明错误处理策略</strong>”。在错误处理方不关心错误值上下文的前提下，透明错误处理策略能最大程度地减少错误处理方与错误值构造方之间的耦合关系。</p><h4 id="策略二-：“哨兵”错误处理策略"><a href="#策略二-：“哨兵”错误处理策略" class="headerlink" title="策略二 ：“哨兵”错误处理策略"></a>策略二 ：“哨兵”错误处理策略</h4><p>当错误处理方不能只根据“透明的错误值”就做出错误处理路径选取的情况下，错误处理方会尝试对返回的错误值进行检视，于是就有可能出现下面代码中的<strong>反模式</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := b.Peek(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">switch</span> err.Error() &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: negative count&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: buffer full&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: invalid use of UnreadByte&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>反模式</strong>就是，错误处理方以透明错误值所能提供的唯一上下文信息（描述错误的字符串），作为错误处理路径选择的依据。但这种“反模式”会造成严重的隐式耦合。这也就意味着，错误值构造方不经意间的一次错误描述字符串的改动，都会造成错误处理方处理行为的变化，并且这种通过字符串比较的方式，对错误值进行检视的性能也很差。</p><p>Go 标准库采用了定义导出的（Exported）“哨兵”错误值的方式，来辅助错误处理方检视（inspect）错误值并做出错误处理分支的决策，比如下面的 bufio 包中定义的“哨兵错误”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/bufio/bufio.go</span><br><span class="hljs-keyword">var</span> (<br>    ErrInvalidUnreadByte = errors.New(<span class="hljs-string">&quot;bufio: invalid use of UnreadByte&quot;</span>)<br>    ErrInvalidUnreadRune = errors.New(<span class="hljs-string">&quot;bufio: invalid use of UnreadRune&quot;</span>)<br>    ErrBufferFull        = errors.New(<span class="hljs-string">&quot;bufio: buffer full&quot;</span>)<br>    ErrNegativeCount     = errors.New(<span class="hljs-string">&quot;bufio: negative count&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p>下面的代码片段利用了上面的哨兵错误，进行错误处理分支的决策：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := b.Peek(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">switch</span> err &#123;<br>    <span class="hljs-keyword">case</span> bufio.ErrNegativeCount:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> bufio.ErrBufferFull:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> bufio.ErrInvalidUnreadByte:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就像给反模式里的字符串加了个变量。<br>一般“哨兵”错误值变量以 ErrXXX 格式命名。和透明错误策略相比，“哨兵”策略让错误处理方在有检视错误值的需求时候，可以“有的放矢”。</p><p>不过，对于 API 的开发者而言，暴露“哨兵”错误值也意味着这些错误值和包的公共函数 &#x2F; 方法一起成为了 API 的一部分。一旦发布出去，开发者就要对它进行很好的维护。而“哨兵”错误值也让使用这些值的错误处理方对它产生了依赖。</p><p>从 Go 1.13 版本开始，标准库 errors 包提供了 Is 函数用于错误处理方对错误值的检视。Is 函数类似于把一个 error 类型变量与“哨兵”错误值进行比较，比如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 类似 if err == ErrOutOfBounds&#123; … &#125;</span><br><span class="hljs-keyword">if</span> errors.Is(err, ErrOutOfBounds) &#123;<br>    <span class="hljs-comment">// 越界的错误处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>=&#x3D;与 errors. Is 不同的是，如果 error 类型变量的底层错误值是一个包装错误（Wrapped Error），errors. Is 方法会沿着该包装错误所在错误链（Error Chain)，与链上所有被包装的错误（Wrapped Error）进行比较，直至找到一个匹配的错误为止。下面是 Is 函数应用的一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ErrSentinel = errors.New(<span class="hljs-string">&quot;the underlying sentinel error&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  err1 := fmt.Errorf(<span class="hljs-string">&quot;wrap sentinel: %w&quot;</span>, ErrSentinel)<br>  err2 := fmt.Errorf(<span class="hljs-string">&quot;wrap err1: %w&quot;</span>, err1)<br>    <span class="hljs-built_in">println</span>(err2 == ErrSentinel) <span class="hljs-comment">//false</span><br>  <span class="hljs-keyword">if</span> errors. Is (err2, ErrSentinel) &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;err2 is ErrSentinel&quot;</span>) <span class="hljs-comment">//err2 is ErrSentinel</span><br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;err2 is not ErrSentinel&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过比较操作符对 err2 与 ErrSentinel 进行比较后，我们发现这二者并不相同。而 errors. Is 函数则会沿着 err2 所在错误链，向下找到被包装到最底层的“哨兵”错误值 ErrSentinel。</p><p>所以，如果你使用的是 Go 1.13 及后续版本，我建议你尽量使用 errors. Is 方法去检视某个错误值是否就是某个预期错误值，或者包装了某个特定的“哨兵”错误值。</p><h4 id="策略三：错误值类型检视策略"><a href="#策略三：错误值类型检视策略" class="headerlink" title="策略三：错误值类型检视策略"></a>策略三：错误值类型检视策略</h4><p>如果遇到错误处理方需要错误值提供更多的“错误上下文”的情况，上面这些错误处理策略和错误值构造方式都无法满足。</p><p>这种情况下，我们需要通过自定义错误类型的构造错误值的方式，来提供更多的“错误上下文”信息。并且，由于错误值都通过 error 接口变量统一呈现，要得到底层错误类型携带的错误上下文信息，错误处理方需要使用 Go 提供的<strong>类型断言机制（Type Assertion）</strong> 或<strong>类型选择机制（Type Switch)</strong>，这种错误处理方式，我称之为<strong>错误值类型检视策略</strong>。<br>我们来看一个标准库中的例子加深下理解，这个 json 包中自定义了一个 UnmarshalTypeError 的错误类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/encoding/json/decode.go</span><br><span class="hljs-keyword">type</span> UnmarshalTypeError <span class="hljs-keyword">struct</span> &#123;<br>    Value  <span class="hljs-type">string</span>       <br>    Type   reflect.Type <br>    Offset <span class="hljs-type">int64</span>        <br>    Struct <span class="hljs-type">string</span>       <br>    Field  <span class="hljs-type">string</span>      <br>&#125;<br></code></pre></td></tr></table></figure><p>错误处理方可以通过错误类型检视策略，获得更多错误值的错误上下文信息，下面就是利用这一策略的 json 包的一个方法的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/encoding/json/decode.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *decodeState)</span></span> addErrorContext(err <span class="hljs-type">error</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> d.errorContext.Struct != <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(d.errorContext.FieldStack) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">switch</span> err := err.(<span class="hljs-keyword">type</span>) &#123;<br>        <span class="hljs-keyword">case</span> *UnmarshalTypeError:<br>            err.Struct = d.errorContext.Struct.Name()<br>            err.Field = strings.Join(d.errorContext.FieldStack, <span class="hljs-string">&quot;.&quot;</span>)<br>            <span class="hljs-keyword">return</span> err<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码通过类型 switch 语句得到了 err 变量代表的动态类型和值，然后在匹配的 case 分支中利用错误上下文信息进行处理。<br>一般自定义导出的错误类型以 XXXError 的形式命名。和“哨兵”错误处理策略一样，错误值类型检视策略，由于暴露了自定义的错误类型给错误处理方，因此这些错误类型也和包的公共函数 &#x2F; 方法一起，成为了 API 的一部分。一旦发布出去，开发者就要对它们进行很好的维护。而它们也让使用这些类型进行检视的错误处理方对其产生了依赖。<br>从 Go 1.13 版本开始，标准库 errors 包提供了 As 函数给错误处理方检视错误值。As 函数类似于通过类型断言判断一个 error 类型变量是否为特定的自定义错误类型，如下面代码所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 类似 if e, ok := err.(*MyError); ok &#123; … &#125;</span><br><span class="hljs-keyword">var</span> e *MyError<br><span class="hljs-keyword">if</span> errors.As(err, &amp;e) &#123;<br>    <span class="hljs-comment">// 如果err类型为*MyError，变量e将被设置为对应的错误值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就像 errors. Is 函数那样, 和常规语句不同的是，如果 error 类型变量的动态错误值是一个包装错误，errors. As 函数会沿着该包装错误所在错误链，与链上所有被包装的错误的类型进行比较，直至找到一个匹配的错误类型。下面是 As 函数应用的一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>    e <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.e<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> err = &amp;MyError&#123;<span class="hljs-string">&quot;MyError error demo&quot;</span>&#125;<br>    err1 := fmt.Errorf(<span class="hljs-string">&quot;wrap err: %w&quot;</span>, err)<br>    err2 := fmt.Errorf(<span class="hljs-string">&quot;wrap err1: %w&quot;</span>, err1)<br>    <span class="hljs-keyword">var</span> e *MyError<br>    <span class="hljs-keyword">if</span> errors.As(err2, &amp;e) &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;MyError is on the chain of err2&quot;</span>)<span class="hljs-comment">//MyError is on the chain of err2</span><br>        <span class="hljs-built_in">println</span>(e == err)<span class="hljs-comment">//true                  </span><br>        <span class="hljs-keyword">return</span>                             <br>    &#125;                                      <br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;MyError is not on the chain of err2&quot;</span>)<br>&#125; <br></code></pre></td></tr></table></figure><p>errors. As 函数沿着 err2 所在错误链向下找到了被包装到最深处的错误值，并将 err2 与其类型 * MyError 成功匹配。<br>匹配成功后，errors. As 会将匹配到的错误值存储到 As 函数的第二个参数中，这也是为什么 println (e &#x3D;&#x3D; err) 输出 true 的原因。(?) 这段话不是很理解</p><p>errors. As ()：检视类型； errors. Is ()：检视错误。</p><h4 id="策略四：错误行为特征检视策略"><a href="#策略四：错误行为特征检视策略" class="headerlink" title="策略四：错误行为特征检视策略"></a>策略四：错误行为特征检视策略</h4><p>在前面的三种策略中，其实只有第一种策略，也就是“透明错误处理策略”，有效降低了错误的构造方与错误处理方两者之间的耦合。虽然前面的策略二和策略三，都是我们实际编码中有效的错误处理策略，但其实使用这两种策略的代码，依然在错误的构造方与错误处理方两者之间建立了耦合。<br>在 Go 标准库中，我们发现了这样一种错误处理方式：<strong>将某个包中的错误类型归类，统一提取出一些公共的错误行为特征，并将这些错误行为特征放入一个公开的接口类型中。</strong> 这种方式也被叫做错误行为特征检视策略。</p><p>以标准库中的 net 包为例，它将包内的所有错误类型的公共行为特征抽象并放入 net. Error 这个接口中，如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> Error <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">error</span><br>    Timeout() <span class="hljs-type">bool</span>  <br>    Temporary() <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>net. Error 接口包含两个用于判断错误行为特征的方法：Timeout 用来判断是否是超时（Timeout）错误，Temporary 用于判断是否是临时（Temporary）错误。<br>而错误处理方只需要依赖这个公共接口，就可以检视具体错误值的错误行为特征信息，并根据这些信息做出后续错误处理分支选择的决策。<br>我们再看一个 http 包使用错误行为特征检视策略进行错误处理的例子，加深下理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">for</span> &#123;<br>        rw, e := l.Accept()<br>        <span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-srv.getDoneChan():<br>                <span class="hljs-keyword">return</span> ErrServerClosed<br>            <span class="hljs-keyword">default</span>:<br>            &#125;<br>            <span class="hljs-keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;<br>                <span class="hljs-comment">// 注：这里对临时性(temporary)错误进行处理</span><br>                ... ...<br>                time.Sleep(tempDelay)<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> e<br>        &#125;<br>        ...<br>    &#125;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面代码中，Accept 方法实际上返回的错误类型为*OpError，它是 net 包中的一个自定义错误类型，它实现了错误公共特征接口 net. Error，如下代码所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> OpError <span class="hljs-keyword">struct</span> &#123;<br>    ... ...<br>    <span class="hljs-comment">// Err is the error that occurred during the operation.</span><br>    Err <span class="hljs-type">error</span><br>&#125;<br><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> &#123;<br>    Temporary() <span class="hljs-type">bool</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *OpError)</span></span> Temporary() <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">if</span> ne, ok := e.Err.(*os.SyscallError); ok &#123;<br>      t, ok := ne.Err.(temporary)<br>      <span class="hljs-keyword">return</span> ok &amp;&amp; t.Temporary()<br>  &#125;<br>  t, ok := e.Err.(temporary)<br>  <span class="hljs-keyword">return</span> ok &amp;&amp; t.Temporary()<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，OpError 实例可以被错误处理方通过 net. Error 接口的方法，判断它的行为是否满足 Temporary 或 Timeout 特征。</p><p>在错误处理策略选择上的建议：</p><ul><li>请尽量使用“透明错误”处理策略，降低错误处理方与错误值构造方之间的耦合；</li><li>如果可以从众多错误类型中提取公共的错误行为特征，那么请尽量使用“错误行为特征检视策略”; </li><li>在上述两种策略无法实施的情况下，再使用“哨兵”策略和“错误值类型检视”策略；</li><li>Go 1.13 及后续版本中，尽量用 errors. Is 和 errors. As 函数替换原先的错误检视比较语句。</li></ul><h2 id="如何让函数更健壮？"><a href="#如何让函数更健壮？" class="headerlink" title="如何让函数更健壮？"></a>如何让函数更健壮？</h2><p><strong>健壮性的“三不要”原则</strong></p><h5 id="原则一：不要相信任何外部输入的参数。"><a href="#原则一：不要相信任何外部输入的参数。" class="headerlink" title="原则一：不要相信任何外部输入的参数。"></a>原则一：不要相信任何外部输入的参数。</h5><p>函数的使用者可能是任何人，这些人在使用函数之前可能都没有阅读过任何手册或文档，他们会向函数传入你意想不到的参数。因此，为了保证函数的健壮性，函数需要对所有输入的参数进行合法性的检查。一旦发现问题，立即终止函数的执行，返回预设的错误值。</p><h5 id="原则二：不要忽略任何一个错误。"><a href="#原则二：不要忽略任何一个错误。" class="headerlink" title="原则二：不要忽略任何一个错误。"></a>原则二：不要忽略任何一个错误。</h5><p>在我们的函数实现中，也会调用标准库或第三方包提供的函数或方法。对于这些调用，我们不能假定它一定会成功，我们一定要显式地检查这些调用返回的错误值。一旦发现错误，要及时终止函数执行，防止错误继续传播。</p><h5 id="原则三：不要假定异常不会发生。"><a href="#原则三：不要假定异常不会发生。" class="headerlink" title="原则三：不要假定异常不会发生。"></a>原则三：不要假定异常不会发生。</h5><p>这里，我们先要确定一个认知：异常不是错误。错误是可预期的，也是经常会发生的，我们有对应的公开错误码和错误处理预案，但异常却是少见的、意料之外的。通常意义上的异常，指的是硬件异常、操作系统异常、语言运行时异常，还有更大可能是代码中潜在 bug 导致的异常，比如代码中出现了以 0 作为分母，或者是数组越界访问等情况。<br>虽然异常发生是“小众事件”，但是我们不能假定异常不会发生。所以，函数设计时，我们就需要根据函数的角色和使用场景，考虑是否要在函数内设置异常捕捉和恢复的环节。</p><h3 id="Panic-Go-函数的异常处理设计"><a href="#Panic-Go-函数的异常处理设计" class="headerlink" title="Panic     Go 函数的异常处理设计"></a>Panic     Go 函数的异常处理设计</h3><p>不同编程语言表示异常（Exception）这个概念的语法都不相同。在 Go 语言中，异常这个概念由 panic 表示。一些教程或文章会把它译为恐慌，我这里依旧选择不译，保留 panic 的原汁原味。<br>panic 指的是 Go 程序在运行时出现的一个异常情况。如果异常出现了，但没有被捕获并恢复，Go 程序的执行就会被终止，即便出现异常的位置不在主 Goroutine 中也会这样。<br>在 Go 中，panic 主要有两类来源，一类是来自 Go 运行时，另一类则是 Go 开发人员通过 panic 函数主动触发的。无论是哪种，一旦 panic 被触发，后续 Go 程序的执行过程都是一样的 (go 的异常终止的逻辑中，程序 down 掉)，这个过程被 Go 语言称为 panicking。</p><p>Go 官方文档以手工调用 panic 函数触发 panic 为例，对 panicking 这个过程进行了诠释：当函数 F 调用 panic 函数时，函数 F 的执行将停止。不过，函数 F 中已进行求值的 deferred 函数都会得到正常执行，执行完这些 deferred 函数后，函数 F 才会把控制权返还给其调用者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call foo&quot;</span>)<br>    bar()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit foo&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call bar&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic occurs in bar&quot;</span>)<br>    zoo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit bar&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zoo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call zoo&quot;</span>)<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit zoo&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call main&quot;</span>)<br>    foo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit main&quot;</span>)<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">//call main</span><br><span class="hljs-comment">//call foo</span><br><span class="hljs-comment">//call bar</span><br><span class="hljs-comment">//panic: panic occurs in bar</span><br></code></pre></td></tr></table></figure><p>程序从入口函数 main 开始依次调用了 foo、bar 函数，在 bar 函数中，代码在调用 zoo 函数之前调用了 panic 函数触发了异常。那示例的 panicking 过程就从这开始了。bar 函数调用 panic 函数之后，它自身的执行就此停止了，所以我们也没有看到代码继续进入 zoo 函数执行。并且，bar 函数没有捕捉这个 panic，这样这个 panic 就会沿着函数调用栈向上走，来到了 bar 函数的调用者 foo 函数中。<br>从 foo 函数的视角来看，这就好比将它对 bar 函数的调用，换成了对 panic 函数的调用一样。这样一来，foo 函数的执行也被停止了。由于 foo 函数也没有捕捉 panic，于是 panic 继续沿着函数调用栈向上走，来到了 foo 函数的调用者 main 函数中。<br>同理，从 main 函数的视角来看，这就好比将它对 foo 函数的调用，换成了对 panic 函数的调用一样。结果就是，main 函数的执行也被终止了，于是整个程序异常退出，日志”exit main”也没有得到输出的机会。<br>不过，Go 也提供了捕捉 panic 并恢复程序正常执行秩序的方法，我们可以通过 recover 函数来实现这一点。<br>将 bar 函数更新为下面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> e := <span class="hljs-built_in">recover</span>(); e != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;recover the panic:&quot;</span>, e)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call bar&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic occurs in bar&quot;</span>)<br>    zoo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit bar&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>recover 是 Go 内置的专门用于恢复 panic 的函数，它必须被放在一个 defer 函数中才能生效。如果 recover 捕捉到 panic，它就会返回以 panic 的具体内容为错误上下文信息的错误值。如果没有 panic 发生，那么 recover 将返回 nil。如果 panic 被 recover 捕捉到，panic 引发的 panicking 过程就会停止。<br>无论 bar 函数正常执行结束，还是因 panic 异常终止，在那之前设置成功的 defer 函数都会得到执行就可以了。<br>执行更新后的程序，得到如下结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">call main<br>call foo<br>call bar<br><span class="hljs-built_in">recover</span> the <span class="hljs-built_in">panic</span>: <span class="hljs-built_in">panic</span> occurs in bar<br>exit foo<br>exit main<br></code></pre></td></tr></table></figure><p>在更新后的代码中，当 bar 函数调用 panic 函数触发异常后，bar 函数的执行就会被中断。但这一次，在代码执行流回到 bar 函数调用者之前，bar 函数中的、在 panic 之前就已经被设置成功的 derfer 函数就会被执行。<br>这个匿名函数会调用 recover 把刚刚触发的 panic 恢复，这样，panic 还没等沿着函数栈向上走，就被消除了。所以，这个时候，从 foo 函数的视角来看，bar 函数与正常返回没有什么差别。<br>foo 函数依旧继续向下执行，直至 main 函数成功返回。这样，这个程序的 panic“危机”就解除了。<br>感觉 recover 就是使得在这之前的函数都能执行完成，而不是直接退出。</p><h2 id="如何应对-panic？"><a href="#如何应对-panic？" class="headerlink" title="如何应对 panic？"></a>如何应对 panic？</h2><h5 id="第一点：评估程序对-panic-的忍受度"><a href="#第一点：评估程序对-panic-的忍受度" class="headerlink" title="第一点：评估程序对 panic 的忍受度"></a>第一点：评估程序对 panic 的忍受度</h5><p><strong>不同应用对异常引起的程序崩溃退出的忍受度是不一样的</strong><br>比如，一个单次运行于控制台窗口中的命令行交互类程序（CLI），和一个常驻内存的后端 HTTP 服务器程序，对异常崩溃的忍受度就是不同的。前者即便因异常崩溃，对用户来说也仅仅是再重新运行一次而已。但后者一旦崩溃，就很可能导致整个网站停止服务。<br><strong>针对各种应用对 panic 忍受度的差异，我们采取的应对 panic 的策略也应该有不同</strong></p><p>就比如 Go 标准库提供的 http server。一般来讲，无论在哪个 Goroutine 中发生未被恢复的 panic，整个程序都将崩溃退出。所以，为了保证处理某一个客户端连接的 Goroutine 出现 panic 时，不影响到 http server 主 Goroutine 的运行，Go 标准库在 serve 方法中加入了对 panic 的捕捉与恢复，下面是 serve 方法的部分代码片段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server. go</span><br><span class="hljs-comment">// Serve a new connection.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span></span> serve (ctx context. Context) &#123;<br>    c.remoteAddr = c.rwc.RemoteAddr().String()<br>    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;<br>            <span class="hljs-keyword">const</span> size = <span class="hljs-number">64</span> &lt;&lt; <span class="hljs-number">10</span><br>            buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size)<br>            buf = buf[:runtime.Stack(buf, <span class="hljs-literal">false</span>)]<br>            c.server.logf(<span class="hljs-string">&quot;http: panic serving %v: %v\n%s&quot;</span>, c.remoteAddr, err, buf)<br>        &#125;<br>        <span class="hljs-keyword">if</span> !c.hijacked() &#123;<br>            c.<span class="hljs-built_in">close</span>()<br>            c.setState(c.rwc, StateClosed, runHooks)<br>        &#125;<br>    &#125;()<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>serve 方法在一开始处就设置了 defer 函数，并在该函数中捕捉并恢复了可能出现的 panic。这样，即便处理某个客户端连接的 Goroutine 出现 panic，处理其他连接 Goroutine 以及 http server 自身都不会受到影响。</p><p>这种<strong>局部不要影响整体的异常处理策略</strong>，在很多并发程序中都有应用。并且，捕捉和恢复 panic 的位置通常都在子 Goroutine 的起始处，这样设置可以捕捉到后面代码中可能出现的所有 panic，就像 serve 方法中那样。</p><h5 id="第二点：提示潜在-bug"><a href="#第二点：提示潜在-bug" class="headerlink" title="第二点：提示潜在 bug"></a>第二点：提示潜在 bug</h5><p>在 Go 标准库中，<strong>大多数 panic 的使用都是充当类似 C 语言中断言的作用的。</strong><br>例如在 json 包的 encode. go 中也有使用 panic 做潜在 bug 提示的例子：：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/encoding/json/encode.go</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *reflectWithString)</span></span> resolve() <span class="hljs-type">error</span> &#123;<br>    ... ...<br><span class="hljs-keyword">switch</span> w.k.Kind() &#123;<br><span class="hljs-keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<br>w.ks = strconv.FormatInt(w.k.Int(), <span class="hljs-number">10</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<br>w.ks = strconv.FormatUint(w.k.Uint(), <span class="hljs-number">10</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unexpected map key type&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码中，resolve 方法的最后一行代码就相当于一个“代码逻辑不会走到这里”的断言。一旦触发“断言”，这很可能就是一个潜在 bug。我们也看到，去掉这行代码并不会对 resolve 方法的逻辑造成任何影响，但真正出现问题时，开发人员就缺少了“断言”潜在 bug 提醒的辅助支持了。</p><h5 id="第三点：不要混淆异常与错误"><a href="#第三点：不要混淆异常与错误" class="headerlink" title="第三点：不要混淆异常与错误"></a>第三点：不要混淆异常与错误</h5><p>不能将 Go panic 当成 Java 的“checked exception”去用<br>查看 Java 标准类库，我们可以看到一些 Java 已预定义好的 checked exception 类，比较常见的有 IOException、TimeoutException、EOFException、FileNotFoundException，等等。看到这里，你是不是觉得这些 checked exception 和我们上一节讲的“哨兵错误值”十分相似？。它们都是预定义好的、代表特定场景下的错误状态。<br><strong>Java 的 checked exception 和 Go 中的 panic 有啥差别呢？</strong><br>Java 的 checked exception 用于一些可预见的、常会发生的错误场景，比如，针对 checked exception 的所谓“异常处理”，就是针对这些场景的“错误处理预案”。也可以说对 checked exception 的使用、捕获、自定义等行为都是“<strong>有意而为之</strong>”的。<br>如果它非要和 Go 中的某种语法对应来看，它对应的也是 Go 的错误处理，也就是基于 error 值比较模型的错误处理。所以，Java 中对 checked exception 处理的本质是错误处理，虽然它的名字用了带有“异常”的字样。<br>而 Go 中的 panic 呢，更接近于 Java 的 RuntimeException+Error，而不是 checked exception。<br>我们前面提到过 Java 的 checked exception 是必须要被上层代码处理的，也就是要么捕获处理，要么重新抛给更上层。但是在 Go 中，我们通常会导入大量第三方包，而对于这些第三方包 API 中是否会引发 panic，我们是不知道的。因此上层代码，也就是 API 调用者根本不会去逐一了解 API 是否会引发 panic，也没有义务去处理引发的 panic。<br>一旦你在编写的 API 中，像 checked exception 那样使用 panic 作为正常错误处理的手段，把引发的 panic 当作错误，那么你就会给你的 API 使用者带去大麻烦！因此，在 <strong>Go 中，作为 API 函数的作者，你一定不要将 panic 当作错误返回给 API 调用者。</strong></p><h2 id="defer-用于使得函数简洁"><a href="#defer-用于使得函数简洁" class="headerlink" title="defer      用于使得函数简洁"></a>defer      用于使得函数简洁</h2><p>defer 是 Go 语言提供的一种延迟调用机制，defer 的运作离不开函数。</p><ul><li>在 Go 中，只有在函数（和方法）内部才能使用 defer；</li><li>defer 关键字后面只能接函数（或方法），这些函数被称为 deferred 函数。defer 将它们注册到其所在 Goroutine 中，用于存放 deferred 函数的栈数据结构中，这些 deferred 函数将在执行 defer 的函数退出前，按后进先出（LIFO）的顺序被程序调度执行（如下图所示）。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230221153813.png]]<br>无论是执行到函数体尾部返回，还是在某个错误处理分支显式 return，又或是出现 panic，已经存储到 deferred 函数栈中的函数，都会被调度执行。所以说，deferred 函数是一个可以在任何情况下为函数进行收尾工作的好“伙伴”。</li></ul><p>使用案例如下<br>未使用 defer 之前：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> mu sync.Mutex<br>    mu.Lock()<br>    r1, err := OpenResource1()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    r2, err := OpenResource2()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    r3, err := OpenResource3()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r2.Close()<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-comment">// 使用r1，r2, r3</span><br>    err = doWithResources() <br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r3.Close()<br>        r2.Close()<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    r3.Close()<br>    r2.Close()<br>    r1.Close()<br>    mu.Unlock()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用 defer 之后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> mu sync.Mutex<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br><br>    r1, err := OpenResource1()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r1.Close()<br><br>    r2, err := OpenResource2()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r2.Close()<br><br>    r3, err := OpenResource3()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r3.Close()<br><br>    <span class="hljs-comment">// 使用r1，r2, r3</span><br>    <span class="hljs-keyword">return</span> doWithResources() <br>&#125;<br></code></pre></td></tr></table></figure><p>使用 defer 后对函数实现逻辑的简化是显而易见的。而且，这里资源释放函数的 defer 注册动作，紧邻着资源申请成功的动作，这样成对出现的惯例就极大降低了遗漏资源释放的可能性，我们开发人员也不用再小心翼翼地在每个错误处理分支中检查是否遗漏了某个资源的释放动作。同时，代码的简化也意味代码可读性的提高，以及代码健壮度的增强。</p><h3 id="defer-使用的几个注意事项"><a href="#defer-使用的几个注意事项" class="headerlink" title="defer 使用的几个注意事项"></a>defer 使用的几个注意事项</h3><h4 id="第一点：明确哪些函数可以作为-deferred-函数"><a href="#第一点：明确哪些函数可以作为-deferred-函数" class="headerlink" title="第一点：明确哪些函数可以作为 deferred 函数"></a>第一点：明确哪些函数可以作为 deferred 函数</h4><p>对于自定义的函数或方法，defer 可以给与无条件的支持，但是对于有返回值的自定义函数或方法，返回值会在 deferred 函数被调度执行的时候被自动丢弃（被 defer 关键字标记的函数的返回值会被舍弃）。<br>不过部分 Go 中的内置函数不能作为 deferred 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go中所有内置函数列表：</span><br>Functions:<br>  <span class="hljs-built_in">append</span> <span class="hljs-built_in">cap</span> <span class="hljs-built_in">close</span> <span class="hljs-built_in">complex</span> <span class="hljs-built_in">copy</span> <span class="hljs-built_in">delete</span> <span class="hljs-built_in">imag</span> <span class="hljs-built_in">len</span><br>  <span class="hljs-built_in">make</span> <span class="hljs-built_in">new</span> <span class="hljs-built_in">panic</span> <span class="hljs-built_in">print</span> <span class="hljs-built_in">println</span> <span class="hljs-built_in">real</span> <span class="hljs-built_in">recover</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// defer1.go</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>     <span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br>     <span class="hljs-keyword">var</span> sl []<span class="hljs-type">int</span><br>     <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>     m[<span class="hljs-string">&quot;item1&quot;</span>] = <span class="hljs-number">1</span><br>     m[<span class="hljs-string">&quot;item2&quot;</span>] = <span class="hljs-number">2</span><br>     <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">-1.4</span>)<br> <br>     <span class="hljs-keyword">var</span> sl1 []<span class="hljs-type">int</span><br>     <span class="hljs-keyword">defer</span> bar()<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">append</span>(sl, <span class="hljs-number">11</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">cap</span>(sl)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(c)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">complex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">copy</span>(sl1, sl)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">delete</span> (m, <span class="hljs-string">&quot;item2&quot;</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">imag</span>(a)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">len</span>(sl)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">new</span>(*<span class="hljs-type">int</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">panic</span>(<span class="hljs-number">1</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello, defer\n&quot;</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello, defer&quot;</span>)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">real</span>(a)<br>     <span class="hljs-keyword">defer</span> <span class="hljs-built_in">recover</span>()<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>     foo()<br> &#125;<br><span class="hljs-comment">//输出</span><br>$<span class="hljs-keyword">go</span> run defer1.<span class="hljs-keyword">go</span><br># command-line-arguments<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">17</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">append</span>(sl, <span class="hljs-number">11</span>)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">18</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">cap</span>(sl)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">20</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">complex</span>(<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">23</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">imag</span>(a)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">24</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">len</span>(sl)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">25</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">26</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">new</span>(*<span class="hljs-type">int</span>)<br>./defer1.<span class="hljs-keyword">go</span>:<span class="hljs-number">30</span>:<span class="hljs-number">2</span>: <span class="hljs-keyword">defer</span> discards result of <span class="hljs-built_in">real</span>(a)<br></code></pre></td></tr></table></figure><p>如上，可以看出 append、cap、len、make、new、imag 等内置函数都是不能直接作为 deferred 函数的，而 close、copy、delete、print、recover 等内置函数则可以直接被 defer 设置为 deferred 函数<br>不过，对于那些不能直接作为 deferred 函数的内置函数，我们可以使用一个包裹它的匿名函数来间接满足要求，以 append 为例是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  _ = <span class="hljs-built_in">append</span>(sl, <span class="hljs-number">11</span>)<br>&#125;()<br></code></pre></td></tr></table></figure><h3 id="第二点：注意-defer-关键字后面表达式的求值时机"><a href="#第二点：注意-defer-关键字后面表达式的求值时机" class="headerlink" title="第二点：注意 defer 关键字后面表达式的求值时机"></a>第二点：注意 defer 关键字后面表达式的求值时机</h3><p>牢记：<strong>defer 关键字后面的表达式，是在将 deferred 函数注册到 deferred 函数栈的时候进行求值的。</strong>(意思是，如果 defer 关键字后面有未知的变量或者表达式，那么在压栈前就会计算成已知的)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo1</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> fmt.Println(i)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo2</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>            fmt.Println(n)<br>        &#125;(i)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo3</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Println(i)<br>        &#125;()<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;foo1 result:&quot;</span>)<br>    foo1()<br>    fmt.Println(<span class="hljs-string">&quot;\nfoo2 result:&quot;</span>)<br>    foo2()<br>    fmt.Println(<span class="hljs-string">&quot;\nfoo3 result:&quot;</span>)<br>    foo3()<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 foo1，defer 后面直接用的是 fmt. Println 函数，每当 defer 将 fmt. Println 注册到 deferred 函数栈的时候，都会对 Println 后面的参数进行求值。根据上述代码逻辑，依次压入 deferred 函数栈的函数是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-number">0</span>)<br>fmt.Println(<span class="hljs-number">1</span>)<br>fmt.Println(<span class="hljs-number">2</span>)<br>fmt.Println(<span class="hljs-number">3</span>)<br><span class="hljs-comment">//因此输出为：</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>对于 foo2，defer 后面接的是一个带有一个参数的匿名函数。每当 defer 将匿名函数注册到 deferred 函数栈的时候，都会对该匿名函数的参数进行求值。根据上述代码逻辑，依次压入 deferred 函数栈的函数是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(0)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(1)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(2)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(3)</span></span><br><span class="hljs-comment">//输出为：</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>对于 foo3，foo3 中 defer 后面接的是一个不带参数的匿名函数。根据上述代码逻辑，依次压入 deferred 函数栈的函数是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">//当 foo3 返回后，deferred 函数被调度执行时，上述压入栈的 deferred 函数将以 LIFO 次序出栈执行。匿名函数会以闭包的方式访问外围函数的变量 i，并通过 Println 输出 i 的值，此时 i 的值为 4输出为：</span><br><span class="hljs-number">4</span><br><span class="hljs-number">4</span><br><span class="hljs-number">4</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>无论以何种形式将函数注册到 defer 中，deferred 函数的参数值都是在注册的时候进行求值的。</p><h4 id="第三点：知晓-defer-带来的性能损耗"><a href="#第三点：知晓-defer-带来的性能损耗" class="headerlink" title="第三点：知晓 defer 带来的性能损耗"></a>第三点：知晓 defer 带来的性能损耗</h4><p>在 Go 1.13 前的版本中, <strong>使用 defer 的函数的执行时间是没有使用 defer 函数的 8 倍左右。</strong><br>但从 Go 1.13 版本开始，带有 defer 的函数执行开销，仅是不带有 defer 的函数的执行开销的 1.45 倍左右，已经达到了几乎可以忽略不计的程度，我们可以放心使用。</p><p><strong>defer 要注意的：</strong></p><ul><li>函数返回前，deferred 函数是按照后入先出（LIFO）的顺序执行的；</li><li>defer 关键字是在注册函数时对函数的参数进行求值的。</li></ul><p>defer 的使用技巧：<br>1）defer 要在 panic 之前，才能执行；<br>2）defer 内部的 recover 只能捕获当前协程的 Panic，不能跨协程执行；<br>3）recover 只能在 defer 中调用才能生效。<br>4）可以跟踪函数的执行过程</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 语言从设计伊始，就不支持经典的面向对象语法元素，比如类、对象、继承，等等，但 Go 语言仍保留了名为“方法（method）”的语法元素。但这并不是要支持面向对象编程范式。<br>下面就是 Go 方法的一般形式：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230221164230.png]]<br>可以看清方法和函数非常相似，就多了一个 2. receiver ，这个 receiver 参数是方法与类型之间的纽带，也是方法与函数的最大不同。<br><strong>Go 中的方法必须是归属于一个类型的</strong>，而 receiver 参数的类型就是这个方法归属的类型，或者说这个方法就是这个类型的一个方法。就像上图中一样，ListenAndServeTLS 是 *Server 类型的方法, 注意是*Server 的方法而不是 Server 类型的方法。<br>每个方法只能有一个 receiver 参数，Go 不支持在方法的 receiver 部分放置包含多个 receiver 参数的参数列表，或者变长 receiver 参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T或T)</span></span> MethodName(参数列表) (返回值列表) &#123;<br>    <span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>receiver 部分的参数名不能与方法参数列表中的形参名，以及具名返回值中的变量名存在冲突，必须在这个方法的作用域中具有唯一性。如果这个不唯一不存在，比如像下面例子中那样，Go 编译器就会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M (t <span class="hljs-type">string</span>) &#123; <br><span class="hljs-comment">// 编译器报错：duplicate argument t (重复声明参数t)</span><br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在方法体中，我们没有用到 receiver 参数，我们也可以省略 receiver 的参数名，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M(t <span class="hljs-type">string</span>) &#123; <br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>仅当方法体中的实现不需要 receiver 参数参与时，我们才会省略 receiver 参数名，不过这一情况<strong>很少使用</strong>，你了解一下就好了。</p><p><strong>以及 receiver 参数的基类型本身不能为指针类型或接口类型。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt *<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r MyInt)</span></span> String() <span class="hljs-type">string</span> &#123; <br><span class="hljs-comment">// r的基类型为MyInt，编译器报错：invalid receiver type MyInt (MyInt is a pointer type)</span><br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, *(*<span class="hljs-type">int</span>)(r))<br>&#125;<br><br><span class="hljs-keyword">type</span> MyReader io.Reader<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r MyReader)</span></span> Read(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123; <br><span class="hljs-comment">// r的基类型为MyReader，编译器报错：invalid receiver type MyReader (MyReader is an interface type)</span><br>    <span class="hljs-keyword">return</span> r.Read(p)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>而且方法声明要与 receiver 参数的基类型声明放在同一个包内。</strong> 基于这个约束，我们还可以得到两个推论。</p><ul><li>第一个推论：<strong>我们不能为原生类型（诸如 int、float64、map 等）添加方法。</strong><br>比如，下面的代码试图为 Go 原生类型 int 增加新方法 Foo，这样做，Go 编译器会报错：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> Foo() <span class="hljs-type">string</span> &#123; <br><span class="hljs-comment">// 编译器报错：cannot define new methods on non-local type int</span><br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, i) <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第二个推论：<strong>不能跨越 Go 包为其他包的类型声明新方法。</strong><br>比如，下面的代码试图跨越包边界，为 Go 标准库中的 http. Server 类型添加新方法 Foo，这样做，Go 编译器同样会报错：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s http.Server)</span></span> Foo() &#123; <br><span class="hljs-comment">// 编译器报错：cannot define new methods on non-local type http.Server</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何调用方法？</strong><br>如果 receiver 参数的基类型为 T，那么我们说 receiver 参数绑定在 T 上，我们可以通过 *T 或 T 的变量实例调用该方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M(n <span class="hljs-type">int</span>) &#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    t.M(<span class="hljs-number">1</span>) <span class="hljs-comment">// 通过类型T的变量实例调用方法M</span><br><br>    p := &amp;T&#123;&#125;<br>    p.M(<span class="hljs-number">2</span>) <span class="hljs-comment">// 通过类型*T的变量实例调用方法M</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法的本质是什么-？"><a href="#方法的本质是什么-？" class="headerlink" title="方法的本质是什么 ？"></a>方法的本质是什么 ？</h4><p>C++ 中的对象在调用方法时，编译器会自动传入指向对象自身的 this 指针作为方法的第一个参数。而 Go 方法中的原理也是相似的，只不过我们是<strong>将 receiver 参数以第一个参数的身份并入到方法的参数列表中。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123; <br>    a <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> Get() <span class="hljs-type">int</span> &#123;  <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> Set(a <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123; <br>    t.a = a <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br><br><span class="hljs-comment">// 类型T的方法Get的等价函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Get</span><span class="hljs-params">(t T)</span></span> <span class="hljs-type">int</span> &#123;  <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br><span class="hljs-comment">// 类型*T的方法Set的等价函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Set</span><span class="hljs-params">(t *T, a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <br>    t.a = a <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br></code></pre></td></tr></table></figure><p>这种等价转换后的函数的类型就是方法的类型。只不过在 Go 语言中，这种等价转换是由 Go 编译器在编译和生成代码时自动完成的。Go 语言规范中还提供了<strong>方法表达式（Method Expression）</strong> 的概念，可以让我们更充分地理解上面的等价转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t T<br>t.Get()<br>(&amp;t).Set(<span class="hljs-number">1</span>)<br><span class="hljs-comment">//上面可以等价替换为：</span><br><span class="hljs-keyword">var</span> t T<br>T.Get(t)<br>(*T).Set(&amp;t, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><strong>直接以类型名 T 调用方法的表达方式，被称为 Method Expression。</strong><br>通过 Method Expression 这种形式，类型 T 只能调用 T 的方法集合（Method Set）中的方法，同理类型 *T 也只能调用 *T 的方法集合中的方法。</p><p><strong>Go 语言中的方法的本质就是，一个以方法的 receiver 参数作为第一个参数的普通函数。</strong><br>Method Expression 就是 Go 方法本质的最好体现，因为方法自身的类型就是一个普通函数的类型，我们甚至可以将它作为右值，赋值给一个函数类型的变量，比如下面示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    f1 := (*T).Set <br>    <span class="hljs-comment">// f1的类型，也是*T类型Set方法的类型：func (t *T, int)int</span><br>    f2 := T.Get    <br>    <span class="hljs-comment">// f2的类型，也是T类型Get方法的类型：func(t T)int</span><br>    fmt.Printf(<span class="hljs-string">&quot;the type of f1 is %T\n&quot;</span>, f1) <br>    <span class="hljs-comment">// the type of f1 is func(*main.T, int) int</span><br>    fmt.Printf(<span class="hljs-string">&quot;the type of f2 is %T\n&quot;</span>, f2) <br>    <span class="hljs-comment">// the type of f2 is func(main.T) int</span><br>    f1 (&amp;t, <span class="hljs-number">3</span>)<br>    fmt.Println(f2(t)) <span class="hljs-comment">// 3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(有部分案例，暂时跳过，感觉不是太看得懂…)</p><h4 id="如何选择-receiver-类型？"><a href="#如何选择-receiver-类型？" class="headerlink" title="如何选择 receiver 类型？"></a>如何选择 receiver 类型？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M1 () &lt;=&gt; F1 (t T)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M2() &lt;=&gt; F2(t *T)<br></code></pre></td></tr></table></figure><p>这个例子中有方法 M1 和 M2。M1 方法是 receiver 参数类型为 T 的一类方法的代表，而 M2 方法则代表了 receiver 参数类型为 *T 的另一类。下面我们分别来看看不同的 receiver 参数类型对 M1 和 M2 的影响。****</p><ul><li>首先，当 receiver 参数的类型为 T 时：当我们选择以 T 作为 receiver 参数类型时，M1 方法等价转换为 F1 (t T)。我们知道，Go 函数的参数采用的是<strong>值拷贝传递</strong>，也就是说，F1 函数体中的 t 是 T 类型实例的一个副本。这样，我们在 F1 函数的实现中对参数 t 做任何修改，都只会影响副本，而不会影响到原 T 类型实例。</li><li>第二，当 receiver 参数的类型为 *T 时：当我们选择以 *T 作为 receiver 参数类型时，M2 方法等价转换为 F2 (t *T)。同上面分析，我们传递给 F2 函数的 t 是 T 类型实例的地址，这样 F2 函数体中对参数 t 做的任何修改，都会反映到原 T 类型实例上。<br> <strong>总结</strong>：当我们的方法 M1 采用类型为 T 的 receiver 参数时，代表 T 类型实例的 receiver 参数以值传递方式传递到 M1 方法体中的，实际上是 <strong>T 类型实例的副本，M1 方法体中对副本的任何修改操作，都不会影响到原 T 类型实例。</strong><br>当我们的方法 M2 采用类型为 *T 的 receiver 参数时，代表 *T 类型实例的 receiver 参数以值传递方式传递到 M2 方法体中的，实际上是 <strong>T 类型实例的地址，M2 方法体通过该地址可以对原 T 类型实例进行任何修改操作。</strong></li></ul><p><strong>无论是 T 类型实例，还是 *T 类型实例，都既可以调用 receiver 为 T 类型的方法，也可以调用 receiver 为 *T 类型的方法。</strong> 因为 Go 编译器在背后做了转换 (自动解引用或自动取地址)。也就是，Go 判断 t2 的类型为 *T，与方法 M1 的 receiver 参数类型 T 不一致，就会自动将 t2. M1 () 转换为 (*t2). M1 ()。</p><h5 id="第一个原则"><a href="#第一个原则" class="headerlink" title="第一个原则"></a>第一个原则</h5><p><strong>如果 Go 方法要把对 receiver 参数代表的类型实例的修改，反映到原类型实例上，那么我们应该选择 *T 作为 receiver 参数的类型。</strong><br><strong>如果 receiver 参数类型的 size 较大，以值拷贝形式传入就会导致较大的性能开销，这时我们选择 *T 作为 receiver 类型可能更好些。</strong></p><h5 id="第二个原则"><a href="#第二个原则" class="headerlink" title="第二个原则"></a>第二个原则</h5><p><strong>如果 Go 方法 不需要对 receiver 参数代表的类型实例的修改，并反映到原类型实例上，那么我们应该选择 \T 作为 receiver 参数的类型，因为这样可以缩窄外部修改类型实例内部状态的“接触面”，也就是尽量少暴露可以修改类型内部状态的方法。</strong></p><h5 id="第三个原则"><a href="#第三个原则" class="headerlink" title="第三个原则"></a>第三个原则</h5><p><strong>判断 T 类型是否需要实现某个接口</strong><br>如果 T 类型需要实现某个接口，那我们就要使用 T 作为 receiver 参数的类型，来满足接口类型方法集合中的所有方法。<br>如果 T 不需要实现某一接口，但 *T 需要实现该接口，那么根据方法集合概念，*T 的方法集合是包含 T 的方法集合的，这样我们在确定 Go 方法的 receiver 的类型时，参考原则一和原则二就可以了。</p><h4 id="方法集合"><a href="#方法集合" class="headerlink" title="方法集合"></a>方法集合</h4><p><strong>方法集合是用来判断一个类型是否实现了某接口类型的唯一手段</strong>，可以说，“<strong>方法集合决定了接口实现</strong>”<br><strong>什么是类型的方法集合?</strong><br>Go 中任何一个类型都有属于自己的方法集合，或者说方法集合是 Go 类型的一个“属性”。但不是所有类型都有自己的方法，比如 int 类型等。所以，对于没有定义方法的 Go 类型，我们称其拥有空方法集合。</p><h5 id="接口类型方法集合"><a href="#接口类型方法集合" class="headerlink" title="接口类型方法集合"></a>接口类型方法集合</h5><p>接口类型相对特殊，它只会列出代表接口的方法列表，不会具体定义某个方法，它的方法集合就是它的方法列表中的所有方法，我们可以一目了然地看到。</p><h5 id="非接口类型的方法集合"><a href="#非接口类型的方法集合" class="headerlink" title="非接口类型的方法集合"></a>非接口类型的方法集合</h5><p>下面这段代码可以用于输出一个非接口类型的方法集合：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dumpMethodSet</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    dynTyp := reflect.TypeOf(i)<br><br>    <span class="hljs-keyword">if</span> dynTyp == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;there is no dynamic type\n&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    n := dynTyp.NumMethod()<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%s&#x27;s method set is empty!\n&quot;</span>, dynTyp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;%s&#x27;s method set:\n&quot;</span>, dynTyp)<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        fmt.Println(<span class="hljs-string">&quot;-&quot;</span>, dynTyp.Method(j).Name)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M1() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M3() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M4() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br>    dumpMethodSet(n)<br>    dumpMethodSet(&amp;n)<br><br>    <span class="hljs-keyword">var</span> t T<br>    dumpMethodSet(t)<br>    dumpMethodSet(&amp;t)<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-type">int</span><span class="hljs-string">&#x27;s method set is empty!</span><br><span class="hljs-string">*int&#x27;</span>s method set is empty!<br>main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T&#x27;</span>s method set:<br>- M1<br>- M2<br>- M3<br>- M4<br></code></pre></td></tr></table></figure><p>其中，可以看到*T 把 T 这个类型下的所有方法 (T 和 *T) 都输出了。这是 Go 语言规定，<strong>*T 类型的方法集合包含所有以 *T 为 receiver 参数类型的方法，以及所有以 T 为 receiver 参数类型的方法。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>    M1 ()<br>    M2()<br>&#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-keyword">var</span> pt *T<br>    dumpMethodSet(t)<br>    dumpMethodSet(pt)<br>    i = pt <br>    i = t <br>    <span class="hljs-comment">// cannot use t (type T) as type Interface in assignment: T does not implement Interface (M2 method has pointer receiver)&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>T 类型的方法集合中只包含 M1，没有 Interface 类型方法集合中的 M2 方法，这就是 Go 编译器认为变量 t 不能赋值给 Interface 类型变量的原因。</p><p><strong>判断某个类型是否实现某接口的理论依据</strong><br>其中 T 类型的方法集合只包含 recevier 为 T 类型的方法，而*T 类型的方法集合包含 receiver 为 T 和*T、即类型下的所有方法。</p><p><strong>方法集合决定了接口实现</strong>的意思是：<br>如果某类型 T 的方法集合与某接口类型的方法集合相同，或者类型 T 的方法集合是接口类型 I 方法集合的超集，那么我们就说这个类型 T 实现了接口 I。或者说，方法集合这个概念在 Go 语言中的主要用途，就是用来判断某个类型是否实现了某个接口。</p><h3 id="类型嵌入"><a href="#类型嵌入" class="headerlink" title="类型嵌入"></a>类型嵌入</h3><p>类型嵌入指的就是在一个类型的定义中嵌入了其他类型。Go 语言支持两种类型嵌入，分别是<strong>接口类型的类型嵌入</strong>和<strong>结构体类型的类型嵌入</strong>。</p><h4 id="接口类型的类型嵌入"><a href="#接口类型的类型嵌入" class="headerlink" title="接口类型的类型嵌入"></a>接口类型的类型嵌入</h4><p><strong>接口类型声明了由一个方法集合代表的接口</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> E <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>    M3()<br>&#125;<span class="hljs-comment">//接口类型 I 方法集合中的 M1 和 M2，与接口类型 E 的方法集合中的方法完全相同。在这种情况下，我们可以用接口类型 E 替代上面接口类型 I 定义中 M1 和 M2</span><br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    E<br>    M3()<br>&#125;<span class="hljs-comment">//嵌入了接口类型 E</span><br></code></pre></td></tr></table></figure><p>像这种在一个接口类型（I）定义中，嵌入另外一个接口类型（E）的方式，接口类型的类型嵌入。<br>接口类型嵌入的语义就是<strong>新接口类型（如接口类型 I）将嵌入的接口类型（如接口类型 E）的方法集合，并入到自己的方法集合中。</strong><br>按 Go 语言惯例，Go 中的接口类型中只包含少量方法，并且常常只是一个方法。通过在接口类型中嵌入其他接口类型可以实现接口的组合，这也是 Go 语言中基于已有接口类型构建新接口类型的惯用法。</p><p>不过，这种通过嵌入其他接口类型来创建新接口类型的方式，在 Go 1.14 版本之前是有约束的：<strong>如果新接口类型嵌入了多个接口类型，这些嵌入的接口类型的方法集合不能有交集，同时嵌入的接口类型的方法集合中的方法名字，也不能与新接口中的其他方法同名。</strong> 比如我们用 Go 1.12.7 版本运行下面例子，Go 编译器就会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface1 <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>&#125;<br><span class="hljs-keyword">type</span> Interface2 <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br><span class="hljs-keyword">type</span> Interface3 <span class="hljs-keyword">interface</span> &#123;<br>    Interface1<br>    Interface2 <span class="hljs-comment">// Error: duplicate method M1 //1和2中M重复了</span><br>&#125;<br><span class="hljs-keyword">type</span> Interface4 <span class="hljs-keyword">interface</span> &#123;<br>    Interface2<br>    M2() <span class="hljs-comment">// Error: duplicate method M2 //也是重复了</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但自 Go 1.14 版本开始，Go 语言去除了这些约束，我们使用 Go 1.17 版本运行上面这个示例就不会得到编译错误了。</strong></p><h4 id="结构体类型的类型嵌入"><a href="#结构体类型的类型嵌入" class="headerlink" title="结构体类型的类型嵌入"></a>结构体类型的类型嵌入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//带有嵌入字段（Embedded Field）的结构体定义</span><br><span class="hljs-keyword">type</span> T1 <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> t2 <span class="hljs-keyword">struct</span>&#123;<br>    n <span class="hljs-type">int</span><br>    m <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>&#125;<br><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>    T1<br>    *t2<br>    I            <br>    a <span class="hljs-type">int</span><br>    b <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结构体 S1 定义中有三个“非常规形式”的标识符，分别是 T1、t2 和 I，它们<strong>既代表字段的名字，也代表字段的类型。</strong></p><ul><li>标识符 T1 表示字段名为 T1，它的类型为自定义类型 T1；</li><li>标识符 t2 表示字段名为 t2，它的类型为自定义结构体类型 t2 的指针类型；</li><li>标识符 I 表示字段名为 I，它的类型为接口类型 I。<br>这种以某个类型名、类型的指针类型名或接口类型名，直接作为结构体字段的方式就叫做<strong>结构体的类型嵌入</strong>，这些字段也被叫做<strong>嵌入字段（Embedded Field）</strong>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *MyInt)</span></span> Add(m <span class="hljs-type">int</span>) &#123;<br>    *n = *n + MyInt(m)<br>&#125;<br><br><span class="hljs-keyword">type</span> t <span class="hljs-keyword">struct</span> &#123;<br>    a <span class="hljs-type">int</span><br>    b <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>    *MyInt<br>    t<br>    io. Reader<br>    s <span class="hljs-type">string</span><br>    n <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := MyInt(<span class="hljs-number">17</span>)<br>    r := strings.NewReader(<span class="hljs-string">&quot;hello, go&quot;</span>)<br>    s := S&#123;<br>        MyInt: &amp;m,<br>        t: t&#123;<br>            a: <span class="hljs-number">1</span>,<br>            b: <span class="hljs-number">2</span>,<br>        &#125;,<br>        Reader: r, <span class="hljs-comment">//可以直接使用字段名来表示 </span><br>        s:      <span class="hljs-string">&quot;demo&quot;</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> sl = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello, go&quot;</span>))<br>    s.Reader.Read(sl)<br>    fmt.Println(<span class="hljs-type">string</span>(sl)) <span class="hljs-comment">// hello, go</span><br>    s.MyInt.Add(<span class="hljs-number">5</span>)<br>    fmt.Println(*(s.MyInt)) <span class="hljs-comment">// 22</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么第 29 行是 reader 而不是 io. Reader？<br>因为，Go 语言规定如果结构体使用从其他包导入的类型作为嵌入字段，比如 pkg. T，那么这个嵌入字段的字段名就是 T，代表的类型为 pkg. T。</p><p>Go 对嵌入字段有一些约束的。比如，和 Go 方法的 receiver 的基类型一样，嵌入字段类型的<strong>底层类型不能为指针类型</strong>。而且，嵌入字段的名字在结构体定义也必须是唯一的，这也意味这如果两个类型的名字相同，它们无法同时作为嵌入字段放到同一个结构体定义中。不过，这些约束你了解一下就可以了，一旦违反，Go 编译器会提示你的。</p><h3 id="Go-实现”继承”"><a href="#Go-实现”继承”" class="headerlink" title="Go 实现”继承”"></a>Go 实现”继承”</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//和上面的代码一起的</span><br><span class="hljs-keyword">var</span> sl = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello, go&quot;</span>))<br>s.Read(sl) <br>fmt.Println(<span class="hljs-type">string</span>(sl))<br>s.Add(<span class="hljs-number">5</span>) <br>fmt.Println(*(s.MyInt))<br></code></pre></td></tr></table></figure><p>可以看到 S 中并没有显式实现 read 和 add 方法，但是它却可以使用他们。<br>这两个方法其实是来自结构体类型 S 的两个嵌入字段 Reader 和 MyInt。结构体类型 S“继承”了 Reader 字段的方法 Read 的实现，也“继承”了 *MyInt 的 Add 方法的实现。<br>他们的工作机制是这样的，当我们通过结构体类型 S 的变量 s 调用 Read 方法时，Go 发现结构体类型 S 自身并没有定义 Read 方法，于是 Go 会查看 S 的嵌入字段对应的类型是否定义了 Read 方法。这个时候，Reader 字段就被找了出来，之后 s.Read 的调用就被转换为 <strong>s.Reader. Read</strong> 调用。这样一来，嵌入字段 Reader 的 Read 方法就被提升为 S 的方法，放入了类型 S 的方法集合。同理*MyInt 的 Add 方法也被提升为 S 的方法而放入 S 的方法集合。从外部来看，这种嵌入字段的方法的提升就给了我们一种结构体类型 S“<strong>继承</strong>”了 io. Reader 类型 Read 方法的实现，以及 *MyInt 类型 Add 方法的实现的错觉。<br>不过类型嵌入这种看似“继承”的机制实际上是一种组合的思想。</p><h4 id="类型嵌入与方法集合"><a href="#类型嵌入与方法集合" class="headerlink" title="类型嵌入与方法集合"></a>类型嵌入与方法集合</h4><p>接口类型的类型嵌入的本质，就是嵌入类型的方法集合并入到新接口类型的方法集合中。<br>接口类型只能嵌入接口类型。而结构体类型对嵌入类型的要求就比较宽泛了，可以是任意自定义类型或接口类型。</p><h5 id="结构体类型中嵌入接口类型"><a href="#结构体类型中嵌入接口类型" class="headerlink" title="结构体类型中嵌入接口类型"></a>结构体类型中嵌入接口类型</h5><p><strong>结构体类型的方法集合，包含嵌入的接口类型的方法集合。</strong><br>需要注意：当结构体嵌入的多个接口类型的方法集合存在交集时，编译器可能会出现的错误提示。<br>前面说的 Go 1.14 版本解决了嵌入接口类型的方法集合有交集的情况，但那仅限于接口类型中嵌入接口类型。如果是结构体类型中嵌入接口类型，并且方法集合存在交集，这个时候，Go 编译器就会因无法确定究竟使用哪个方法而报错。<br>有两个解决办法：</p><ol><li>在结构体中增加自身方法，因为嵌入了其他类型的结构体类型本身是一个代理，在调用其实例所代理的方法时，Go 会首先查看结构体自身是否实现了该方法。</li><li>消除方法集合存在交集的情况。</li></ol><p>总结：不同的嵌入字段之间，其方法交集时会报错。但一旦自身方法中有了，则优先用自身方法，不会报错。<br>.<br>结构体类型嵌入接口类型在日常编码中有一个妙用，就是可以<strong>简化单元测试的编写</strong>。<br>在编写单元测试时，可以通过内嵌接口类型的方式来假装实现了该接口。<br>（没有很懂）</p><h5 id="结构体类型中嵌入结构体类型"><a href="#结构体类型中嵌入结构体类型" class="headerlink" title="结构体类型中嵌入结构体类型"></a>结构体类型中嵌入结构体类型</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T1)</span></span> T1M1()   &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;T1&#x27;s M1&quot;</span>) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T1)</span></span> PT1M2() &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;PT1&#x27;s M2&quot;</span>) &#125;<br><br><span class="hljs-keyword">type</span> T2 <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T2)</span></span> T2M1()   &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;T2&#x27;s M1&quot;</span>) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T2)</span></span> PT2M2() &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;PT2&#x27;s M2&quot;</span>) &#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    T1<br>    *T2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    t := T&#123;<br>        T1: T1&#123;&#125;,<br>        T2: &amp;T2&#123;&#125;,<br>    &#125;<br>    dumpMethodSet(t)<br>    dumpMethodSet(&amp;t)<br>&#125;<br><span class="hljs-comment">//输出</span><br>main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- PT2M2</span><br><span class="hljs-string">- T1M1</span><br><span class="hljs-string">- T2M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main. T&#x27;</span>s method set:<br>- PT1M2<br>- PT2M2<br>- T1M1<br>- T2M1<br></code></pre></td></tr></table></figure><ul><li>类型 T 的方法集合 &#x3D; T1 的方法集合 +*T2 的方法集合类型 </li><li>*T 的方法集合 &#x3D; *T1 的方法集合 + *T2 的方法集合</li></ul><p>注意 *T 类型的方法集合，它包含的可不是 T1 类型的方法集合，而是 *T1 类型的方法集合。</p><h4 id="defined-定义-类型与-alias-别名-类型的方法集合"><a href="#defined-定义-类型与-alias-别名-类型的方法集合" class="headerlink" title="defined (定义) 类型与 alias (别名) 类型的方法集合"></a>defined (定义) 类型与 alias (别名) 类型的方法集合</h4><p>defined (定义) 类型不会继承，新 defined 类型要想实现那些接口，仍然需要重新实现接口的所有方法。<br>无论原类型是接口类型还是非接口类型，类型别名都与原类型拥有完全相同的方法集合。</p><p>Define 的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-keyword">type</span> T1 T<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> t T<br>  <span class="hljs-keyword">var</span> pt *T<br>  <span class="hljs-keyword">var</span> t1 T1<br>  <span class="hljs-keyword">var</span> pt1 *T1<br><br>  dumpMethodSet(t)<br>  dumpMethodSet(t1)<br><br>  dumpMethodSet(pt)<br>  dumpMethodSet(pt1)<br>&#125;<br><span class="hljs-comment">//输出</span><br>main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">main.T1&#x27;</span>s method set is empty!<br><br>*main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T1&#x27;</span>s method set is empty!<br></code></pre></td></tr></table></figure><p>Alias 的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-keyword">type</span> T1 = T<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-keyword">var</span> pt *T<br>    <span class="hljs-keyword">var</span> t1 T1<br>    <span class="hljs-keyword">var</span> pt1 *T1<br><br>    dumpMethodSet(t)<br>    dumpMethodSet(t1)<br><br>    dumpMethodSet(pt)<br>    dumpMethodSet(pt1)<br>&#125;<br><span class="hljs-comment">//输出</span><br>main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">main.T&#x27;</span>s method set:<br>- M1<br><br>*main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T&#x27;</span>s method set:<br>- M1<br>- M2<br></code></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><a href="https://learnku.com/articles/44099">Golang 学习——interface 接口学习（一） | Go 技术论坛</a><br>在 <strong>Golang</strong> 中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。它与 <code>OOP(面向对象编程)</code> 非常相似。接口指定了类型应该具有的方法，类型决定了如何实现这些方法。<br>接口类型是由 type 和 interface 关键字定义的一组方法集合。</p><h3 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1. 定义接口"></a>1. 定义接口</h3><p>使用关键字 <code>interface</code> 用来定义接口，语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> interface_name <span class="hljs-keyword">interface</span> &#123;<br>   method_name1([args ...arg_type]) [return_type]<br>   method_name2([args ...arg_type]) [return_type]<br>   method_name3 ([args ... arg_type]) [return_type]<br>   ...<br>   method_namen([args ...arg_type]) [return_type]<br>&#125;<br></code></pre></td></tr></table></figure><p>（跳过大部分）</p><h3 id="2-空接口"><a href="#2-空接口" class="headerlink" title="2. 空接口"></a>2. 空接口</h3><p><code>Golang</code> 很多库的源代码都会以空接口作为参数，表示接受任意类型的参数<br>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个空接口</span><br><span class="hljs-keyword">type</span> Empyt_interface <span class="hljs-keyword">interface</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 定义一个入参为任意类型的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getInfo</span><span class="hljs-params">(arg Empyt_interface)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;getInfo 函数.....&quot;</span>, arg)<br>&#125;<br><span class="hljs-comment">// 也可以写成如下形式，更推荐</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getInfo2</span><span class="hljs-params">(arg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;getInfo2 函数.....&quot;</span>, arg)<br>&#125;<br></code></pre></td></tr></table></figure><p>比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] <span class="hljs-keyword">interface</span>&#123;&#125;)<br>map1[<span class="hljs-string">&quot;数字&quot;</span>] = <span class="hljs-number">1</span><br>map1[<span class="hljs-string">&quot;字符串&quot;</span>] = <span class="hljs-string">&quot;字符串&quot;</span><br>map1[<span class="hljs-string">&quot;布尔&quot;</span>] = <span class="hljs-literal">false</span><br>fmt.Println(<span class="hljs-string">&quot;map1 ...........&quot;</span>, map1)<br><span class="hljs-comment">//输出</span><br>map1 ........... <span class="hljs-keyword">map</span>[字符串:字符串 布尔:<span class="hljs-literal">false</span> 数字:<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="Go-并发-goroutine"><a href="#Go-并发-goroutine" class="headerlink" title="Go 并发 goroutine"></a>Go 并发 goroutine</h2><h3 id="并发-1"><a href="#并发-1" class="headerlink" title="并发"></a>并发</h3><p><a href="https://learnku.com/go/t/30845">[奔跑的 Go] 教程十五、深入学习 Go 语言的并发编程 | Go 优质外文翻译 | Go 技术论坛</a><br>并发（concurrency）与 并行（parallelism）<br><strong>并发不是并行，并发关乎结构，并行关乎执行。</strong><br><strong>并行（parallelism）</strong>，指的就是在同一时刻，有两个或两个以上的任务的代码在处理器上执行。<br><strong>并发 concurrency）</strong> 考虑的是如何将应用划分为多个互相配合的、可独立执行的模块的问题。采用并发设计的程序并不一定是并行执行的。<br><strong>并发是同时处理多个事物，并行是同时做多个事物</strong>。<br>将程序分成多个可独立执行的部分的结构化程序的设计方法，就是<strong>并发设计</strong>。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230223155040.png]]</p><p><strong>并发：</strong> 针对的是程序结构设计，将一个程序分成若干个模块，不同模块单独执行，由多个模块相互交替执行，实现程序的运行。<br><strong>并行：</strong> 针对的程序的执行，指的是同一时间点，有个多个任务在被多个或者多核的 CPU 下调度执行。</p><p>传统编程语言（如 C、C++ 等）中，基于多线程模型的应用设计就是一种典型的并发程序设计。<br>传统多线程是以操作系统线程做执行单元的。<br>传统多线程是以操作系统线程作为承载分解后的代码片段（模块）的执行单元，由操作系统执行调度。这种传统支持并发的方式有很多不足：</p><ul><li>复杂</li><li>难以规模化</li></ul><h3 id="Go-的并发"><a href="#Go-的并发" class="headerlink" title="Go 的并发"></a>Go 的并发</h3><p>Go 并没有使用操作系统线程作为承载分解后的代码片段（模块）的基本执行单元，而是实现了 goroutine 这一由 Go 运行时（runtime）负责调度的、轻量的用户级线程，为并发程序设计提供原生支持。<br>goroutine 的优势主要是：</p><ul><li>资源占用小，每个 goroutine 的初始<strong>栈</strong>大小仅为 2k；</li><li>由 Go 运行时而不是操作系统调度，goroutine 上下文切换在用户层完成，开销更小；</li><li>在语言层面而不是通过标准库提供。goroutine 由 go 关键字创建，一退出就会被回收或销毁，开发体验更佳；</li><li>语言内置 channel 作为 goroutine 间通信原语，为并发设计提供了强大支撑。<br>Go 语言是面向并发而生的，所以，在程序的结构设计阶段，Go 的惯例是优先考虑并发设计。</li></ul><h4 id="goroutine-的基本用法"><a href="#goroutine-的基本用法" class="headerlink" title="goroutine 的基本用法"></a>goroutine 的基本用法</h4><p><a href="https://learnku.com/go/t/31082">[奔跑的 Go] 教程十六、深入学习 Go 并发编程之 goroutine | Go 优质外文翻译 | Go 技术论坛</a><br><strong>并发</strong>是一种能力，它让你的程序可以由若干个<strong>代码片段组合而成</strong>，并且每个片段都是独立运行的。goroutine 恰恰就是 Go 原生支持并发的一个具体实现。无论是 Go 自身运行时代码还是用户层 Go 代码，都无一例外地运行在 goroutine 中。</p><h4 id="创建和退出-goroutine"><a href="#创建和退出-goroutine" class="headerlink" title="创建和退出 goroutine"></a>创建和退出 goroutine</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建方式：go关键字+函数/方法</span><br><span class="hljs-keyword">go</span> fmt.Println(<span class="hljs-string">&quot;I am a goroutine&quot;</span>) <br><br><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>    c &lt;- a + b<br>&#125;(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br> <br><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br>c := srv.newConn(rw)<br><span class="hljs-keyword">go</span> c.serve(connCtx)<br></code></pre></td></tr></table></figure><p>通过 go 关键字，我们可以基于已有的具名函数 &#x2F; 方法创建 goroutine，也可以基于匿名函数 &#x2F; 闭包创建 goroutine。</p><p>多数情况下，我们不需要考虑对 goroutine 的退出进行控制：<strong>goroutine 的执行函数的返回，就意味着 goroutine 退出。</strong><br>如果 main goroutine 退出了，那么也意味着整个应用程序的退出。此外，你还要注意的是，<strong>goroutine 执行的函数或方法即便有返回值，Go 也会忽略这些返回值</strong>。<br>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   <span class="hljs-keyword">go</span> printHello()  <br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br><span class="hljs-comment">//输出</span><br>main() started<br>main() stopped<br></code></pre></td></tr></table></figure><p><strong>为什么我们看不到 printHello 函数的输出？</strong><br>这是因为，每个 go 应用程序都会创建一个 goroutine，main 函数在其中运行，称为 main goroutine。在上述情况下，main goroutine 生成另一个 goroutine 运行 printHello 函数，我们叫它 printHello goroutine。因此，当我们执行上述程序时，同时运行了两个 goroutine。<br>我们已经了解到，goroutine 是协同调度的。因此，在 main goroutine 执行完之前，printHello goroutine 不会执行。不幸的是，当 main goroutine 执行完毕后，程序会立即结束，调度器没有时间安排 printHello goroutine 执行。但是从之前的课程我们知道，我们可以通过阻塞当前 goroutine，通知调度器运行其他可用的 goroutine，即手动将控制权传递到其他 goroutine。我们可以使用 time. Sleep () 来实现这个目的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   <span class="hljs-keyword">go</span> printHello()  <br>   time.Sleep(<span class="hljs-number">10</span> * time.Millisecond)  <span class="hljs-comment">// 10ms 之后_</span><br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br><span class="hljs-comment">//输出</span><br>main() started<br>Hello World<br>main() stopped<br></code></pre></td></tr></table></figure><p>在 main goroutine 执行最后一行代码前，通过调用 time. Sleep (10 * time. Millisecond) ，把控制权传递给 printHello goroutine。在这种情况下，main goroutine 将休眠 10ms，在 10ms 内，调度器将不会再次执行它。一旦 printHello goroutine 执行，它向终端打印 「Hello World!」并终止，然后，main goroutine 继续被调度执行 堆栈指针指向的 最后一行代码（10ms 之后），因此 printHello 能够输出结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span></span> &#123;  <br>   time.Sleep(<span class="hljs-number">16</span> * time.Millisecond)  <span class="hljs-comment">// 16ms 之后 但是我测试15ms还是可以输出</span><br>   fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   <span class="hljs-keyword">go</span> printHello()  <br>   time.Sleep(<span class="hljs-number">10</span> * time.Millisecond)  <span class="hljs-comment">// 10ms 之后_</span><br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br><span class="hljs-comment">//输出</span><br>main() started<br>main() stopped<br></code></pre></td></tr></table></figure><p>现在我们已经明白了怎样去创建协程并使得它们协同工作。但是调度协程使用 time. Sleep 仅仅是一种 hack (折中) 手段。在生产环境中，我们不知道一个协程的运行时间，因此我们不能仅仅在主线程中去添加一个随机休眠时间。我们期望是让协程在执行结束后主动告诉我们。同样的，我们也不能从协程接收数据和发送数据。简单来说就是我们无法和协程进行数据交互操作。而 <strong>golang 的通道</strong>就是用来解决上述痛点的。</p><h5 id="匿名协程"><a href="#匿名协程" class="headerlink" title="匿名协程"></a>匿名协程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;  <br>      fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)  <br>   &#125;()  <span class="hljs-comment">//和上面的作用是差不多的。</span><br>   time.Sleep(<span class="hljs-number">10</span> * time.Millisecond)  <br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Goroutine-之间的通讯"><a href="#Goroutine-之间的通讯" class="headerlink" title="Goroutine 之间的通讯"></a>Goroutine 之间的通讯</h3><p>传统语言的并发模型是基于对内存的共享的。<br>Go 的并发模型这设计是借鉴的 <strong>CSP</strong>（Communicating Sequential Processes，通信顺序进程）并发模型。<br>（????）</p><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p><strong>通道</strong> 是用于协程间交流的通信载体。严格地来说，通道就是数据传输的管道，数据通过这根管道被 “传入” 或被 “读出”。 因此协程可以发送数据到通道中，而另一个协程可以从该通道中读取数据。</p><h5 id="声明一个通道"><a href="#声明一个通道" class="headerlink" title="声明一个通道"></a>声明一个通道</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">//声明了一个nil通道，但这是没有用的。</span><br>c:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-comment">//必须使用 make 函数器创建一个可以使用的通道。</span><br></code></pre></td></tr></table></figure><h5 id="通道的读写操作"><a href="#通道的读写操作" class="headerlink" title="通道的读写操作"></a>通道的读写操作</h5><p>Go 语言提供一个非常简洁的左箭头语法 <code>&lt;-</code> 去从通道读写数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c &lt;- data<br></code></pre></td></tr></table></figure><p>上面的代码意味着我们想要把 <code>data</code> 数据推入到通道 <code>c</code>. 注意看箭头的指向。它表明是从 <code>data</code> to 通道 <code>c</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;- c<br></code></pre></td></tr></table></figure><p>上面的代码表明我们想要从通道 c 读一些数据。注意看箭头的指向，它从通道 c 开始。这个语句不会把数据传输给任何变量，但是仍然是一个有效的语句。如果你希望有一个变量来接收通道 C 的数据，你可以使用下面的语句:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> data <span class="hljs-type">int</span><br>data = &lt;- c<br><span class="hljs-comment">//使用语法:= 重写</span><br>data := &lt;- c<span class="hljs-comment">//自动判断 data 变量的数据类型。</span><br></code></pre></td></tr></table></figure><p>现在来自 int 类型通道 c 的数据就可以被存储到 int 类型变量 data 中。</p><p>通道操作默认是阻塞的. 通道操作本质上是阻塞的。当一些数据被写入通道，对应的协程将阻塞直到有其他的协程可以从此通道接收数据。 同时正如我们之前看的文章 concurrency chapter, 通道操作会通知调度器去调度其他的协程，这就是为什么程序不会一直阻塞在一个协程。通道的这些特性在不同的协程沟通的时候非常有用，它避免了我们使用锁或者一些 hack 手段去达到阻塞协程的目的。(不是很懂)</p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p><strong>当通道读写数据时，所在协程会阻塞并且调度控制权会转移到其他未阻塞的协程。</strong></p><p>如果当前协程正在从一个没有任何值的通道中读取数据，那么当前协程会阻塞并且等待其他协程往此通道写入值。因此，读操作将被阻塞。同理，如果你发送数据到一个通道，它将阻塞当前协程直到有其他协程从通道中读取数据。此时写操作将阻塞。</p><p>通道阻塞的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span> <span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;  <br>   fmt. Println (<span class="hljs-string">&quot;Hello &quot;</span> + &lt;-c + <span class="hljs-string">&quot;!&quot;</span>)  <br>   fmt.Println(<span class="hljs-string">&quot;Hello &quot;</span> + &lt;-c + <span class="hljs-string">&quot;!&quot;</span>)   <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">1</span>)  <br>   <span class="hljs-keyword">go</span> greet(c)  <br>   c &lt;- <span class="hljs-string">&quot;John&quot;</span>  <br>   <span class="hljs-comment">//close(c)  </span><br>   c &lt;- <span class="hljs-string">&quot;Mike&quot;</span>  <br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br><span class="hljs-comment">//无close</span><br>main() started<br>Hello John!<br>Hello Mike!<br>main() stopped<br><span class="hljs-comment">//有close</span><br>main() started<br>Hello John!<br>Hello !<br><span class="hljs-built_in">panic</span>: send on closed channel <span class="hljs-comment">//不能够像已经关闭的通道里面传数据</span><br></code></pre></td></tr></table></figure><h5 id="关闭-channel"><a href="#关闭-channel" class="headerlink" title="关闭 channel"></a>关闭 channel</h5><p><strong>可以使用 close 来关闭通道。</strong><br><strong>从已经关闭的通道接收数据或者正在接收数据时，将会接收到通道类型的零值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">n := &lt;- ch      <span class="hljs-comment">// 当ch被关闭后，n将被赋值为ch元素类型的零值</span><br>m, ok := &lt;-ch   <span class="hljs-comment">// 当ch被关闭后，m将被赋值为ch元素类型的零值, ok值为false</span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123; <span class="hljs-comment">// 当ch被关闭后，for range循环结束</span><br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>channel 的一个使用惯例: <strong>发送端负责关闭 channel。因为发送端没有像接受端那样的、可以安全判断 channel 是否被关闭了的方法。同时，一旦向一个已经关闭的 channel 执行发送操作，这个操作就会引发 panic</strong><br>所以对于普通的 for 循环需要手动去关闭通道，比如下面那样。不过 go 的 for range 在通道关闭的时候主动退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squares</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;  <br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++ &#123;  <br>      c &lt;- i * i  <br>   &#125;  <br>   <span class="hljs-built_in">close</span>(c)  <span class="hljs-comment">//不关闭的话会死锁</span><br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)  <br>   <span class="hljs-keyword">go</span> squares(c)  <br>   <span class="hljs-comment">//for &#123;  </span><br>    <span class="hljs-comment">//  val, ok := &lt;-c  </span><br>    <span class="hljs-comment">//  if ok == false &#123;  </span><br>    <span class="hljs-comment">//     fmt.Println(val, ok, &quot;&lt;-- loop broke&quot;)  </span><br>    <span class="hljs-comment">//     break  </span><br>     <span class="hljs-comment">// &#125; else &#123;  </span><br>    <span class="hljs-comment">//     fmt.Println(val, ok)  </span><br>    <span class="hljs-comment">//  &#125;  </span><br>   <span class="hljs-comment">//&#125;  </span><br>   <span class="hljs-keyword">for</span> val := <span class="hljs-keyword">range</span> c &#123;  <br>      fmt.Println(val)  <br>   &#125;  <br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="通道容量"><a href="#通道容量" class="headerlink" title="通道容量"></a>通道容量</h5><p>前面我们声明的都是无缓冲的通道，每次往无缓冲通道发送数据会阻塞当前协程，这是因为我们还没有使用 <code>make</code> 函数的第二个参数。这第二个参数代表通道缓冲区的容量。<br>默认情况下通道缓冲区容量为 0，被称为无缓冲通道。 向无缓冲通道发送的数据需要立即被读取。</p><p>当缓冲区参数不是 0 的时候。<strong>协程将不会阻塞除非缓冲区被填满</strong>。 当缓冲区满了之后，想要再往缓冲区发送数据只有等到有其他协程从缓冲区接收数据， (此时的发送协程是阻塞的)。 有一点需要注意， 读缓冲区的操作是<strong>渴望式读取</strong>.。意味着一旦读操作开始它将读取缓冲区所有数据，直到缓冲区为空。<strong>原理上来说读操作的协程将不会阻塞直到缓冲区为空。</strong> 而且<strong>如果通道没有放满，也不会阻止你去从通道读取数据</strong>.</p><p>可以使用以下语法定义有缓冲的 type 类型的通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Type, n)<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;Hello &quot;</span> + &lt;-c + <span class="hljs-string">&quot;!&quot;</span>)  <br>   fmt.Println(<span class="hljs-string">&quot;Hello &quot;</span> + &lt;-c + <span class="hljs-string">&quot;!&quot;</span>)  <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">//前面例子里面这里是1</span><br>   <span class="hljs-keyword">go</span> greet(c)  <br>   c &lt;- <span class="hljs-string">&quot;John&quot;</span>   <br>   c &lt;- <span class="hljs-string">&quot;Mike&quot;</span>  <br>   <span class="hljs-comment">//c &lt;- &quot;Mike2&quot;  </span><br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br><span class="hljs-comment">// 输出</span><br>main() started<br>main() stopped<br><span class="hljs-comment">// /c &lt;- &quot;Mike2&quot;  </span><br>main() started<br>Hello John!<br>Hello Mike!<br>main() stopped<br></code></pre></td></tr></table></figure><h5 id="通道的长度和容量"><a href="#通道的长度和容量" class="headerlink" title="通道的长度和容量"></a>通道的长度和容量</h5><p>和切片类似，一个缓冲通道也有长度和容量。通道的长度是其内部缓冲队列未读的数据量，而通道的容量是缓冲区可最大盛放的数据量。我们可以使用 <code>len</code> 函数去计算通道的长度，使用 <code>cap</code> 函数去获得通道的容量<br><strong>虽然通道没有放满，也不会阻止你去从通道读取数据</strong>.<br><strong>虽然通道关闭了，但是数据还在缓冲区，我们仍然可以获取这些数据。</strong></p><h5 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h5><p>目前为止的通道都是双向通道，我们可以对通道做<strong>读操作</strong>和<strong>写操作</strong>。但是事实上我们也可以创建单向通道。比如<strong>只读通道</strong>只允许读操作，<strong>只写通道</strong>只允许写操作。<br>单向通道也可以使用 make 函数创建，不过需要额外加一个箭头语法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">roc := <span class="hljs-built_in">make</span> (&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-comment">//读</span><br>soc := <span class="hljs-built_in">make</span> (<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)<span class="hljs-comment">//写</span><br>fmt.Printf(<span class="hljs-string">&quot;Data type of roc is `%T`\n&quot;</span>, roc)  <br>fmt.Printf(<span class="hljs-string">&quot;Data type of soc is `%T`\n&quot;</span>, soc)<br><span class="hljs-comment">//输出</span><br>Data <span class="hljs-keyword">type</span> of roc is <span class="hljs-string">`&lt;-chan int`</span><br>Data <span class="hljs-keyword">type</span> of soc is <span class="hljs-string">`chan&lt;- int`</span><br></code></pre></td></tr></table></figure><p><strong>但是单向通道有什么作用呢</strong> ?<br>使用单向通道可以 <strong>提高程序的类型安全性</strong>， 使得程序不容易出错。</p><p>但是假如你在一个协程中只需要<strong>读操作</strong>某通道，但是在主线程中却需要<strong>读写操作</strong>这个通道该怎么办呢？<br>幸运的是 Go 可以直接把<strong>双向通道转化为单向通道</strong>。<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230224151335.png]]</p><h5 id="通道类型的通道"><a href="#通道类型的通道" class="headerlink" title="通道类型的通道"></a>通道类型的通道</h5><p>通道也是一种类型可以像其他类型一样被用在很多地方：比如结构体元素，函数参数，函数返回值，甚至是作为其他通道的数据传输类型。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p><code>select</code> 和 <code>switch</code> 很像，它不需要输入参数，并且仅仅被使用在通道操作上。</p><p>通过 select，我们可以同时在多个 channel 上进行发送 &#x2F; 接收操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> x := &lt;-ch1:     <span class="hljs-comment">// 从channel ch1接收数据</span><br>  ... ...<br><br><span class="hljs-keyword">case</span> y, ok := &lt;-ch2: <span class="hljs-comment">// 从channel ch2接收数据，并根据ok值判断ch2是否已经关闭</span><br>  ... ...<br><br><span class="hljs-keyword">case</span> ch3 &lt;- z:       <span class="hljs-comment">// 将z值发送到channel ch3中:</span><br>  ... ...<br><br><span class="hljs-keyword">default</span>:             <span class="hljs-comment">// 当上面case中的channel通信均无法实施时，执行该默认分支</span><br>&#125;<br></code></pre></td></tr></table></figure><p>default 分支可以使 select 语句永不阻塞. 这意味着， 任何通道的 发送 和 接收 操作 (不管是缓冲或者非缓冲) 都不会阻塞当前线程。<br>如果有 case 块的通道操作是非阻塞，那么 select 会执行其 case 块。如果没有那么 select 将默认执行 default 块.<br>当 select 语句中没有 default 分支，而且所有 case 中的 channel 操作都阻塞了的时候，整个 select 语句都将被阻塞，直到某一个 case 上的 channel 变成可发送，或者某个 case 上的 channel 变成可接收，select 语句才可以继续进行下去。</p><p>注意：<strong>一个 nil 通道的 case 块会被忽略</strong>. <strong>select{}也是正确的语法，但是它会一直阻塞</strong><br>Nil 的用法就是，之前一直用 nil 通道使得 case 块被忽略，然后再激活。</p><h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p><strong>WaitGroup</strong> 是一个带着计数器的 <code>结构体</code>，这个计数器可以追踪到有多少协程创建，有多少协程完成了其工作。当计数器为 0 的时候说明所有协程都完成了其工作。<br>它主要有三个方法：<code>Add</code>, <code>Wait</code> 和 <code>Done</code></p><ul><li><code>Add</code> 方法的参数是一个变量名叫 <code>delta</code> 的 <code>int</code> 类型参数，主要用来内部计数。部计数器默认值为 0，它用于记录多少个协程在运行。当协程建立后，<code>计数器</code> 的值不会自动递增 ，因此需要我们手动递增它。我们可以通过给 <code>Add</code> 方法传 int 类型值来增加它的数量。</li><li><code>Done</code> 方法可以降低计数器的值。他不接受任何参数，因此，它每执行一次计数器就减 1。</li><li><code>Wait</code> 方法用来阻塞当前协程。一旦 <code>计数器</code> 为 0, 被阻塞的协程将恢复运行。<br>实例如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">service</span><span class="hljs-params">(wg *sync.WaitGroup, instance <span class="hljs-type">int</span>)</span></span> &#123;  <br>   time.Sleep(<span class="hljs-number">2</span> * time.Second)  <br>   fmt.Println(<span class="hljs-string">&quot;Service called on instance&quot;</span>, instance)  <br>   wg.Done()  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   fmt.Println(<span class="hljs-string">&quot;main() started&quot;</span>)  <br>   <span class="hljs-keyword">var</span> wg sync.WaitGroup  <br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;  <br>      wg.Add(<span class="hljs-number">1</span>)  <br>      <span class="hljs-keyword">go</span> service(&amp;wg, i)  <br>   &#125;  <br>   wg.Wait()  <br>   fmt.Println(<span class="hljs-string">&quot;main() stopped&quot;</span>)  <br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子中，我们在创建 wg 变量后，运行了三次 for 循环，每次运行的时候我们创建一个协程并给计数器加 1。 这意味着现在我们有三个协程在等待运行并且 WaitGroup 的计数器值为 3。注意我们传给协程函数的是一个指针，这是因为一旦在协程内部工作完成后，我们需要通过调用 Done 方法去降低计数器的值。 如果 wg 通过值复制方式传过去， 因为传递的是一个拷贝，主线程中的 wg 将不会得到修改。 </p><p>在 for 循环执行完成后，我们通过调用 wg. Wait () 去阻塞当前主线程，并把调度权让给其他协程，直到计数器值为 0 之后，主线程才会被再次调度。我们在另外三个协程中通过 Done 方法把计数器值降为 0，此时主线程将再次被调度并开始执行之后的代码。</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>goroutines 都有自己的独立的调用栈，因此他们之间不分享任何数据。但是有一种情况是数据存放在堆上，并且被多个 goroutines 使用。 多个 goroutines 试图去操作一个内存区域的数据会造成意想不到的后果。而互斥锁就是用来解决这个问题的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span> <span class="hljs-params">(wg *sync. WaitGroup)</span></span> &#123;  <br>   i = i + <span class="hljs-number">1</span>  <br>   wg. Done ()  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   <span class="hljs-keyword">var</span> wg sync.WaitGroup  <br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;  <br>      wg.Add(<span class="hljs-number">1</span>)  <br>      <span class="hljs-keyword">go</span> worker(&amp;wg)  <br>   &#125;  <br>   wg.Wait()  <span class="hljs-comment">//建了1000个协程</span><br>   fmt.Println(<span class="hljs-string">&quot;value of i after 1000 operations is &quot;</span>, i)  <br>&#125;<br><span class="hljs-comment">//输出</span><br>value of i after <span class="hljs-number">1000</span> operations is  <span class="hljs-number">983</span><br></code></pre></td></tr></table></figure><p>例如让我们从 1000 个 goroutines 中拿出两个举个例子，标明 G1 和 G2。</p><p>G1 开始执行的时候 i 为 0, 运行两步之后 i 现在是 1. 但是在 G1 执行第三步更新 i 的值的时候，新的协程 G2 被调度并且执行了 3 个步骤。 因此现在 i 的值为 1。现在 G1 又一次被调度从第二步开始更新了 i 的值。理想情况下，2 个协程调度后 i 的值应该是 2，但是事实却不是这样。因此我们可以猜想到为什么结果不是 1000。</p><p>目前为止我们学习到的调度方式都是协同调度。我们知道除非一个协程阻塞，否则其他协程是没有机会获得调度的。那么 i &#x3D; i + 1 也没有阻塞，为什么 Go 的调度器会去调度其他协程呢？ 好像不是很可靠。<br><strong>在任何情况下，都不应该依赖 Go 的调度算法，而应该实现自己的逻辑来同步不同的 goroutine</strong>（比如互斥锁）<br>互斥锁是一个编程概念，它保证了在同一时间只能有一个线程或者协程去操作同一个数据。当一个协程想要操作数据的时候，必须获取该数据的一个锁，操作完成后必须释放锁，如果没有获取到该数据的锁，那么就不能操作这个数据。<br>我们需要在操作数据之前使用 mutex. Lock () 去锁定它，一旦我们完成操作，比如上面提到的 i &#x3D; i + 1, 我们就可以使用  mutext. Unlock () 方法解锁。如果在锁定的时候，有一个协程想要读写 i 的值，那么此协程将阻塞 直到前面的协程完成操作并解锁数据。因此在某一时刻有且仅有一个协程可以操作数据，从而避免竞态条件。记住，任何锁之间的变量在解锁之前对于其他协程都不是可用的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(wg *sync.WaitGroup, m *sync.Mutex)</span></span> &#123;  <span class="hljs-comment">//新增m</span><br>   m.Lock()  <span class="hljs-comment">//加锁</span><br>   i = i + <span class="hljs-number">1</span>  <br>   m.Unlock()  <span class="hljs-comment">//解锁</span><br>   wg.Done()  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   <span class="hljs-keyword">var</span> wg sync.WaitGroup  <br>   <span class="hljs-keyword">var</span> m sync.Mutex  <span class="hljs-comment">//定义一个锁</span><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;  <br>      wg.Add(<span class="hljs-number">1</span>)  <br>      <span class="hljs-keyword">go</span> worker(&amp;wg, &amp;m)  <br>   &#125;  <br>   wg.Wait()  <br>   fmt.Println(<span class="hljs-string">&quot;value of i after 1000 operations is &quot;</span>, i)  <br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的结果来看互斥锁可以帮助我们解决竞态条件。 <strong>但首要规则是避免 goroutine 之间共享资源</strong>。</p><h2 id="图书管理-API-服务"><a href="#图书管理-API-服务" class="headerlink" title="图书管理 API 服务"></a>图书管理 API 服务</h2><h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><p>在这个实战小项目中，我们模拟的是真实世界的一个书店的图书管理后端服务。这个服务为平台前端以及其他客户端，提供针对图书的 CRUD（创建、检索、更新与删除）的基于 HTTP 协议的 API。API 采用典型的 RESTful 风格设计，这个服务提供的 API 集合如下：<br>![[【Go基础】未整理合集&#x2F;Pasted image 20230206223859.png]]<br>简单来说，我们通过 id 来唯一标识一本书，对于图书来说，这个 id 通常是 ISBN 号。至于客户端和服务端中请求与响应的数据，我们采用放在 HTTP 协议包体（Body）中的 Json 格式数据来承载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">mkdir</span> bookstore</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">cd</span> bookstore</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">go mod init bookstore</span><br>go: creating new go.mod: module bookstore<br></code></pre></td></tr></table></figure><p>这个服务大体拆分为两大部分，一部分是 HTTP 服务器，用来对外提供 API 服务；另一部分是图书数据的存储模块，所有的图书数据均存储在这里。</p><p><strong>项目布局</strong></p><pre><code class="hljs">├── cmd/│   └── bookstore/         // 放置 bookstore main 包源码│       └── main. go├── go. mod                 // module bookstore 的 go. mod├── go. sum├── internal/              // 存放项目内部包的目录│   └── store/│       └── memstore. go     ├── server/                // HTTP 服务器模块│   ├── middleware/│   │   └── middleware. go│   └── server. go          └── store/                 // 图书数据存储模块    ├── factory/    │   └── factory. go└── store. go</code></pre><p>store. go 提供了 图书 和 接口的模板<br>factory. go 用于生产 接口实例<br>memstore. go 用于具体实现一个接口实例，实现其方法，并把样例发送到工厂<br>server. go 用于把路由和接口的方法对接起来</p><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><h4 id="什么是空导入"><a href="#什么是空导入" class="headerlink" title="什么是空导入"></a>什么是空导入</h4><p>像下面代码这样的包导入方式被称为“空导入”： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;foo&quot;</span> <br></code></pre></td></tr></table></figure><p>空导入也是导入，意味着我们将依赖 foo 这个路径下的包。但由于是空导入，我们并没有显式使用这个包中的任何语法元素。<br>那么空导入的意义是什么呢？</p><p>由于依赖 foo 包，程序初始化的时候会沿着包的依赖链初始化 foo 包，包的初始化会按照常量-&gt;变量-&gt;init 函数的次序进行。通常实践中空导入意味着期望依赖包的 init 函数得到执行，这个 init 函数中有我们需要的逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go刷题】ACM输入输出</title>
    <link href="/2023/03/17/%E3%80%90Go%E5%88%B7%E9%A2%98%E3%80%91ACM%E8%BE%93%E5%85%A5/"/>
    <url>/2023/03/17/%E3%80%90Go%E5%88%B7%E9%A2%98%E3%80%91ACM%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a,b,x <span class="hljs-type">int</span><br><br>fmt.Scan(&amp;a,&amp;b) <span class="hljs-comment">// 一个或多个数据绑定。用空格分割stdin输入数据，并把换行符算作空格，然后传递给本函数的参数</span><br><br>fmt.Scanln(&amp;a,&amp;b) <span class="hljs-comment">// 类似Scan，遇到换行停止扫描，必须在最后一项之后有换行符或EOF</span><br><br>fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x) <span class="hljs-comment">// 对空格分割的字符串或其他数据类型格式化，会把换行符也当作输入的！由于数据是先缓存，然后再传递给参数，所以如果格式中没有换行符，但输入回车换行，会保存到下一个参数中！</span><br><span class="hljs-comment">//尽可能的少用Scanf</span><br><br>bufio.NewScanner(os.Stdin)<br><span class="hljs-string">`os.Stdin`</span>是标准输入描述结构，类似C语言中的<span class="hljs-string">`FILE`</span>。处理输入的时候将该结构使用<span class="hljs-string">`bufio`</span>包中的<span class="hljs-string">`Scanner`</span>类型进行包装。每次调用<span class="hljs-string">`input.Scan()`</span>，即读入下一行，并移除行末的换行符，读取的内容可以使用<span class="hljs-string">`input.Text()`</span>获取。<br></code></pre></td></tr></table></figure><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><h3 id="不知道行数（需要一直读入，直到没有）"><a href="#不知道行数（需要一直读入，直到没有）" class="headerlink" title="不知道行数（需要一直读入，直到没有）"></a>不知道行数（需要一直读入，直到没有）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">输入描述:<br>输入包括两个正整数 a,b(1 &lt;= a, b &lt;= 1000),输入数据包括多组。<br><br>输出描述:<br>输出a+b的结果<br><br>输入例子1:<br>1 5<br>10 20<br><br>输出例子1:<br>6<br>30<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">0</span><br>b := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123;<br>n, _ := fmt.Scan(&amp;a, &amp;b)  <span class="hljs-comment">//也可以用 fmt.Scan</span><br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, a+b)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="知道行数-经典模式"><a href="#知道行数-经典模式" class="headerlink" title="知道行数 (经典模式)"></a>知道行数 (经典模式)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">输入描述:<br>输入第一行包括一个数据组数t(1 &lt;= t &lt;= 100)<br>接下来每行包括两个正整数a,b(1 &lt;= a, b &lt;= 1000)<br><br>输出描述:<br>输出a+b的结果<br><br>输入例子1:<br>2<br>1 5<br>10 20<br><br>输出例子1:<br>6<br>30<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> t,a,b <span class="hljs-type">int</span><br>    fmt.Scanln(&amp;t)<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;t;i++&#123;<br>        fmt.Scanln(&amp;a,&amp;b)<br>        fmt.Println(a+b)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="每行数字数量不固定，且不知道数量-必须整行读取"><a href="#每行数字数量不固定，且不知道数量-必须整行读取" class="headerlink" title="每行数字数量不固定，且不知道数量 (必须整行读取)"></a>每行数字数量不固定，且不知道数量 (必须整行读取)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">输入描述:<br>输入数据有多组, 每行表示一组输入数据。<br><br>每行不定有n个整数，空格隔开。(1 &lt;= n &lt;= 100)。<br><br>输出描述:<br>每组数据输出求和的结果<br><br>输入例子1:<br>1 2 3<br>4 5<br>0 0 0 0 0<br><br>输出例子1:<br>6<br>9<br>0<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;strconv&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    inputs := bufio.NewScanner(os.Stdin)<br>    <span class="hljs-keyword">for</span> inputs.Scan() &#123;  <span class="hljs-comment">//每次读入一行</span><br>        data := strings.Split(inputs.Text(), <span class="hljs-string">&quot; &quot;</span>)  <span class="hljs-comment">//通过空格将他们分割，并存入一个字符串切片</span><br>        <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> data &#123;<br>            val, _ := strconv.Atoi(data[i])   <span class="hljs-comment">//将字符串转换为int</span><br>            sum += val<br>        &#125;<br>        fmt.Println(sum)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="读字符串"><a href="#读字符串" class="headerlink" title="读字符串"></a>读字符串</h1><h2 id="1-读一行字符串"><a href="#1-读一行字符串" class="headerlink" title="1. 读一行字符串"></a>1. 读一行字符串</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">输入描述:<br>输入有两行，第一行n<br>第二行是n个字符串，字符串之间用空格隔开<br><br>输出描述:<br>输出一行排序后的字符串，空格隔开，无结尾空格<br><br>输入例子1:<br>5<br>c d a bb e<br><br>输出例子1:<br>a bb c d e<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span>(<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;sort&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    in := bufio.NewScanner(os.Stdin)<br>    in.Scan()<br>    <span class="hljs-keyword">for</span> in.Scan()&#123;<br>        str := in.Text()<br>        s := strings.Split(str, <span class="hljs-string">&quot; &quot;</span>)<br>        sort.Strings(s)  <span class="hljs-comment">//排序</span><br>        fmt.Println(strings.Join(s,<span class="hljs-string">&quot; &quot;</span>))  <span class="hljs-comment">//将切片s里面的值连接成字符串</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//下面这样也可以</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br>    fmt.Scan(&amp;n)<br>    <span class="hljs-keyword">var</span> s []<span class="hljs-type">string</span><br>    <span class="hljs-keyword">var</span> t <span class="hljs-type">string</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        fmt.Scan(&amp;t)<br>        s = <span class="hljs-built_in">append</span>(s, t)<br>    &#125;<br>    fmt.Print(s)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-读多行字符串"><a href="#2-读多行字符串" class="headerlink" title="2. 读多行字符串"></a>2. 读多行字符串</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">输入描述:<br>多个测试用例，每个测试用例一行。<br><br>每行通过空格隔开，有n个字符，n＜100<br><br>输出描述:<br>对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开<br><br>输入例子1:<br>a c bb<br>f dddd<br>nowcoder<br><br>输出例子1:<br>a bb c<br>dddd f<br>nowcoder<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;sort&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    input := bufio.NewScanner(os.Stdin)<br>    <span class="hljs-keyword">for</span> input.Scan()&#123;<br>        data := strings.Split(input.Text(),<span class="hljs-string">&quot; &quot;</span>)<br>        sort.Strings(data)<br>        fmt.Println(strings.Join(data, <span class="hljs-string">&quot; &quot;</span>))<span class="hljs-comment">//把data里面的值用&quot; &quot;拼接起来</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>将输入读入到数组中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span>  <br>   <span class="hljs-comment">//var m [n + 5]int  会报错  </span><br>   m := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n) <span class="hljs-comment">//m := make([]int, n+5)  go中最好不要用这种写法 </span><br>   fmt.Scan(&amp;n)  <br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;  <br>      fmt.Scan(&amp;m[i])  <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机网络】TCP相关</title>
    <link href="/2023/03/10/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91TCP%E7%9B%B8%E5%85%B3/"/>
    <url>/2023/03/10/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91TCP%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>TCP 的全称叫传输层控制协议（Transmission Control Protocol），⼤部分应⽤使⽤的正是 TCP 传输层协议，⽐如 HTTP 应⽤层协议。TCP 相⽐ UDP 多了很多特性，⽐如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对⽅。</p><p>握手是为了建立可靠的连接，可靠连接是通过序列号，确认应答，重传机制等来实现的。同时，作为一个广泛使用的网络协议，会通过滑动窗口和推迟确认在对数据传输进行优化，在复杂网络时会通过流量控制和拥塞控制对传输进行控制。</p><h2 id="TCP-头部的格式"><a href="#TCP-头部的格式" class="headerlink" title="TCP 头部的格式"></a>TCP 头部的格式</h2><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91TCP%E7%9B%B8%E5%85%B3/image-20230310104141178.png"></p><ul><li><strong>序列号</strong>: 在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。</li><li><strong>确认应答号</strong>: 指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。</li></ul><p><strong>控制位</strong>:</p><ul><li><p>ACK︰该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。</p></li><li><p>RST: 该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</p></li><li><p>SYN∶该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</p></li><li><p>FN: 该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</p></li></ul><h2 id="UDP-头部格式"><a href="#UDP-头部格式" class="headerlink" title="UDP 头部格式"></a>UDP 头部格式</h2><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91TCP%E7%9B%B8%E5%85%B3/image-20230310104330574.png"></p><ul><li>目标和源端口: 主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度: 该字段保存了 UDP 首部的长度跟数据的长度之和。（占位符？）</li><li>校验和: 校验和是为了提供可靠的 UDP 首部和数据而设计。</li></ul><h2 id="有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少"><a href="#有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少" class="headerlink" title="有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少?"></a>有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少?</h2><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91TCP%E7%9B%B8%E5%85%B3/image-20230310110445185.png"></p><p>其中：<br>客户端 IP 数最多为：2^32<br>客户端端口数最多为：2^16<br>因此，最大 TCP 连接数为：2^48</p><h2 id="UDP-和-TCP-有什么区别呢？"><a href="#UDP-和-TCP-有什么区别呢？" class="headerlink" title="UDP 和 TCP 有什么区别呢？"></a>UDP 和 TCP 有什么区别呢？</h2><ol><li>连接</li></ol><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><ol start="2"><li>服务对象</li></ol><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、—对多、多对多的交互通信</li></ul><ol start="3"><li>可靠性</li></ol><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul><ol start="4"><li>拥塞控制、流量控制</li></ol><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><ol start="5"><li>首部开销</li></ol><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部有 8 个字节，并且是固定不变的，开销较小。</li></ul><ol start="6"><li>传输方式</li></ol><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><ol start="7"><li>分片不同</li></ol><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。</li></ul><h2 id="TCP-和-UDP-应用场景："><a href="#TCP-和-UDP-应用场景：" class="headerlink" title="TCP 和 UDP 应用场景："></a>TCP 和 UDP 应用场景：</h2><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于:</p><ul><li><p>FTP 文件传输</p></li><li><p>HTTP &#x2F; HTTPS</p></li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于:</p><ul><li><p>包总量较少的通信，如 DNS . SNMP 等</p></li><li><p>视频、音频等多媒体通信</p></li><li><p>广播通信</p></li></ul><h2 id="如何唯一确定一个-TCP-连接？"><a href="#如何唯一确定一个-TCP-连接？" class="headerlink" title="如何唯一确定一个 TCP 连接？"></a>如何唯一确定一个 TCP 连接？</h2><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91TCP%E7%9B%B8%E5%85%B3/image-20230310110524519.png"><br>通过这四个可以唯一确认一个 tcp 连接。</p><p>源地址和目的地址的字段 (32 位〉是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p><p>源端口和目的端口的字段（16 位〉是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p><h2 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h2><p>需要进行三次握手</p><p>总共需要发送三次报文，其中 SYN 为 1 表示序列号有值，ACK 为 1 表示确认应答号有值。</p><ul><li><p>第一次握手：Client 将 SYN 置 1，随机产生一个初始序列号 seq 发送给 Server，进入 SYN_SENT 状态；</p></li><li><p>第二次握手：Server 收到 Client 的 SYN&#x3D;1 之后，知道客户端请求建立连接，将自己的 SYN 置 1，ACK 置 1，产生一个 acknowledge number&#x3D;sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入 SYN_RCVD 状态；</p></li><li><p>第三次握手：客户端检查 acknowledge number 是否为序列号+1，ACK 是否为 1，检查正确之后将自己的 ACK 置为 1，产生一个 acknowledge number&#x3D;服务器发的序列号+1，发送给服务器；进入 ESTABLISHED 状态；服务器检查 ACK 为 1 和 acknowledge number 为序列号+1 之后，也进入 ESTABLISHED 状态；完成三次握手，连接建立。</p></li></ul><h2 id="为什么是三次握手而不是两次或四次？"><a href="#为什么是三次握手而不是两次或四次？" class="headerlink" title="为什么是三次握手而不是两次或四次？"></a>为什么是三次握手而不是两次或四次？</h2><ol><li>三次握手才可以阻止重复历史连接的初始化 (主要原因) </li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ol><h3 id="为什么不是两次？"><a href="#为什么不是两次？" class="headerlink" title="为什么不是两次？"></a>为什么不是两次？</h3><p>C: 我要给你发数据</p><p>S: 好的，可以，我知道了</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费（尤其是接收方），也无法可靠的同步双方序列号；</li></ul><p>接收方在收到任何的 syn 后就开始分配资源建立连接了。而这个 syn 有可能是旧的已经不用的 syn，也有可能是因为网络延迟而迟到的 syn。而在两次握手的情况下，接收端都会给他们分配资源。</p><p>至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91TCP%E7%9B%B8%E5%85%B3/image-20230310110753034.png"></p><h3 id="为什么不是四次？"><a href="#为什么不是四次？" class="headerlink" title="为什么不是四次？"></a>为什么不是四次？</h3><ul><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><p>如果是四次的话，那就是</p><p>C: 我要给你发送数据</p><p>S: 好的，没问题，我知道了</p><p>S：你知道我知道了吗？</p><p>C: 我知道你知道了。</p><p>其中 中间两条可以合并为一条也就是</p><p>好的没问题，你能收到我的消息吗？</p><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91TCP%E7%9B%B8%E5%85%B3/image-20230310110832280.png"></p><h2 id="TCP-连接断开"><a href="#TCP-连接断开" class="headerlink" title="TCP 连接断开"></a>TCP 连接断开</h2><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91TCP%E7%9B%B8%E5%85%B3/image-20230310110859233.png"></p><ul><li>C 打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后 C 进入 <code>FIN_WAIT_1</code> 状态。</li><li>S 收到该报文后，就向 C 发送 <code>ACK</code> 应答报文，接着 S 进入 <code>CLOSE_WAIT</code> 状态。</li><li>C 收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待 S 处理完数据后，也向 C 发送 <code>FIN</code> 报文，之后 S 进入 <code>LAST_ACK</code> 状态。</li><li>C 收到 S 的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>S 收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此 S 已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。<br>其中：</li><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>通俗理解：<br>主动关闭的 C 方要礼貌一点。<br>C: 我想要关闭连接了    Fin-&gt;S<br>S: 好的我知道了，我在准备关闭，准备好了告诉你 ACK-&gt;C<br>S：我准备好关闭了  FIN-&gt;C<br>C: 好的，那我们关闭吧  ACK-&gt;S  得到这个 ack 后 S close<br>C 等 2MSL 时间再正式关闭<br>MSL：最大报文段生存时间</p><p>每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。<br><strong>只有主动关闭连接的，才有 TIME_WAIT 状态</strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机网络】HTTP相关</title>
    <link href="/2023/03/10/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%9B%B8%E5%85%B3/"/>
    <url>/2023/03/10/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>HTTP 是超⽂本传输协议，也就是 HyperText Transfer Protocol。HTTP 在应用层。</p><p>HTTP 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」。</p><h2 id="HTTP-常见的状态码："><a href="#HTTP-常见的状态码：" class="headerlink" title="HTTP 常见的状态码："></a>HTTP 常见的状态码：</h2><p>1xx；2xx；3xx；4xx；5xx<br><a href="https://zyweven.github.io/2023/03/01/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%8A%B6%E6%80%81%E7%A0%81/">【计算机网络】HTTP状态码 - Even</a></p><h2 id="HTTP-常见字段"><a href="#HTTP-常见字段" class="headerlink" title="HTTP 常见字段"></a>HTTP 常见字段</h2><h4 id="Host-字段"><a href="#Host-字段" class="headerlink" title="Host 字段"></a>Host 字段</h4><p>发出方：客户端发送请求时<br>作用：用来指定服务器的域名。</p><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%9B%B8%E5%85%B3/image-20230310103934830.png"></p><h4 id="Content-Length-字段"><a href="#Content-Length-字段" class="headerlink" title="Content-Length 字段"></a>Content-Length 字段</h4><p>发出方：服务器<br>作用：表明本次回应的数据长度</p><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%9B%B8%E5%85%B3/image-20230310103948232.png"></p><h4 id="Connection-字段"><a href="#Connection-字段" class="headerlink" title="Connection 字段"></a>Connection 字段</h4><p>发出方：客户端<br>作用：要求服务器使用 TCP 持久连接，以便其他请求复用。<br>HTTP&#x2F;1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive</p><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%9B%B8%E5%85%B3/image-20230310103957647.png"></p><h4 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h4><p>发出方：服务器<br>作用：用于回应时告诉客户端本次的数据是什么格式</p><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%9B%B8%E5%85%B3/image-20230310104018085.png"></p><h4 id="Content-Encoding-字段"><a href="#Content-Encoding-字段" class="headerlink" title="Content-Encoding 字段"></a>Content-Encoding 字段</h4><p>发出方：服务器<br>作用：说明数据的压缩方式<br><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%9B%B8%E5%85%B3/image-20230310104030535.png"></p><h2 id="HTTP-请求方法："><a href="#HTTP-请求方法：" class="headerlink" title="HTTP 请求方法："></a>HTTP 请求方法：</h2><p>8 种方法：OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE 和 CONNECT。<br>其中 GET 和 POST 是最常用的。</p><h3 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h3><p>Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。<br>而 POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。</p><h2 id="HTTP-1-1-；HTTP-2；HTTP-3-演变"><a href="#HTTP-1-1-；HTTP-2；HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1 ；HTTP&#x2F;2；HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1 ；HTTP&#x2F;2；HTTP&#x2F;3 演变</h2><h3 id="HTTP-1-1-相比-HTTP-1-0-性能上的改进"><a href="#HTTP-1-1-相比-HTTP-1-0-性能上的改进" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进:"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进:</h3><ul><li>使用 TCP 长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li><li>支持管道（pipeline) 网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><h3 id="HTTP-2-相比-HTTP-1-1-性能上的改进︰"><a href="#HTTP-2-相比-HTTP-1-1-性能上的改进︰" class="headerlink" title="HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进︰"></a>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进︰</h3><p>1．头部压缩<strong>HPACK</strong><br>HTTP&#x2F;2 会压缩头 (Header) 如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。<br>这就是所谓的 <strong>HPACK</strong> 算法︰在客户端和服务器同时维护―张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><ol start="2"><li><p>二进制格式<br>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧 (frame) ︰头信息帧和数据帧。增加了数据传输的效率。</p></li><li><p>数据流 <strong>Stream</strong><br>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>每个请求或回应的所有数据包，称为一个<strong>数据流（Stream )</strong>。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数<br>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p></li><li><p>多路复用<br>HTTP&#x2F;2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。<br>移除了 HTTP&#x2F;1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。<br>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p></li><li><p>服务器推送<br>HTTP&#x2F;2 还在一定程度上改善了传统的「请求-应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。<br>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送 (Server Push，也叫 Cache Push) 。</p></li></ol><h3 id="HTTP-3-相比-HTTP-2-性能上的改进︰"><a href="#HTTP-3-相比-HTTP-2-性能上的改进︰" class="headerlink" title="HTTP&#x2F;3 相比 HTTP&#x2F;2 性能上的改进︰"></a>HTTP&#x2F;3 相比 HTTP&#x2F;2 性能上的改进︰</h3><p>HTTP&#x2F;2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。</p><ul><li>HTTP&#x2F;1.1 中的管道（ pipeline) 传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞</li><li>HTTP&#x2F;2 多个请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li></ul><p>这都是基于 TCP 传输层的问题，所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP</p><p>UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP&#x2F;1.1 的队头阻塞和 HTTP&#x2F;2 的一个丢包全部重传问题。<br>大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议可以实现类似 TCP 的可靠性传输。</p><ul><li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。</li><li>TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。</li><li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS&#x2F;1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS&#x2F;1.3 的 6 次交互合并成了 3 次，减少了交互次数。</li></ul><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%9B%B8%E5%85%B3/image-20230310103913079.png"></p><p>目前很多都还是用的是 HTTP&#x2F;1.1 , 不过 2 已经有很多大公司在用了。3 的话由于 QUIC 是新的协议，很多网络设备不知道它，会把 UDP 还是当成 UDP，所以 3 的普及非常缓慢…</p><h2 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h2><p>区别：</p><ol><li><p>端口不同：HTTP 使用的是 80 端口，HTTPS 使用 443 端口；</p></li><li><p>HTTP（超文本传输协议）信息是明文传输，HTTPS 运行在 SSL (Secure Socket Layer) 之上，添加了加密和认证机制，更加安全；</p></li><li><p>HTTPS 由于加密解密会带来更大的 CPU 和内存开销；</p></li><li><p>HTTPS 通信需要证书，一般需要向证书颁发机构（CA）购买</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机网络】网络模型</title>
    <link href="/2023/03/06/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/03/06/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>网络模型分为 <strong>OSI 参考模型</strong>和 <strong>TCP&#x2F;IP 模型</strong>。<br><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/image-20230306211357043.jpeg"></p><p>TCP&#x2F;IP 四层从上往下依次是：应用层、传输层、网络层（互联网层）、链路层（数据链路层&#x2F;网络接口层）。与 OSI 七层的映射关系如下：<br><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/image-20230306211447989.png"></p><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/image-20230310103557799.png"></p><h2 id="包在网络中的传递过程-？"><a href="#包在网络中的传递过程-？" class="headerlink" title="包在网络中的传递过程 ？"></a>包在网络中的传递过程 ？</h2><p>在计算机网络中，包在网络中的传递过程主要经历了以下几个步骤：</p><ol><li><p>应用层封装：发送方的应用程序将数据转换成报文，并添加报文头部信息，如源地址、目标地址、协议类型等，然后将报文传递给传输层。</p></li><li><p>传输层封装：传输层会将应用层的数据分割成适合网络传输的数据段，并在每个数据段的头部添加 TCP 或 UDP 的控制信息，如端口号、序列号、确认号等，然后将数据段传递给网络层。</p></li><li><p>网络层封装：网络层将传输层的<strong>数据段</strong>打包成 IP <strong>数据包</strong>，并在 IP 数据包头部添加源 IP 地址、目标 IP 地址等信息，然后将 IP 数据包传递给链路层。</p></li><li><p>链路层封装：链路层将 IP <strong>数据包</strong>转换成适合链路传输的<strong>数据帧</strong>，并在数据帧头部添加物理地址、帧类型等信息，然后将数据帧传递给物理层。</p></li><li><p>物理层传输：物理层将数据帧转换成电信号，通过物理介质进行传输。</p></li><li><p>接收方反向过程：接收方的物理层接收到电信号后，会逆向解析成数据帧，并依次进行解封装，直到应用层获得数据。</p></li></ol><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/image-20230310103613344.png"></p><p><img src="/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/image-20230310103619581.png"></p><h2 id="OSI-七层和-TCP-IP-的区别："><a href="#OSI-七层和-TCP-IP-的区别：" class="headerlink" title="OSI 七层和 TCP&#x2F;IP 的区别："></a>OSI 七层和 TCP&#x2F;IP 的区别：</h2><ul><li><p>TCP&#x2F;IP 是一个协议簇；而 OSI 则是一个模型。</p></li><li><p>TCP&#x2F;IP 是由一些交互性的模块做成的分层次的协议，其中每个模块提供特定的功能；OSI 则指定了哪个功能是属于哪一层的。</p></li><li><p>TCP&#x2F;IP 四层是 OSI 七层的简化版。</p></li></ul><h2 id="分层的好处是什么呢-？"><a href="#分层的好处是什么呢-？" class="headerlink" title="分层的好处是什么呢 ？"></a>分层的好处是什么呢 ？</h2><p>分层的本质是通过分离关注点而让复杂问题简单化，通过分层可以做到：</p><p>各层独立：限制了依赖关系的范围，各层之间使用标准化的接口，各层不需要知道上下层是如何工作的，增加或者修改一个应用层协议不会影响传输层协议<br>灵活性更好：比如路由器不需要应用层和传输层，分层以后路由器就可以只用加载更少的几个协议层<br>易于测试和维护：提高了可测试性，可以独立的测试特定层，某一层有了更好的实现可以整体替换掉能促进标准化：每一层职责清楚，方便进行标准化</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go基础】包管理2——GO Module</title>
    <link href="/2023/03/05/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E5%8C%85%E7%AE%A1%E7%90%862%E2%80%94%E2%80%94GO%20Module/"/>
    <url>/2023/03/05/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E5%8C%85%E7%AE%A1%E7%90%862%E2%80%94%E2%80%94GO%20Module/</url>
    
    <content type="html"><![CDATA[<p>从 Go 1.11 版本开始有 Go Module</p><p>一个 Go Module 是一个 Go 包的集合。module 是有版本的，所以 module 下的包也就有了版本属性。这个 module 与这些包会组成一个独立的版本单元，它们一起打版本、发布和分发。</p><p>在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。一个 Go Module 的顶层目录下会放置一个 go. mod 文件，每个 go. mod 文件会定义唯一一个 module，它们是一一对应的关系。</p><p>go. mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。</p><h2 id="如何创建一个-Go-module"><a href="#如何创建一个-Go-module" class="headerlink" title="如何创建一个 Go module"></a>如何创建一个 Go module</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> mod init <span class="hljs-comment">//创建 go. mod 文件，将当前项目变为一个 Go Module；</span><br><span class="hljs-keyword">go</span> mod tidy <span class="hljs-comment">//命令自动更新当前 module 的依赖信息</span><br><span class="hljs-keyword">go</span> build  <span class="hljs-comment">//执行新 module 的构建</span><br></code></pre></td></tr></table></figure><h3 id="指令解析"><a href="#指令解析" class="headerlink" title="指令解析"></a>指令解析</h3><p><strong>go mod init</strong></p><p>go mod init 会在当前项目目录下创建了一个 go. mod 文件。</p><hr><p><strong>go mod tidy</strong> </p><p>go mod tidy 命令会扫描 Go 源码，并自动找出项目依赖的外部 Go Module 以及版本，下载这些依赖并更新本地的 go. mod 文件。</p><p>执行完 go mod tidy 后，当前项目除了 go. mod 文件外，还多了一个新文件 go. sum，它同样是由 go mod 相关命令维护的一个文件，它存放了特定版本 module 内容的哈希值，它可以确保项目所依赖的 module 内容，不会被恶意或意外篡改。</p><p>由 go mod tidy 下载的依赖 module 会被放置在本地的 module 缓存路径下，默认值为 $GOPATH[0]&#x2F;pkg&#x2F;mod，Go 1.15 及以后版本可以通过 GOMODCACHE 环境变量，自定义本地 module 的缓存路径。</p><hr><p><strong>go build</strong></p><p>go build 命令会读取 go. mod 中的依赖及版本信息，并在本地 module 缓存路径下找到对应版本的依赖 module，执行编译和链接。如果顺利的话，我们会在当前目录下看到一个新生成的可执行文件 module-mode，执行这个文件我们就能得到正确结果了。</p><h2 id="Go-Module-构建模式的特点"><a href="#Go-Module-构建模式的特点" class="headerlink" title="Go Module 构建模式的特点"></a>Go Module 构建模式的特点</h2><p>有两个特点：</p><ul><li><p>语义导入版本机制</p></li><li><p>最小版本选择原则</p></li></ul><h3 id="语义导入版本机制"><a href="#语义导入版本机制" class="headerlink" title="语义导入版本机制"></a>语义导入版本机制</h3><p><img src="/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E5%8C%85%E7%AE%A1%E7%90%862%E2%80%94%E2%80%94GO%20Module/image-20230305144529145.png"></p><p>如上图，语义版本号分成 3 部分：主版本号 (major)、次版本号 (minor) 和补丁版本号 (patch)。</p><p>例如 logrus module 的版本号是 v1.8.1，这就表示它的主版本号为 1，次版本号为 8，补丁版本号为 1。</p><p>按照语义版本规范，主版本号不同的两个版本是相互不兼容的。而且，在主版本号相同的情况下，次版本号大都是向后兼容次版本号小的版本。补丁版本号也不影响兼容性。</p><p><strong>Go Module 规定：如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的。</strong></p><p>那么如果之前我们一直使用的是 logrus v1 的版本，而 logrus 发布了和 v1 不兼容的 v2 版本时我们应该使用什么方式导入 logrus v2.0.0 版本呢？</p><p>Go Module 创新性地给出了一个方法：<strong>将包主版本号引入到包导入路径中。</strong> </p><p>这就是 Go 的“语义导入版本”机制，也就是说<strong>通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本，这样一来我们甚至可以同时依赖一个包的两个不兼容版本</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/sirupsen/logrus&quot;</span> <span class="hljs-comment">//导入 v1</span><br>    logv2 <span class="hljs-string">&quot;github.com/sirupsen/logrus/v2&quot;</span> <span class="hljs-comment">//导入 v2</span><br>)<br></code></pre></td></tr></table></figure><h3 id="最小版本选择原则"><a href="#最小版本选择原则" class="headerlink" title="最小版本选择原则"></a>最小版本选择原则</h3><p><img src="/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E5%8C%85%E7%AE%A1%E7%90%862%E2%80%94%E2%80%94GO%20Module/image-20230305144515012.png"></p><p>在这张图中，myproject 有两个直接依赖 A 和 B，A 和 B 有一个共同的依赖包 C，但 A 依赖 C 的 v1.1.0 版本，而 B 依赖的是 C 的 v1.3.0 版本，并且此时 C 包的最新发布版为 C v1.7.0 。那么我们应该使用 C 的哪个版本？</p><p>对于一些其他依赖管理工具可能会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 v1.7.0。</p><p>而对于 <strong>Go</strong> 会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本”。</p><p>这个例子中，C v1.3.0 是符合项目整体要求的版本集合中的版本最小的那个，于是 <strong>Go 命令选择了 C v1.3.0</strong>，而不是最新最大的 C v1.7.0。</p><p>并且，Go 团队认为“最小版本选择”为 Go 程序实现持久的和可重现的构建提供了最佳的方案。</p><p><strong>注意</strong>：Go Module 将 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径。</p><h2 id="包管理实践"><a href="#包管理实践" class="headerlink" title="包管理实践"></a>包管理实践</h2><h3 id="为当前-module-添加一个依赖"><a href="#为当前-module-添加一个依赖" class="headerlink" title="为当前 module 添加一个依赖"></a>为当前 module 添加一个依赖</h3><p>可以使用手工执行 go get 新增依赖项，也可以使用 go mod tidy 自动分析和下载依赖项的最终效果，它们是等价的。</p><p>但对于复杂的项目变更而言，逐一手工添加依赖项显然很没有效率，go mod tidy 是更佳的选择。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">方法一<br>go get github.com/google/uuid  #  手动添加<br><br>go: downloading github.com/google/uuid v1.3.0<br>go get: added github.com/google/uuid v1.3.0<br><br>方法二<br>go mod tidy  # 自动检测<br><br>go: finding module for package github.com/google/uuid<br>go: found github.com/google/uuid in github.com/google/uuid v1.3.0<br></code></pre></td></tr></table></figure><h3 id="升级-降级依赖的版本"><a href="#升级-降级依赖的版本" class="headerlink" title="升级 &#x2F; 降级依赖的版本"></a>升级 &#x2F; 降级依赖的版本</h3><p>以 logrus 为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用一下指令可以查询logrus的多个发布版本</span><br>go list -m -versions github.com/sirupsen/logrus<br><br>github.com/sirupsen/logrus v0.1.0 v0.1.1 v0.2.0 v0.3.0 v0.4.0 v0.4.1 v0.5.0 v0.5.1 v0.6.0 v0.6.1 v0.6.2 v0.6.3 v0.6.4 v0.6.5 v0.6.6 v0.7.0 v0.7.1 v0.7.2 ...<br></code></pre></td></tr></table></figure><p>如果我们想从 v1.8.1 降到 v1.7.0，可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/sirupsen/logrus@v1.7.0<br><br>go: downloading github.com/sirupsen/logrus v1.7.0<br>go get: downgraded github.com/sirupsen/logrus v1.8.1 =&gt; v1.7.0<br></code></pre></td></tr></table></figure><p>或者使用 go mod tidy 也可以，但是要先编辑 go mod 明确告知我们要依赖 v1.7.0 版本，而不是 v1.8.1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">go mod edit -require=github.com/sirupsen/logrus@v1.7.0<br><br>go mod tidy       <br><br>go: downloading github.com/sirupsen/logrus v1.7.0<br></code></pre></td></tr></table></figure><h3 id="添加一个主版本号大于-1-的依赖"><a href="#添加一个主版本号大于-1-的依赖" class="headerlink" title="添加一个主版本号大于 1 的依赖"></a>添加一个主版本号大于 1 的依赖</h3><p>语义导入版本机制有一个原则：如果新旧版本的包使用相同的导入路径，那么新包与旧包是兼容的。也就是说，<strong>如果新旧两个包不兼容，那么我们就应该采用不同的导入路径。</strong><br>如果我们要为 Go 项目添加主版本号大于 1 的依赖，我们就需要使用“语义导入版本”机制，在声明它的导入路径的基础上，加上版本号信息。<br>比如 redis 的导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>  _ <span class="hljs-string">&quot;github.com/go-redis/redis/v7&quot;</span> <span class="hljs-comment">// “_”为空导入</span><br>  <span class="hljs-string">&quot;github.com/google/uuid&quot;</span><br>  <span class="hljs-string">&quot;github.com/sirupsen/logrus&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  logrus.Println(<span class="hljs-string">&quot;hello, go module mode&quot;</span>)<br>  logrus.Println(uuid.NewString())<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/go-redis/redis/v7<br><br>go: downloading github.com/go-redis/redis/v7 v7.4.1<br>go: downloading github.com/go-redis/redis v6.15.9+incompatible<br>go get: added github.com/go-redis/redis/v7 v7.4.1<br></code></pre></td></tr></table></figure><h3 id="升级依赖版本到一个不兼容版本"><a href="#升级依赖版本到一个不兼容版本" class="headerlink" title="升级依赖版本到一个不兼容版本"></a>升级依赖版本到一个不兼容版本</h3><p>假如我们想把 redis v7 升级到 v8<br>首先在代码中把 v7 改成 v8</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>  _ <span class="hljs-string">&quot;github.com/go-redis/redis/v8&quot;</span><br>  <span class="hljs-string">&quot;github.com/google/uuid&quot;</span><br>  <span class="hljs-string">&quot;github.com/sirupsen/logrus&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/go-redis/redis/v8<br><br>go: downloading github.com/go-redis/redis/v8 v8.11.1<br>go: downloading github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f<br>go: downloading github.com/cespare/xxhash/v2 v2.1.1<br>go get: added github.com/go-redis/redis/v8 v8.11.1<br></code></pre></td></tr></table></figure><p>就可以了</p><h3 id="移除一个依赖"><a href="#移除一个依赖" class="headerlink" title="移除一个依赖"></a>移除一个依赖</h3><p>要想彻底从项目中移除 go. mod 中的依赖项，仅从源码中删除对依赖项的导入语句还不够。这是因为如果源码满足成功构建的条件，go build 命令是不会“多管闲事”地清理 go. mod 中多余的依赖项的。</p><p>那正确的做法是怎样的呢？我们还得用 go mod tidy 命令，将这个依赖项彻底从 Go Module 构建上下文中清除掉。go mod tidy 会自动分析源码依赖，而且将不再使用的依赖从 go. mod 和 go. sum 中移除。</p><p>也就是使用 go build 无效 而要用一次 go mod tidy 才行。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go基础】包管理</title>
    <link href="/2023/03/05/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E5%8C%85%E7%AE%A1%E7%90%861%E2%80%94%E2%80%94GOPATH%20and%20Vendor/"/>
    <url>/2023/03/05/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91%E5%8C%85%E7%AE%A1%E7%90%861%E2%80%94%E2%80%94GOPATH%20and%20Vendor/</url>
    
    <content type="html"><![CDATA[<p>Go 的包管理经历了三个演变过程：</p><p><strong>GOPATH</strong>  -&gt; <strong>Vendor</strong> -&gt; <strong>GO Module</strong></p><p>目前基本都使用的是 GO Module 的方式来进行包管理，不过这里先看前两个。</p><h2 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h2><p>Go 编译器可以在本地 GOPATH 环境变量配置的路径下，搜寻 Go 程序依赖的第三方包。如果存在，就使用这个本地包进行编译；如果不存在，就会报编译错误。</p><h3 id="GOPATH-的使用"><a href="#GOPATH-的使用" class="headerlink" title="GOPATH 的使用"></a>GOPATH 的使用</h3><p>如果当前的 GOPATH 为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GOPATH=/usr/local/goprojects:/home/tonybai/go<br></code></pre></td></tr></table></figure><p>那么 Go 编译器在编译 Go 程序时，就会在下面两个路径下搜索第三方依赖包是否存在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/goprojects/src/github.com/user/repo<br>/home/tonybai/go/src/github.com/user/repo<br></code></pre></td></tr></table></figure><p>如果没有找到的话，就需要程序员使用 go get 来将本地缺失的第三方依赖包下载到本地如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/sirupsen/logrus<br></code></pre></td></tr></table></figure><p>这里的 go get 命令，不仅能将 logrus 包下载到 GOPATH 环境变量配置的目录下，它还会检查 logrus 的依赖包在本地是否存在，如果不存在，go get 也会一并将它们下载到本地。<br>但是，go get 下载的包只是那个时刻各个依赖包的最新主线版本。而依赖包是会持续演进的，这就不能保证程序的可重现的构建（Reproduceable Build）。</p><h3 id="GOPATH-的问题"><a href="#GOPATH-的问题" class="headerlink" title="GOPATH 的问题"></a>GOPATH 的问题</h3><p>在 GOPATH 构建模式下，&#x3D;&#x3D;Go 编译器实质上并没有关注 Go 项目所依赖的第三方包的版本。&#x3D;&#x3D;</p><p>但 Go 开发者希望自己的 Go 项目所依赖的第三方包版本能受到自己的控制，而不是随意变化。于是 Go 核心开发团队引入了 Vendor 机制试图解决上面的问题。</p><h2 id="Vendor"><a href="#Vendor" class="headerlink" title="Vendor"></a>Vendor</h2><p>Go 在 1.5 版本中引入 vendor 机制。vendor 机制本质上就是在 Go 项目的某个特定目录下，将项目的所有依赖包缓存起来，这个特定目录名就是 vendor。</p><p>Go 编译器会优先感知和使用 <strong>vendor 目录</strong>下缓存的第三方包版本，而不是 GOPATH 环境变量所配置的路径下的第三方包版本。这样，无论第三方依赖包自己如何变化，无论 GOPATH 环境变量所配置的路径下的第三方包是否存在、版本是什么，都不会影响到 Go 程序的构建。</p><p>只要将 vendor 目录和项目源码一样提交到代码仓库，那么其他开发者下载这个项目，都可以实现可重现的构建。因此，如果使用 vendor 机制管理第三方依赖包，最佳实践就是将 vendor 一并提交到代码仓库中。</p><p>要想开启 vendor 机制，<strong>Go 项目必须位于 GOPATH 环境变量配置的某个路径的 src 目录下面</strong>。如果不满足这一路径要求，那么 Go 编译器是不会理会 Go 项目目录下的 vendor 目录。</p><h3 id="vendor-的问题"><a href="#vendor-的问题" class="headerlink" title="vendor 的问题"></a>vendor 的问题</h3><p>一方面，Go 项目必须放在 GOPATH 环境变量配置的路径下，庞大的 vendor 目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度，而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响。（感觉就像是把 vue 项目里面的 module 给一起上传到 GitHub 一样）</p><p>另一方面，还需要手工管理 vendor 下面的 Go 依赖包，包括项目依赖包的分析、版本的记录、依赖包获取和存放，等等。</p><p>Go Module 构建模式下，可以无需手动维护 vendor 目录下的依赖包了，Go 提供了可以快速建立和更新 vendor 的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">go mod vendor  //使用该指令<br><br>tree -LF 2 vendor<br>vendor<br>├── github.com/<br>│   ├── google/<br>│   ├── magefile/<br>│   └── sirupsen/<br>├── golang.org/<br>│   └── x/<br>└── modules.txt<br></code></pre></td></tr></table></figure><p>go mod vendor 命令在 vendor 目录下，创建了一份这个项目的依赖包的副本，并且通过 vendor&#x2F;modules. txt 记录了 vendor 下的 module 以及版本。</p><p>如果我们要基于 vendor 构建，而不是基于本地缓存的 Go Module 构建，我们需要在 go build 后面加上 -mod&#x3D;vendor 参数。</p><p>在 Go 1.14 及以后版本中，如果 Go 项目的顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非给 go build 传入 -mod&#x3D;mod 的参数。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go练习】TCP 端口扫描器</title>
    <link href="/2023/03/02/%E3%80%90Go%E7%BB%83%E4%B9%A0%E3%80%91TCP%20%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    <url>/2023/03/02/%E3%80%90Go%E7%BB%83%E4%B9%A0%E3%80%91TCP%20%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="普通循环写法"><a href="#普通循环写法" class="headerlink" title="普通循环写法"></a>普通循环写法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">21</span>; i &lt; <span class="hljs-number">120</span>; i++ &#123;  <br>      address := fmt.Sprintf(<span class="hljs-string">&quot;121.4.131.64:%d&quot;</span>, i)  <br>      conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, address)  <br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <br>         fmt.Printf(<span class="hljs-string">&quot;%s 关闭\n&quot;</span>, address)  <br>      &#125;  <br>      conn.Close()  <br>      fmt.Printf(<span class="hljs-string">&quot;%s 打开\n&quot;</span>, address)  <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并发写法"><a href="#并发写法" class="headerlink" title="并发写法"></a>并发写法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   start := time.Now()  <br>   <span class="hljs-keyword">var</span> wg sync.WaitGroup  <br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">21</span>; i &lt; <span class="hljs-number">120</span>; i++ &#123;  <br>      wg.Add(<span class="hljs-number">1</span>)  <br>      <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;  <br>         <span class="hljs-keyword">defer</span> wg.Done()  <br>         address := fmt.Sprintf(<span class="hljs-string">&quot;121.2.131.64:%d&quot;</span>, i)  <br>         conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, address)  <br>         <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <br>            fmt.Printf(<span class="hljs-string">&quot;%s 关闭\n&quot;</span>, address)  <br>            <span class="hljs-keyword">return</span>  <br>         &#125;  <br>         conn.Close()  <br>         fmt.Printf(<span class="hljs-string">&quot;%s 打开\n&quot;</span>, address)  <br>         <span class="hljs-comment">//wg.Done()  </span><br>      &#125;(i)  <br>   &#125;  <br>   wg.Wait()  <br>   elapsed := time.Since(start) / <span class="hljs-number">1e9</span>  <br>   fmt.Printf(<span class="hljs-string">&quot;\n\n 用时 %d&quot;</span>, elapsed)  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="worker池写法"><a href="#worker池写法" class="headerlink" title="worker池写法"></a>worker池写法</h2><p>多线程写法，同时对端口号进行了排序，使用两个通道来分别接收关闭的端口和开启的端口。</p><p><img src="/%E3%80%90Go%E7%BB%83%E4%B9%A0%E3%80%91TCP%20%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/image-20230305144556578.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">workerpool</span><span class="hljs-params">(ports <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, cresult <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, oresult <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;  <br>   <span class="hljs-keyword">defer</span> wg.Done()  <br>   <span class="hljs-keyword">for</span> port := <span class="hljs-keyword">range</span> ports &#123;  <br>      <span class="hljs-comment">//fmt.Println(port)  </span><br>      address := fmt.Sprintf(<span class="hljs-string">&quot;121.2.131.64:%d&quot;</span>, port)  <br>      conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, address)  <br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <br>         cresult &lt;- port  <br>         <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 注意这个 避免conn为nil时还去关闭它</span><br>         <span class="hljs-comment">//fmt.Printf(&quot;%s 关闭了\n&quot;, address)  </span><br>      &#125; <span class="hljs-keyword">else</span> &#123;  <br>         oresult &lt;- port  <br>      &#125;  <br>      conn.Close()  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>   start := time.Now()  <br>   <span class="hljs-keyword">var</span> wg sync.WaitGroup  <br>   nworker := <span class="hljs-number">20</span>  <br>   startPort := <span class="hljs-number">1</span>  <br>   endPort := <span class="hljs-number">1000</span>  <br>   cresults := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)  <br>   oresults := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)  <br>   ports := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">25</span>)  <br>   openports := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)  <br>   closeports := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)  <br>  <br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;  <br>      <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> cresults &#123;  <br>    closeports = <span class="hljs-built_in">append</span>(closeports, i)  <br>      &#125;  <br>   &#125;()  <br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;  <br>      <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> oresults &#123;  <br>    openports = <span class="hljs-built_in">append</span>(openports, i)  <br>      &#125;  <br>   &#125;()  <br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nworker; i++ &#123;  <br>      wg.Add(<span class="hljs-number">1</span>)  <br>      <span class="hljs-keyword">go</span> workerpool(ports, cresults, oresults, &amp;wg)  <br>   &#125;  <br>   <span class="hljs-keyword">for</span> i := startPort; i &lt; endPort; i++ &#123;  <br>      ports &lt;- i  <br>   &#125;  <br>   <span class="hljs-built_in">close</span>(ports)  <span class="hljs-comment">//把数据全部输入到ports之后关闭通道。</span><br>   wg.Wait()  <span class="hljs-comment">// 等待所有的 worker 完成任务</span><br>   <span class="hljs-built_in">close</span>(oresults)   <span class="hljs-comment">//这两个通道应该是在worker工作完之后才关闭</span><br>   <span class="hljs-built_in">close</span>(cresults)  <br>   sort.Ints(closeports)  <br>   sort.Ints(openports)  <br>   <span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> openports &#123;  <br>      fmt.Printf(<span class="hljs-string">&quot;121.2.131.64:%d 开\n&quot;</span>, i)  <br>   &#125;  <br>   <span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> closeports &#123;  <br>      fmt.Printf(<span class="hljs-string">&quot;121.2.131.64:%d 关\n&quot;</span>, i)  <br>   &#125;  <br>   elapsed := time.Since(start) / <span class="hljs-number">1e9</span>  <br>   fmt.Printf(<span class="hljs-string">&quot;一共用时 %d&quot;</span>, elapsed)  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go基础】Go安装</title>
    <link href="/2023/03/01/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91Go%E5%AE%89%E8%A3%85/"/>
    <url>/2023/03/01/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91Go%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://go.dev/dl/">https://go.dev/dl/</a></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>直接看官网就行了。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>参考这篇</p><p><a href="https://www.jianshu.com/p/c43ebab25484">https://www.jianshu.com/p/c43ebab25484</a></p><p>下载压缩包-&gt;解压-&gt;配置路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">`<span class="hljs-built_in">sudo</span> apt-get install vim`安装vim</span><br>vim /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在最后一行添加</span><br>export GOROOT=/usr/local/go<br>export PATH=$PATH:$GOROOT/bin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存退出后<span class="hljs-built_in">source</span>一下</span><br>source /etc/profile<br></code></pre></td></tr></table></figure><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><p>没有用过，略</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机网络】HTTP状态码</title>
    <link href="/2023/03/01/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/2023/03/01/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP-中的状态码"><a href="#HTTP-中的状态码" class="headerlink" title="HTTP 中的状态码"></a>HTTP 中的状态码</h1><h2 id="状态码的作用"><a href="#状态码的作用" class="headerlink" title="状态码的作用"></a>状态码的作用</h2><p>状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果，借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><p>状态码第一位数字决定了不同的响应状态，有如下：</p><ul><li>1 表示消息</li><li>2 表示成功</li><li>3 表示重定向</li><li>4 表示请求错误</li><li>5 表示服务器错误</li></ul><h2 id="1xx-【提示信息】"><a href="#1xx-【提示信息】" class="headerlink" title="1xx 【提示信息】"></a>1xx 【提示信息】</h2><p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束</p><p>常见的有：</p><ul><li><p>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</p></li><li><p>101：服务器根据客户端的请求切换协议，主要用于 websocket 或 http2 升级</p></li></ul><h2 id="2xx-【成功处理】"><a href="#2xx-【成功处理】" class="headerlink" title="2xx 【成功处理】"></a>2xx 【成功处理】</h2><p>代表请求已成功被服务器接收、理解、并接受</p><p>常见的有：</p><ul><li><p><strong>200（成功 OK）</strong>：请求已成功，请求所希望的响应头或数据体将随此响应返回。最常见的成功状态码，表示⼀切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</p></li><li><p>201（已创建）：请求成功并且服务器创建了新的资源</p></li><li><p>202（已创建）：服务器已经接收请求，但尚未处理</p></li><li><p>203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源</p></li><li><p><strong>204（无内容 No Content）</strong>：服务器成功处理请求，但没有返回任何内容,与 200 OK 基本相同，但响应头没有 body 数据。</p></li><li><p>205（重置内容）：服务器成功处理请求，但没有返回任何内容</p></li><li><p><strong>206（部分内容）</strong>：服务器成功处理了部分请求</p></li></ul><h2 id="3xx-【重定向】"><a href="#3xx-【重定向】" class="headerlink" title="3xx 【重定向】"></a>3xx 【重定向】</h2><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</p><p>常见的有：</p><ul><li><p>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</p></li><li><p><strong>301（永久移动</strong>）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</p></li><li><p><strong>302（临时移动</strong>）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。  表示临时重定向，说明请求的资源还在，但暂时需要用另⼀个 URL 来访问</p></li></ul><p>301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会自动重定向新的 URL</p><ul><li><p>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</p></li><li><p>304（Not Modified）不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制</p></li><li><p>305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理</p></li><li><p>307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</p></li></ul><h2 id="4xx-【客户端错误】"><a href="#4xx-【客户端错误】" class="headerlink" title="4xx 【客户端错误】"></a>4xx 【客户端错误】</h2><p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</p><p>常见的有：</p><ul><li><p><strong>400（错误请求）：</strong> 服务器不理解请求的语法。客户端报文有误，笼统的错误码，具体错误不知道。</p></li><li><p>401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p></li><li><p><strong>403（禁止）</strong>： 服务器拒绝请求。表示服务器禁止访问资源，并不是客户端的请求出错。</p></li><li><p><strong>404（未找到）</strong>： 服务器找不到请求的网页。表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p></li><li><p>405（方法禁用）： 禁用请求中指定的方法</p></li><li><p>406（不接受）： 无法使用请求的内容特性响应请求的网页</p></li><li><p>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</p></li><li><p>408（请求超时）： 服务器等候请求时发生超时</p></li></ul><h2 id="5xx-【服务端错误】"><a href="#5xx-【服务端错误】" class="headerlink" title="5xx 【服务端错误】"></a>5xx 【服务端错误】</h2><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p><p>常见的有：</p><ul><li><p><strong>500（服务器内部错误）</strong>：服务器遇到错误，无法完成请求。笼统的错误码，具体错误不知道</p></li><li><p>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码</p></li><li><p><strong>502（错误网关）</strong>： 服务器作为网关或代理，从上游服务器收到无效响应。表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。电话打通没人接。</p></li><li><p><strong>503（服务不可用）</strong>： 服务器目前无法使用（由于超载或停机维护）”网络服务正忙，请稍候重试”</p></li><li><p><strong>504（网关超时）</strong>： 服务器作为网关或代理，但是没有及时从上游服务器收到请求。电话打不通。</p></li></ul><p>502 是电话打通没人接，504 是电话打不通</p><ul><li>505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Go基础】new与make</title>
    <link href="/2023/02/28/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91new%E4%B8%8Emake/"/>
    <url>/2023/02/28/%E3%80%90Go%E5%9F%BA%E7%A1%80%E3%80%91new%E4%B8%8Emake/</url>
    
    <content type="html"><![CDATA[<h2 id="Go-语言当中-new-的作用是什么？"><a href="#Go-语言当中-new-的作用是什么？" class="headerlink" title="Go 语言当中 new 的作用是什么？"></a>Go 语言当中 new 的作用是什么？</h2><p>new 创建一个该类型的实例，并且返回指向该实例的指针。new 函数是内建函数，函数定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">new</span><span class="hljs-params">(Type)</span></span> *Type<br></code></pre></td></tr></table></figure><ul><li>使用 new 函数来分配空间</li><li>传递给 new 函数的是一个类型，而不是一个值</li><li>返回值是指向这个新分配的地址的指针</li></ul><h2 id="Go-语言中-make-的作用是什么？"><a href="#Go-语言中-make-的作用是什么？" class="headerlink" title="Go 语言中 make 的作用是什么？"></a>Go 语言中 make 的作用是什么？</h2><p>make 的作用是为 slice, map or chan 的初始化 然后返回引用 make 函数是内建函数，函数定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">make</span><span class="hljs-params">(Type, size IntegerType)</span></span> Type<br></code></pre></td></tr></table></figure><p>make (T, args) 函数的目的和 new (T) 不同 仅仅用于创建 slice, map, channel 而且返回类型是实例。</p><h2 id="golang-中-make-和-new-的区别？"><a href="#golang-中-make-和-new-的区别？" class="headerlink" title="golang 中 make 和 new 的区别？"></a>golang 中 make 和 new 的区别？</h2><p><strong>共同点</strong>：给变量分配内存。</p><p><strong>不同点</strong>：</p><ul><li><p>作用变量类型不同，new 给 string， int 和数组分配内存， make 给切片，map，channel 分配内存；</p></li><li><p>返回类型不一样，new 返回执行变量的指针， make 返回变量本身；</p></li><li><p>new 分配的空间被清零。make 分配空间后，会进行初始化。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建博客中遇到的坑</title>
    <link href="/2023/02/16/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E7%AE%80%E8%AE%B0/"/>
    <url>/2023/02/16/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><p>挺简单的，参考这个就可以了</p><p><a href="https://wushishu.xyz/post/be8880ea.html">Hexo+github搭建个人博客 | 武师叔</a> （已经失效了）</p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p><a href="https://hexo.io/zh-cn/">Hexo</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s  # 在本地浏览<br>hexo cl   # 清除已经生成的<br>hexo g    # 生成<br>hexo d    # 发布到GitHub上<br></code></pre></td></tr></table></figure><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>尝试了两个主题，Next 和 Fluid</p><h3 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h3><p>首先试了一下这个经典的主题，个人挺喜欢这个主题样式的。</p><p>但了解之后发现已经不维护了，遗憾放弃。</p><h3 id="Fluid"><a href="#Fluid" class="headerlink" title="Fluid"></a>Fluid</h3><p>一个国人开发的一个主题，挺好看的，即便是默认的样式也不错。</p><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90">配置指南 | Hexo Fluid 用户手册</a></p><h2 id="遇见的坑"><a href="#遇见的坑" class="headerlink" title="遇见的坑"></a>遇见的坑</h2><h3 id="无法连接到-Github"><a href="#无法连接到-Github" class="headerlink" title="无法连接到 Github"></a>无法连接到 Github</h3><p>虽然前段时间才在服务器上配置过 git ssh 登录。但在自己的 Windows 电脑上搞一直出问题，没有办法登录。</p><p>这上面折腾了蛮久的，一开始怀疑自己的网络有问题，没办法连接到 GitHub，后面又怀疑是自己把密码记错或者输错了&#x3D;-&#x3D;。最后才想到可能是我的 git 太旧了。更新一下就解决了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git update-git-for-windows<br></code></pre></td></tr></table></figure><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><h4 id="obsidian-配置："><a href="#obsidian-配置：" class="headerlink" title="obsidian 配置："></a>obsidian 配置：</h4><p><img src="/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E7%AE%80%E8%AE%B0/image-20230305145013823.png"></p><p>安装下面这个插件并如下设置。<br><img src="/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E7%AE%80%E8%AE%B0/image-20230305145038744.png"></p><h4 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h4><p>需要下载一个图像路径替换的插件。</p><p>在配置图片插入的时候发现了这个问题：</p><p><a href="https://github.com/xcodebuild/hexo-asset-image/issues/47">域名是xxx.io的情况下，图片路径会从原本&#x2F;xxx.jpg变成 &#x2F;.io&#x2F;xxx.jpg · Issue #47 · xcodebuild&#x2F;hexo-asset-image · GitHub</a></p><p>找了半天的解决方案，最后发现是安装的插件的问题。把有问题的插件卸载了就可以。</p><p>现在一篇文章的配图是放在同一目录下的同名文件夹里面。配合 obsidian 可以很好的进行添加和删除。</p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p><a href="https://segmentfault.com/a/1190000042111566">Hexo + Obsidian + Git 完美的博客部署与编辑方案 - 个人文章 - SegmentFault 思否</a></p><p><a href="https://zahui.fan/posts/ldle4xfe/">使用Obsidian配合Hexo写博客 | 杂烩饭</a></p><p>可以参考以上两篇文章。<br>现在我是有两个 obsidian 库，一个用来平时记笔记，一个用来写博文。平时记的笔记又臭又长，需要整理了才能发布为博文。</p><h2 id="后续遇到的问题"><a href="#后续遇到的问题" class="headerlink" title="后续遇到的问题"></a>后续遇到的问题</h2><p>提交的时候出现 Error: Spawn failed 错误：<br><a href="https://blog.csdn.net/HTL2018/article/details/106876940">https://blog.csdn.net/HTL2018/article/details/106876940</a></p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个开始</title>
    <link href="/2023/02/15/%E3%80%90%E9%97%B2%E8%81%8A%E3%80%91%E4%B8%80%E4%B8%AA%E5%BC%80%E5%A7%8B/"/>
    <url>/2023/02/15/%E3%80%90%E9%97%B2%E8%81%8A%E3%80%91%E4%B8%80%E4%B8%AA%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一个开始"><a href="#一个开始" class="headerlink" title="一个开始"></a>一个开始</h1><p>2023 年 2 月 15 日，利用 GitHub 和 hexo 搭建了一个简易的博客，虽然平时其实有在用 markdown 记笔记，csdn 上也发布了几篇。本科的时候也想过要自己搭建一个博客，但直到现在才用一个很简单的方式做了一个。</p><p><strong>为什么是这个时候而不是更早或者更迟开始我的博客？</strong></p><p>过去的阻碍：</p><ul><li>域名：Blog 需要一个域名，虽然买一年的域名其实很便宜的，但是续费很贵。周围就有人搭了一年的博客域名到期就不再写了。</li><li>服务器：虽然我现在还是学生，服务器还挺便宜，但是一旦工作了之后服务器就贵起来了，到时候不知道博客该如何处理。</li><li>心理：感觉没有太大的必要把自己写的学习笔记发布到网上。而且平时看到的个人博客还挺少的，没什么感觉。</li></ul><p>现在的动力</p><ul><li>今年寒假的时候不知道怎么开始，好像是因为当时开始用 obsidian 记笔记，于是在整理归纳我过去收藏网页书签，同时又在学习 go 语言，不知道为什么的就浏览了很多的优质博客并收藏了下来。那些博客很多有五六年了，看着作者记录的往昔，给我带来了很多的触动。有点想自己搞个博客。</li><li>我知道 hexo+GitHub 可以快速的搭建一个博客，我看的不少博客也是这样搭建的。其中有个主题我还非常喜欢。这样搭建可以避免域名和服务器的问题。</li><li>看到实验室往届有个师兄的简历上放了个 hexo+github 搭建的博客的链接。感觉对我找实习好像有点帮助。</li><li>在用 obsidian 写笔记日记，开始写博客的心理负担不会很大。</li></ul><p>不过让我在今天搞这个博客的主要触发因素可能还是第三点吧，要不是看到师兄也是用 hexo+github 搞的博客，那以我的性格，肯定是要学习 go 语言到了一定程度之后再准备写一个自己的博客的。那可不知道要到何年何月了。先搞一个这个，如果后面真写了一个好用的博客再迁移也行。</p><p>希望我能养成写博客的好习惯吧，后续把我过去写的一些笔记上传，为了归档的时间线顺眼一点，笔记时间以我实际笔记在本地写的时间，所以会有文章时间比博客创建时间早的情况。</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闲聊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 自启动程序（比如frp）</title>
    <link href="/2021/09/30/Ubuntu%20%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%AF%94%E5%A6%82frp%EF%BC%89/"/>
    <url>/2021/09/30/Ubuntu%20%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%AF%94%E5%A6%82frp%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><p><a href="https://blog.csdn.net/littlle_yan/article/details/78844286">https://blog.csdn.net/littlle_yan/article/details/78844286</a></p><p><a href="https://www.cnblogs.com/ohsolong/p/14184987.html">https://www.cnblogs.com/ohsolong/p/14184987.html</a></p><h2 id="编写可执行脚本"><a href="#编写可执行脚本" class="headerlink" title="编写可执行脚本"></a>编写可执行脚本</h2><p>先为frp写一个可执行脚本</p><p>建立一个文档，随便取个名字</p><p>然后将要执行的命令放入其中，但是保证文档最顶上有个#!&#x2F;bin&#x2F;bash（独占一行）就行。</p><p>比如 我要执行 frpc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>cd /frp/<br>./frpc -c frpc.ini<br></code></pre></td></tr></table></figure><p>保存后</p><p>给权限让这个文档可以执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chmod +x 文档名<br></code></pre></td></tr></table></figure><p>现在，我们可以通过 .&#x2F;文档名 的方式来启动frpc了。</p><h2 id="设置开机自启。"><a href="#设置开机自启。" class="headerlink" title="设置开机自启。"></a>设置开机自启。</h2><p>gnome-session-properties</p><p>在命令行中输入这个，然后在弹出的窗口中点击ADD，然后选择我们之前创建的可执行文件即可。</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装cuda 11  ,cudnn，pytorch 1.7</title>
    <link href="/2020/11/23/%E5%AE%89%E8%A3%85cuda%2011%20%20,cudnn%EF%BC%8Cpytorch%201.7/"/>
    <url>/2020/11/23/%E5%AE%89%E8%A3%85cuda%2011%20%20,cudnn%EF%BC%8Cpytorch%201.7/</url>
    
    <content type="html"><![CDATA[<h2 id="1-安装-cuda"><a href="#1-安装-cuda" class="headerlink" title="1. 安装 cuda"></a>1. 安装 cuda</h2><p>先康康电脑里面有没有</p><p>nvcc -V</p><p>结果当然是没有。</p><p>要安装首选需要康康自己的显卡能支持到多少的 cuda</p><p><img src="https://img-blog.csdnimg.cn/20201123175747734.png#pic_center" alt="在这里插入图片描述"></p><p>打开这个（可以通过搜索直接搜到。）</p><p><img src="https://img-blog.csdnimg.cn/2020112317585665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdWh1Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>点击系统信息</p><p><img src="https://img-blog.csdnimg.cn/20201123175932212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdWh1Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>在组件栏可以发现我的电脑支持 11.0.228 以下的 driver。</p><p>想用新一点的，所以打算就直接安装 cuda11</p><p><a href="https://developer.nvidia.com/cuda-toolkit">https://developer.nvidia.com/cuda-toolkit</a></p><p>去官网下载</p><p>进去发现直接就是11update。</p><p>找了一下才找到以前的版本下载的位置。</p><p><img src="https://img-blog.csdnimg.cn/20201123180323419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdWh1Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201123180348700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdWh1Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>这个就是我想要的版本</p><p>挺大的，还好我的网速还不错。</p><p>下载完毕直接安装就可以了。我下载在C盘里面。</p><h2 id="2-cudnn下载"><a href="#2-cudnn下载" class="headerlink" title="2.cudnn下载"></a>2.cudnn下载</h2><p><a href="https://developer.nvidia.com/rdp/cudnn-download">https://developer.nvidia.com/rdp/cudnn-download</a></p><p>去这里下载</p><p>需要登录</p><p>可以直接微信登录就完事了，比较方便。</p><p><img src="https://img-blog.csdnimg.cn/20201123180559552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdWh1Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>很明确的，就是下载这个</p><p>下载好是个压缩包，解压后有这些东西</p><p><img src="https://img-blog.csdnimg.cn/20201123180726401.png#pic_center" alt="在这里插入图片描述"></p><p>然后进入  C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0  </p><p>将 bin include lib 都复制到这里面</p><h3 id="验证是否安装成功-cuda-cudnn"><a href="#验证是否安装成功-cuda-cudnn" class="headerlink" title="验证是否安装成功 cuda cudnn"></a>验证是否安装成功 cuda cudnn</h3><p>打开cmd</p><p>cd C:\Program Files\NVIDIA GPU Computing  Toolkit\CUDA\v11.0\extras\demo_suite</p><p>运行  bandwidthTest.exe</p><p><img src="https://img-blog.csdnimg.cn/2020112318101117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdWh1Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>运行 deviceQuery.exe</p><p><img src="https://img-blog.csdnimg.cn/20201123181043320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdWh1Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>有PASS就是OK的。</p><h2 id="安装pytorch-1-7"><a href="#安装pytorch-1-7" class="headerlink" title="安装pytorch 1.7"></a>安装pytorch 1.7</h2><p><a href="https://pytorch.org/">https://pytorch.org/</a></p><p>直接去官网</p><p><img src="https://img-blog.csdnimg.cn/20201123181151663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdWh1Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>选好后下载好就行了。</p><p><img src="https://img-blog.csdnimg.cn/20201123182808356.png#pic_center" alt="在这里插入图片描述"></p><p>参考：<br><a href="https://blog.csdn.net/qq_18620653/article/details/105329219">https://blog.csdn.net/qq_18620653/article/details/105329219</a></p><hr><p>时间 2021年5月15日</p><p>网络不好 只能采取wheel的方式下载</p><p><a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a></p><p><a href="https://download.pytorch.org/whl/torch_stable.html">https://download.pytorch.org/whl/torch_stable.html</a></p><p>去上面的第二个网址通过浏览器下载需要的wheel会比用pip下载稳定点，至于要下载哪个就只有参考第一个网址，或者通过pip返回出来的那个名字找就行。<br>下载好之后，通过</p><pre><code class="hljs">pip install torch-1.8.0+cu111-cp38-cp38-win_amd64.whl</code></pre><p>安装就行了</p><p>我这次下载的是1.8版本的</p><p>链接：<a href="https://pan.baidu.com/s/1XBH5Zn5uPteURANU23taKA">https://pan.baidu.com/s/1XBH5Zn5uPteURANU23taKA</a><br>提取码：mn3g </p><p>就顺带上传到网盘里了。</p><p>不过配套的 torchvision&#x3D;&#x3D;0.9.0+cu111 torchaudio&#x3D;&#x3D;0.8.0 就自己通过pip单独下载了。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows平台上的ffmpeg安装</title>
    <link href="/2020/11/15/windows%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84ffmpeg%E5%AE%89%E8%A3%85/"/>
    <url>/2020/11/15/windows%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84ffmpeg%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="windows平台上的ffmpeg安装"><a href="#windows平台上的ffmpeg安装" class="headerlink" title="windows平台上的ffmpeg安装"></a>windows平台上的ffmpeg安装</h1><p>目的是想得到ffmpeg.exe方便直接调用。</p><p><a href="https://ffmpeg.org/download.html#releases">https://ffmpeg.org/download.html#releases</a></p><p>这个是官网，不过官方提供了源代码。一开始来没找到编译后的文件。</p><p>仔细一看，官方还是给了他人编译的链接。</p><p><a href="https://github.com/BtbN/FFmpeg-Builds/releases">https://github.com/BtbN/FFmpeg-Builds/releases</a></p><p><a href="https://www.gyan.dev/ffmpeg/builds/">https://www.gyan.dev/ffmpeg/builds/</a></p><p>windows平台的就两个。不过更新的都挺快的感觉。</p><p><img src="https://img-blog.csdnimg.cn/20201115001610449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdWh1Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>我下载的这个，其他版本倒也不是太懂其中的区别。</p><p>解压得到下面这些东西</p><p><img src="https://img-blog.csdnimg.cn/20201115001717159.png#pic_center" alt="在这里插入图片描述"></p><p>我想要的ffmpeg.exe就在bin文件夹里面</p><p><img src="https://img-blog.csdnimg.cn/2020111500185792.png#pic_center" alt="在这里插入图片描述"></p><p>这里吐槽一下。本来想直接用一些软件里面自带的ffmpeg.exe的，但估计是定制化的修改过的。转化的时候会降低画质。</p><p>还有就是通过 python pip 安装的ffmpeg是没有exe文件的。</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习Q&amp;A</title>
    <link href="/2020/07/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0Q&amp;A/"/>
    <url>/2020/07/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0Q&amp;A/</url>
    
    <content type="html"><![CDATA[<p>后面有机会会考虑整理一下。</p><h1 id="深度学习Q-A"><a href="#深度学习Q-A" class="headerlink" title="深度学习Q&amp;A"></a>深度学习Q&amp;A</h1><p>以 Q&amp;A 形式收集的一些深度学习的知识。</p><h1 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h1><h3 id="Q-常规判断"><a href="#Q-常规判断" class="headerlink" title="Q: 常规判断"></a>Q: 常规判断</h3><p><strong>A:</strong><br>train loss 不断下降, dev (或 test) loss 不断下降: 说明网络仍在学习;</p><p>train loss 不断下降，dev (或 test) loss 趋于不变: 说明网络过拟合;</p><p>train loss 趋于不变，dev (或 test) loss 不断下降: 说明数据集 100%有问题;</p><p>train loss 趋于不变，dev (或 test) loss 趋于不变: 说明学习遇到瓶颈，需要减小学习率或批量数目; 或者是数据集有问题 (数据集标注错误数据比较多)</p><p>train loss 不断上升，dev (或 test) loss 不断上升: 说明网络结构设计不当，训练超参数设置不当，数据集未经过清洗等问题。</p><h3 id="Q-iteration-和-epoch-有什么区别？"><a href="#Q-iteration-和-epoch-有什么区别？" class="headerlink" title="Q: iteration 和 epoch 有什么区别？"></a>Q: iteration 和 epoch 有什么区别？</h3><p><strong>A:</strong></p><p>一次传播 &#x3D; 一次前向传播 + 一次后向传播。（所有的训练样本完成一次 Forword 运算以及一次 BP 运算）</p><p>但是考虑到内存不够用的问题，训练样本们往往并不是全都一起拿到内存中去训练，而是一次拿一个 batch 去训练，一个 batch 包含的样本数称为 batch size。</p><p>iteration——使用 batch size 个样本传播一次。同样，一次传播 &#x3D; 一次前向传播 + 一次后向传播。</p><p>eg. 我们有 1000 个训练样本，batch size 为 100，那么完成一次 epoch 就需要 10 个 iteration。</p><h3 id="Q-什么是强化学习？"><a href="#Q-什么是强化学习？" class="headerlink" title="Q: 什么是强化学习？"></a>Q: 什么是强化学习？</h3><p><strong>A:</strong></p><h3 id="Q-什么是半监督学习？"><a href="#Q-什么是半监督学习？" class="headerlink" title="Q: 什么是半监督学习？"></a>Q: 什么是半监督学习？</h3><p><strong>A:</strong></p><h3 id="Q：什么是偏差，什么是方差？"><a href="#Q：什么是偏差，什么是方差？" class="headerlink" title="Q：什么是偏差，什么是方差？"></a>Q：什么是偏差，什么是方差？</h3><p><strong>A:</strong><br><strong>偏差（bias）</strong>：偏差衡量了模型的预测值与实际值之间的偏离关系。通常在深度学习中，我们每一次训练迭代出来的新模型，都会拿训练数据进行预测，偏差就反应在预测值与实际值匹配度上，比如通常在 keras 运行中看到的准确度为 96%，则说明是低偏差；反之，如果准确度只有 70%，则说明是高偏差。</p><p><strong>方差（variance）</strong>：方差描述的是训练数据在不同迭代阶段的训练模型中，预测值的变化波动情况（或称之为离散情况）。从数学角度看，可以理解为每个预测值与预测均值差的平方和的再求平均数。通常在深度学习训练中，初始阶段模型复杂度不高，为低方差；随着训练量加大，模型逐步拟合训练数据，复杂度开始变高，此时方差会逐渐变高。<br>![[image-20230215210503598.png]]<br><strong>低偏差，低方差</strong>：这是训练的理想模型，此时蓝色点集基本落在靶心范围内，且数据离散程度小，基本在靶心范围内；</p><p><strong>低偏差，高方差</strong>：这是深度学习面临的最大问题，过拟合了。也就是模型太贴合训练数据了，导致其泛化（或通用）能力差，若遇到测试集，则准确度下降的厉害；</p><p><strong>高偏差，低方差</strong>：这往往是训练的初始阶段；</p><p><strong>高偏差，高方差</strong>：这是训练最糟糕的情况，准确度差，数据的离散程度也差。<br><a href="https://www.cnblogs.com/hutao722/p/9921788.html">https://www.cnblogs.com/hutao722/p/9921788.html</a></p><h3 id="Q：什么是卷积？什么是池化？"><a href="#Q：什么是卷积？什么是池化？" class="headerlink" title="Q：什么是卷积？什么是池化？"></a>Q：什么是卷积？什么是池化？</h3><p><strong>A:</strong></p><h3 id="Q：什么是多标签分类？"><a href="#Q：什么是多标签分类？" class="headerlink" title="Q：什么是多标签分类？"></a>Q：什么是多标签分类？</h3><p><strong>A:</strong> 在一些复杂场景下，一个 object 可能属于多个类，比如你的类别中有 woman 和 person 这两个类，那么如果一张图像中有一个 woman，那么你检测的结果中类别标签就要同时有 woman 和 person 两个类，这就是多标签分类</p><h3 id="Q：什么是回归模型，什么是分类模型？"><a href="#Q：什么是回归模型，什么是分类模型？" class="headerlink" title="Q：什么是回归模型，什么是分类模型？"></a>Q：什么是回归模型，什么是分类模型？</h3><p><strong>A:</strong><br><strong>分类</strong><br>分类是指有有限个可能的问题，预测的是一个离散的、明确的变量。比如给出一张图片，去判断是 T 恤是裤子或者其他的种类；这个类别是有限的。目标检测算法中，RCNN 系列就是用了分类问题的思想，先是找出一定量的 region proposal（候选区域），然后再对这些个候选区域进行分类任务。</p><p><strong>回归</strong><br>相反，回归是指有无限个可能的问题，预测的是一个连续的、逼近的变量。比如房价的预测、明日气温的预测。同样，目标检测算法中，yolo 系列则是用来回归的思想，没有提取候选区域这一步，直接划分为一些 cell，然后产出 bbox，回归出这些 bbox 的位置和置信度。</p><h3 id="Q：什么是先验，后验，似然？"><a href="#Q：什么是先验，后验，似然？" class="headerlink" title="Q：什么是先验，后验，似然？"></a>Q：什么是先验，后验，似然？</h3><p><strong>A:</strong><br>先验分布：根据一般的经验认为随机变量应该满足的分布<br>后验分布：通过当前训练数据修正的随机变量的分布，比先验分布更符合当前数据<br>似然估计：已知训练数据，给定了模型，通过让似然性极大化估计模型参数的一种方法<br>后验分布往往是基于先验分布和极大似然估计计算出来的。</p><p>隔壁老王要去 10 公里外的一个地方办事，他可以选择走路，骑自行车或者开车，并花费了一定时间到达目的地。在这个事件中，可以把交通方式（走路、骑车或开车）认为是原因，花费的时间认为是结果。若老王花了一个小时的时间完成了 10 公里的距离，那么很大可能是骑车过去的，当然也有较小可能老王是个健身达人跑步过去的，或者开车过去但是堵车很严重。若老王一共用了两个小时的时间完成了 10 公里的距离，那么很有可能他是走路过去的。若老王只用了二十分钟，那么很有可能是开车。这种先知道结果，然后由结果估计原因的概率分布，p (交通方式|时间)，就是后验概率。</p><p>老王早上起床的时候觉得精神不错，想锻炼下身体，决定跑步过去；也可能老王想做个文艺青年试试最近流行的共享单车，决定骑车过去；也可能老王想炫个富，决定开车过去。老王的选择与到达目的地的时间无关。先于结果，确定原因的概率分布，p (交通方式)，就是先验概率。</p><p>老王决定步行过去，那么很大可能 10 公里的距离大约需要两个小时；较小可能是老王平时坚持锻炼，跑步过去用了一个小时；更小可能是老王是个猛人，40 分钟就到了。老王决定骑车过去，很可能一个小时就能到；较小可能是老王那天精神不错加上单双号限行交通很通畅，40 分钟就到了；还有一种较小可能是老王运气很差，连着坏了好几辆共享单车，花了一个半小时才到。老王决定开车过去，很大可能是 20 分钟就到了，较小可能是那天堵车很严重，磨磨唧唧花了一个小时才到。这种先确定原因，根据原因来估计结果的概率分布，p (时间|交通方式)，就是似然估计。</p><p>老王去那个地方好几趟，不管是什么交通方式，得到了一组关于时间的概率分布。这种不考虑原因，只看结果的概率分布，p (时间)，也有一个名词：evidence（不清楚合适的中文名是什么）</p><h3 id="Q：-论文中常见的-Top-1-准确率和-Top-5-准确率（Top-1-Error-Top-5-Error）是什么意思？"><a href="#Q：-论文中常见的-Top-1-准确率和-Top-5-准确率（Top-1-Error-Top-5-Error）是什么意思？" class="headerlink" title="Q： 论文中常见的 Top-1 准确率和 Top-5 准确率（Top-1 Error&amp;Top-5 Error）是什么意思？"></a>Q： 论文中常见的 Top-1 准确率和 Top-5 准确率（Top-1 Error&amp;Top-5 Error）是什么意思？</h3><p><strong>A:</strong><br>ImageNet 有大概 1000 个分类，而模型预测某张图片时，会给出 1000 个按概率从高到低的类别排名。</p><p>所谓的 Top-1 Accuracy 是指排名第一的类别与实际结果相符的准确率<br>而 Top-5 Accuracy 是指排名前五的类别包含实际结果的准确率。</p><p>Top-1 Error：假设模型预测某个对象的类别，模型输出 1 个预测结果，那么这一个结果能判断正确的概率就是 Top-1 正确率。判断错误的概率就是 Top-1 错误率。简言之就是模型判错的概率。<br>Top-5 Error ：假设模型预测某个对象的类别，模型输出 5 个预测结果，只要其中一个能判断正确类别，这个概率就是 Top-5 正确率，反之，预测输出的五个结果都错误的概率就是 Top-5 错误率。<br>一般来说，Top-1 Error 和 Top-5 Error 越低，模型的性能也就越好。且 Top-5 Error 往往小于 Top-1 Error。</p><h3 id="Q：怎么设置学习速率的优化策略？学习速率的优化策略有哪些？"><a href="#Q：怎么设置学习速率的优化策略？学习速率的优化策略有哪些？" class="headerlink" title="Q：怎么设置学习速率的优化策略？学习速率的优化策略有哪些？"></a>Q：怎么设置学习速率的优化策略？学习速率的优化策略有哪些？</h3><p><strong>A:</strong><br><a href="https://lumingdong.cn/setting-strategy-of-gradient-descent-learning-rate.html">https://lumingdong.cn/setting-strategy-of-gradient-descent-learning-rate.html</a></p><h3 id="Q：-什么是-one-stage-什么的是-two-stage-两者的区别是什么？"><a href="#Q：-什么是-one-stage-什么的是-two-stage-两者的区别是什么？" class="headerlink" title="Q： 什么是 one-stage 什么的是 two-stage 两者的区别是什么？"></a>Q： 什么是 one-stage 什么的是 two-stage 两者的区别是什么？</h3><p><strong>A:</strong><br>one-stage 一次性进行定位+类型预测<br>two-stage 先定位再预测？</p><h3 id="Q-什么是-LSTM-Net"><a href="#Q-什么是-LSTM-Net" class="headerlink" title="Q: 什么是 LSTM Net?"></a>Q: 什么是 LSTM Net?</h3><p><strong>A:</strong>:</p><p>参考：<br><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p><h3 id="Q-什么是-Contrastive-Learning-对比学习"><a href="#Q-什么是-Contrastive-Learning-对比学习" class="headerlink" title="Q: 什么是 Contrastive Learning (对比学习)?"></a>Q: 什么是 Contrastive Learning (对比学习)?</h3><p><strong>A:</strong>:</p><p>参考：</p><h3 id="Q-什么是-Optimization-in-Multi-task-learning-多任务学习优化"><a href="#Q-什么是-Optimization-in-Multi-task-learning-多任务学习优化" class="headerlink" title="Q: 什么是 Optimization in Multi-task learning (多任务学习优化)?"></a>Q: 什么是 Optimization in Multi-task learning (多任务学习优化)?</h3><p><strong>A:</strong>:</p><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/269492239">https://zhuanlan.zhihu.com/p/269492239</a></p><p><a href="https://mp.weixin.qq.com/s/EDDSWyo8goRKG_bXohKUcA">https://mp.weixin.qq.com/s/EDDSWyo8goRKG_bXohKUcA</a></p><p><a href="https://mp.weixin.qq.com/s/JaMSZfJZ6zPEOueuVg6XHw">https://mp.weixin.qq.com/s/JaMSZfJZ6zPEOueuVg6XHw</a> loss 设计</p><h3 id="Q-什么是-pretext-task-前置任务"><a href="#Q-什么是-pretext-task-前置任务" class="headerlink" title="Q: 什么是 pretext task (前置任务)?"></a>Q: 什么是 pretext task (前置任务)?</h3><p><strong>A:</strong>:<br>Pretext task 也叫 surrogate task，我更倾向于把它翻译为：代理任务。</p><p>参考：<br><a href="https://www.zhihu.com/question/358468168">https://www.zhihu.com/question/358468168</a><br><a href="https://atcold.github.io/pytorch-Deep-Learning/zh/week01/01-1/">https://atcold.github.io/pytorch-Deep-Learning/zh/week01/01-1/</a>  (非常好的一个课程)<br><a href="https://stats.stackexchange.com/questions/404602/pretext-task-in-computer-vision">https://stats.stackexchange.com/questions/404602/pretext-task-in-computer-vision</a></p><h3 id="Q-什么是-Downstream-Task-下游任务"><a href="#Q-什么是-Downstream-Task-下游任务" class="headerlink" title="Q: 什么是 Downstream Task (下游任务)?"></a>Q: 什么是 Downstream Task (下游任务)?</h3><p><strong>A:</strong>：</p><p>参考：</p><h3 id="Q-什么是-Few-Shot-Learning-小样本学习"><a href="#Q-什么是-Few-Shot-Learning-小样本学习" class="headerlink" title="Q: 什么是 Few-Shot Learning (小样本学习)?"></a>Q: 什么是 Few-Shot Learning (小样本学习)?</h3><p><strong>A:</strong>:</p><p>参考：</p><h3 id="Q-什么是-Meta-learning-元学习"><a href="#Q-什么是-Meta-learning-元学习" class="headerlink" title="Q: 什么是 Meta learning (元学习)?"></a>Q: 什么是 Meta learning (元学习)?</h3><p><strong>A:</strong>:</p><p>参考：</p><p><a href="https://www.youtube.com/watch?v=EkAqYbpCYAc">https://www.youtube.com/watch?v=EkAqYbpCYAc</a></p><h3 id="Q-什么是-life-long-Learning-终生学习"><a href="#Q-什么是-life-long-Learning-终生学习" class="headerlink" title="Q: 什么是 life long Learning (终生学习)"></a>Q: 什么是 life long Learning (终生学习)</h3><p><strong>A:</strong>:</p><p>参考： <a href="https://zhuanlan.zhihu.com/p/119324185">https://zhuanlan.zhihu.com/p/119324185</a></p><h3 id="Q-什么是-Curriculum-Learning-课程学习"><a href="#Q-什么是-Curriculum-Learning-课程学习" class="headerlink" title="Q: 什么是 Curriculum Learning (课程学习)?"></a>Q: 什么是 Curriculum Learning (课程学习)?</h3><p><strong>A:</strong>:</p><p>参考： <a href="https://zhuanlan.zhihu.com/p/362351969">https://zhuanlan.zhihu.com/p/362351969</a></p><h3 id="Q-什么是-Zero-Shot-Learning-零样本学习"><a href="#Q-什么是-Zero-Shot-Learning-零样本学习" class="headerlink" title="Q: 什么是 Zero-Shot Learning (零样本学习)?"></a>Q: 什么是 Zero-Shot Learning (零样本学习)?</h3><p><strong>A:</strong>:</p><p>参考：</p><h3 id="Q-什么是-蒸馏学习"><a href="#Q-什么是-蒸馏学习" class="headerlink" title="Q: 什么是 蒸馏学习?"></a>Q: 什么是 蒸馏学习?</h3><p><strong>A:</strong></p><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/102038521">https://zhuanlan.zhihu.com/p/102038521</a></p><h2 id="Q：什么是异常检测（Anomaly-Detection）"><a href="#Q：什么是异常检测（Anomaly-Detection）" class="headerlink" title="Q：什么是异常检测（Anomaly Detection）"></a>Q：什么是异常检测（Anomaly Detection）</h2><p><strong>A:</strong></p><p><a href="https://mp.weixin.qq.com/s/bLcb9QvdY4pOu6CEME0aeQ">https://mp.weixin.qq.com/s/bLcb9QvdY4pOu6CEME0aeQ</a></p><h2 id="Q：什么是目标跟踪？"><a href="#Q：什么是目标跟踪？" class="headerlink" title="Q：什么是目标跟踪？"></a>Q：什么是目标跟踪？</h2><p><strong>A:</strong></p><p><a href="https://mp.weixin.qq.com/s/GdEmAZokncFDrcIsj9luug">https://mp.weixin.qq.com/s/GdEmAZokncFDrcIsj9luug</a></p><h2 id="Q：什么是图像匹配？"><a href="#Q：什么是图像匹配？" class="headerlink" title="Q：什么是图像匹配？"></a>Q：什么是图像匹配？</h2><p><strong>A:</strong></p><p><a href="https://mp.weixin.qq.com/s/Q6bdbRBHnIPh_zdL5nkOyw">https://mp.weixin.qq.com/s/Q6bdbRBHnIPh_zdL5nkOyw</a></p><p><a href="https://mp.weixin.qq.com/s/3fJ8Z0WIGOoUymEsTw30LQ">https://mp.weixin.qq.com/s/3fJ8Z0WIGOoUymEsTw30LQ</a></p><h2 id="Q：什么是多模态深度学习？"><a href="#Q：什么是多模态深度学习？" class="headerlink" title="Q：什么是多模态深度学习？"></a>Q：什么是多模态深度学习？</h2><p><strong>A:</strong></p><p><a href="https://mp.weixin.qq.com/s/0CUGispeZS04D6NhGkrucw">https://mp.weixin.qq.com/s/0CUGispeZS04D6NhGkrucw</a></p><h2 id="Q：什么是-SPPnet？他能解决什么问题？"><a href="#Q：什么是-SPPnet？他能解决什么问题？" class="headerlink" title="Q：什么是 SPPnet？他能解决什么问题？"></a>Q：什么是 SPPnet？他能解决什么问题？</h2><p><strong>A:</strong><br>参考： <a href="https://blog.csdn.net/yzf0011/article/details/75212513">https://blog.csdn.net/yzf0011/article/details/75212513</a>  spp 深度解析<br>优点：</p><ul><li>可以提取不同尺寸的空间特征信息，可以提升模型对于空间布局和物体变性的鲁棒性。</li><li>可以避免将图片 resize、crop 成固定大小输入模型的弊端。<br>SPP 和 Fast R-CNN 的 ROI Pooling 是一脉相承的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-comment"># https://github.com/yueruchen/sppnet-pytorch/blob/master/spp_layer.py</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spatial_pyramid_pool</span>(<span class="hljs-params">self, previous_conv, num_sample, previous_conv_size, out_pool_size</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    previous_conv: a tensor vector of previous convolution layer</span><br><span class="hljs-string">    num_sample: an int number of image in the batch</span><br><span class="hljs-string">    previous_conv_size: an int vector [height, width] of the matrix features size of previous convolution layer</span><br><span class="hljs-string">    out_pool_size: a int vector of expected output size of max pooling layer</span><br><span class="hljs-string">    returns: a tensor vector with shape [1 x n] is the concentration of multi-level pooling</span><br><span class="hljs-string">    previous_conv:前卷积层的张量向量</span><br><span class="hljs-string">    num_sample：批处理中图像的整数</span><br><span class="hljs-string">    previous_conv_size：矩阵的int向量[高度，宽度]表示上一个卷积层的大小</span><br><span class="hljs-string">    out_pool_size</span><br><span class="hljs-string">    returns：形状为[1 x n]的张量向量是多级池的集中</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># print(previous_conv.size())</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(out_pool_size)):<br>        <span class="hljs-comment"># print(previous_conv_size)</span><br>        h_wid = <span class="hljs-built_in">int</span>(math.ceil(previous_conv_size[<span class="hljs-number">0</span>] / out_pool_size[i]))<br>        w_wid = <span class="hljs-built_in">int</span>(math.ceil(previous_conv_size[<span class="hljs-number">1</span>] / out_pool_size[i]))<br>        h_pad = (h_wid * out_pool_size[i] - previous_conv_size[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br>        w_pad = (w_wid * out_pool_size[i] - previous_conv_size[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br>        maxpool = nn.MaxPool2d((h_wid, w_wid), stride=(h_wid, w_wid), padding=(h_pad, w_pad))<br>        x = maxpool(previous_conv)<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>):<br>            spp = x.view(num_sample, -<span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># print(&quot;spp size:&quot;,spp.size())</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># print(&quot;size:&quot;,spp.size())</span><br>            spp = torch.cat((spp, x.view(num_sample, -<span class="hljs-number">1</span>)), <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> spp<br></code></pre></td></tr></table></figure><h3 id="Q：什么是消融实验（Ablation-experiment）？"><a href="#Q：什么是消融实验（Ablation-experiment）？" class="headerlink" title="Q：什么是消融实验（Ablation experiment）？"></a>Q：什么是消融实验（Ablation experiment）？</h3><p><strong>A:</strong><br>采用“消融研究”来描述去除网络的某些部分的过程，以便更好地理解网络的行为。</p><p>作者提出了一种方案，同时改变了多个条件&#x2F;参数，他在接下去的消融实验中，会一一控制一个条件&#x2F;参数不变，来看看结果，到底是哪个条件&#x2F;参数对结果的影响更大。</p><p>对于一个问题 Q，原先有个方法 A。然后你提出一个创新点，得到 A+的方法 B。为了比较创新点的作用，你要控制 B 中关于 A 的实验的参数，并改变创新点。进行 A 和 B 对比实验。看创新点是否有效。</p><p>有点控制变量的意思。</p><h2 id="Q：什么是-end-to-end"><a href="#Q：什么是-end-to-end" class="headerlink" title="Q：什么是 end to end?"></a>Q：什么是 end to end?</h2><p><strong>A:</strong><br><a href="https://www.zhihu.com/question/51435499">https://www.zhihu.com/question/51435499</a><br>大概意思就是：<br>输入原始数据，直接得到最后的结果，且网络从头到尾是可导的。中间无需人工干预。</p><p>end-to-end 训练只用一个阶段，如：Fast R-CNN，Faster R-CNN<br>而 R-CNN、SPP 训练需要分为多个阶段：微调网络+训练 SVM+训练边框回归器</p><p>以下是知乎的一个解释，答主要就语音识别领域来讲的，图像领域有所不同，“图像识别和语音识别任务不一样”<br><strong>端到端训练</strong>（end-to-end training）：一般指的是在训练好语言模型后，将声学模型和语言模型接在一起，以 WER 或它的一种近似为目标函数去训练声学模型。由于训练声学模型时要计算系统整体的输出，所以称为「端到端」训练。可以看出这种方法并没有彻底解决问题，因为语言模型还是独立训练的。</p><p><strong>端到端模型</strong>（end-to-end models）：系统中不再有独立的声学模型、发音词典、语言模型等模块，而是从输入端（语音波形或特征序列）到输出端（单词或字符序列）直接用一个神经网络相连，让这个神经网络来承担原先所有模块的功能。典型的代表如使用 CTC 的 EESEN [1]、使用注意力机制的 Listen, Attend and Spell [2]。这种模型非常简洁，但灵活性就差一些：一般来说用于训练语言模型的文本数据比较容易大量获取，但不与语音配对的文本数据无法用于训练端到端的模型。因此，端到端模型也常常再外接一个语言模型，用于在解码时调整候选输出的排名（rescoring），如 [1]</p><p>链接： <a href="https://www.zhihu.com/question/51435499/answer/129429628">https://www.zhihu.com/question/51435499/answer/129429628</a></p><h2 id="Q：-什么是多尺度训练，什么是-FPN？两者是什么关系？什么的-FRN？"><a href="#Q：-什么是多尺度训练，什么是-FPN？两者是什么关系？什么的-FRN？" class="headerlink" title="Q： 什么是多尺度训练，什么是 FPN？两者是什么关系？什么的 FRN？"></a>Q： 什么是多尺度训练，什么是 FPN？两者是什么关系？什么的 FRN？</h2><p><strong>A:</strong><br>参考： <a href="https://cloud.tencent.com/developer/article/1546594">https://cloud.tencent.com/developer/article/1546594</a><br><a href="https://www.jianshu.com/p/57cfa4fdd423">https://www.jianshu.com/p/57cfa4fdd423</a><br>多尺度训练是一种数据处理方式（？）同一张图片以不同的尺寸输入模型进行训练（或者不同的图片以不同的尺寸输入模型？）<br>FPN（特征金字塔）是一种网络结构。对于小目标来说，当进行卷积池化到最后一层，实际上语义信息已经没有了，所以为了解决多尺度检测的问题，引入了特征金字塔网络。</p><h2 id="Q-什么是-VAE-Variational-Auto-Encoder"><a href="#Q-什么是-VAE-Variational-Auto-Encoder" class="headerlink" title="Q: 什么是 VAE (Variational Auto Encoder)?"></a>Q: 什么是 VAE (Variational Auto Encoder)?</h2><p><strong>A:</strong></p><h2 id="Q-什么是能量图"><a href="#Q-什么是能量图" class="headerlink" title="Q: 什么是能量图?"></a>Q: 什么是能量图?</h2><p><strong>A:</strong></p><h2 id="什么是-Seam-Carving-算法，如何实现？"><a href="#什么是-Seam-Carving-算法，如何实现？" class="headerlink" title="什么是 Seam Carving 算法，如何实现？"></a>什么是 Seam Carving 算法，如何实现？</h2><p><a href="https://zhuanlan.zhihu.com/p/38974520">https://zhuanlan.zhihu.com/p/38974520</a><br><a href="https://zhuanlan.zhihu.com/p/65339171">https://zhuanlan.zhihu.com/p/65339171</a><br><a href="https://github.com/avidLearnerInProgress/pyCAIR">https://github.com/avidLearnerInProgress/pyCAIR</a><br><a href="https://zhuanlan.zhihu.com/p/85136353">https://zhuanlan.zhihu.com/p/85136353</a><br><a href="http://cs.brown.edu/courses/cs129/results/proj3/taox/">http://cs.brown.edu/courses/cs129/results/proj3/taox/</a></p><h2 id="Q：-1×1-卷积核的作用"><a href="#Q：-1×1-卷积核的作用" class="headerlink" title="Q： 1×1 卷积核的作用"></a>Q： 1×1 卷积核的作用</h2><p><strong>A:</strong><br><a href="https://zhuanlan.zhihu.com/p/40050371">https://zhuanlan.zhihu.com/p/40050371</a></p><p>卷积核的作用在于特征的抽取，越是大的卷积核尺寸就意味着更大的感受野</p><p><strong>降维（减少参数）&#x2F;升维</strong></p><p>当 1*1 卷积出现时，在大多数情况下它作用是升&#x2F;降特征的维度，这里的维<br>度指的是通道数（厚度），而不改变图片的宽和高。</p><p>1×1 卷积核可以起到一个跨通道聚合的作用，所以进一步可以起到降维（或者升维）的作用，起到减少参数的目的。<br>比如当前层为 x×x×m 即图像大小为 x×x，特征层数为 m，然后如果将其通过 1×1 的卷积核，特征层数为 n，那么只要 n&lt;m 这样就能起到降维的目的，减少之后步骤的运算量（当然这里不太严谨，需要考虑 1×1 卷积核本身的参数个数为 m×nm×n 个）。</p><p>如果卷积的输出输入都只是一 个平面，那么 1x1 卷积核并没有什么意义，它是完全不考虑像素与周边其他像素关系。 但卷积的输出输入是长方体，所以 1x1 卷积实际上是对每个像素点，在不同的 channels_上进行线性组合 (信息整合) ，且保留了图片的原有平面结构, 调控 depth, 从而完成升维或降维的功能。</p><p><strong>加入非线性</strong></p><p>卷积层之后经过激励层，1*1 的卷积在前一层的学习表示上添加了非线性激励（ non-linear activation ），提升网络的表达能力；</p><p><strong>跨通道信息交互（channal 的变换）</strong></p><p>例子：使用 1×1 卷积核，实现降维和升维的操作其实就是 channel 间信息的线性组合变化，3×3，64channels 的卷积核后面添加一个 1×1，28channels 的卷积核，就变成了 3×3，28channels 的卷积核，原来的 64 个 channels 就可以理解为跨通道线性组合变成了 28channels，这就是通道间的信息交互。</p><p>注意：只是在 channel 维度上做线性组合，W 和 H 上是共享权值的 sliding window</p><h2 id="Q：-常用-Normalization-的区别：BN-LN-IN-GN"><a href="#Q：-常用-Normalization-的区别：BN-LN-IN-GN" class="headerlink" title="Q： 常用 Normalization 的区别：BN, LN, IN, GN"></a>Q： 常用 Normalization 的区别：BN, LN, IN, GN</h2><p><strong>A:</strong><br>![[image-20230215210441926.png]]<br>Batch Normalization (BN)、Layer Normalization (LN)、Instance Normalization (IN)、Group Normalization (GN)<br>这几个方法主要的区别就是在：</p><ol><li><p>BN 是在 batch 上，对 N、H、W 做归一化，而保留通道 C 的维度。BN 对较小的 batch size 效果不好。BN 适用于固定深度的前向神经网络，如 CNN，不适用于 RNN；</p></li><li><p>LN 在通道方向上，对 C、H、W 归一化，主要对 RNN 效果明显；</p></li><li><p>IN 在图像像素上，对 H、W 做归一化，用在风格化迁移</p></li><li><p>GN 将 channel 分组，然后再做归一化。</p></li></ol><p>将 feature map shape 记为[N, C, H, W]。如果把特征图比喻成一摞书，这摞书总共有 N 本，每本有 C 页，每页有 H 行，每行有 W 个字符。</p><ol><li>BN 是在 batch 上，对 N、H、W 做归一化，而保留通道 C 的维度。BN 相当于把这些书按页码一一对应地加起来，再除以每个页码下的字符总数：N×H×W。</li><li>LN 在通道方向上，对 C、H、W 归一化。LN 相当于把每一本书的所有字加起来，再除以这本书的字符总数：C×H×W。</li><li>IN 在图像像素上，对 H、W 做归一化。IN 相当于把一页书中所有字加起来，再除以该页的总字数：H×W。</li><li>GN 将 channel 分组，然后再做归一化。GN 相当于把一本 C 页的书平均分成 G 份，每份成为有 C&#x2F;G 页的小册子，对每个小册子做 Norm。</li></ol><p>其中 GN，pytorch 已经有实现<br><a href="https://pytorch.org/docs/stable/nn.html#torch.nn.GroupNorm">https://pytorch.org/docs/stable/nn.html#torch.nn.GroupNorm</a></p><pre><code class="hljs">参考：  1、 https://blog.csdn.net/ft_sunshine/article/details/99203548?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task  2、https://mp.weixin.qq.com/s/HK4Ajk363GOoO1P5Js8Deg</code></pre><h2 id="Q-什么是-surrogate-losses-代理函数-？"><a href="#Q-什么是-surrogate-losses-代理函数-？" class="headerlink" title="Q: 什么是 surrogate losses (代理函数)？"></a>Q: 什么是 surrogate losses (代理函数)？</h2><p><strong>A:</strong> 中文可以译为代理损失函数。当原本的 loss function 不便计算的时候，我们就会考虑使用 surrogate loss function。</p><p><strong>参考</strong>：<br><a href="http://sofasofa.io/forum_main_post.php?postid=1000605">http://sofasofa.io/forum_main_post.php?postid=1000605</a></p><h2 id="Q：-探究各种新出的优化器的优缺点"><a href="#Q：-探究各种新出的优化器的优缺点" class="headerlink" title="Q： 探究各种新出的优化器的优缺点"></a>Q： 探究各种新出的优化器的优缺点</h2><p><strong>A:</strong><br><a href="https://github.com/jettify/pytorch-optimizer">https://github.com/jettify/pytorch-optimizer</a></p><h2 id="Q：我们需要模型压缩吗？"><a href="#Q：我们需要模型压缩吗？" class="headerlink" title="Q：我们需要模型压缩吗？"></a>Q：我们需要模型压缩吗？</h2><p><strong>A:</strong></p><p><a href="https://mp.weixin.qq.com/s/HqiTdsZv_9aERq0tjBuO1A">https://mp.weixin.qq.com/s/HqiTdsZv_9aERq0tjBuO1A</a></p><h2 id="Q：什么是-mae-什么是-mRMSE，什么是-MSE"><a href="#Q：什么是-mae-什么是-mRMSE，什么是-MSE" class="headerlink" title="Q：什么是 mae, 什么是 mRMSE，什么是 MSE"></a>Q：什么是 mae, 什么是 mRMSE，什么是 MSE</h2><p><strong>A:</strong><br><strong>平均绝对误差 (MAE)</strong> 和 <strong>均方差误差 (RMSE)</strong> 是用来衡量连续变量精度的两个最常用的指标。</p><ul><li>平均绝对误差 (MAE)<br><a href="https://medium.com/human-in-a-machine-world/mae-and-rmse-which-metric-is-better-e60ac3bde13d">https://medium.com/human-in-a-machine-world/mae-and-rmse-which-metric-is-better-e60ac3bde13d</a><br>平均绝对误差 (MAE) : MAE 测量在一组预测中的平均误差大小，没有考虑它们的方向。 它是预测与实际观测之间的绝对差异在测试样本上的平均值，其中所有的个体差异具有相同的权重。</li></ul><p>根均方差 (RMSE) : 也可以度量误差的平均值。 它是预测值与实际观测值平方差的平方根。</p><h2 id="Q：什么是标签平滑，什么时候使用标签平滑？"><a href="#Q：什么是标签平滑，什么时候使用标签平滑？" class="headerlink" title="Q：什么是标签平滑，什么时候使用标签平滑？"></a>Q：什么是标签平滑，什么时候使用标签平滑？</h2><p><strong>A:</strong><br><a href="https://www.jiqizhixin.com/articles/2019-07-09-7">https://www.jiqizhixin.com/articles/2019-07-09-7</a></p><p><a href="https://blog.csdn.net/weixin_37947156/article/details/95936642?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">https://blog.csdn.net/weixin_37947156/article/details/95936642?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase</a></p><h2 id="Q：-什么是-P-R-mAP-F1"><a href="#Q：-什么是-P-R-mAP-F1" class="headerlink" title="Q： 什么是 P, R, mAP, F1?"></a>Q： 什么是 P, R, mAP, F1?</h2><p><strong>A:</strong><br>Precision – 查准率、精确率</p><p>Recall – 查全率、召回率</p><p>![[image-20230215210422593.png]]</p><p>注意：准确率和召回率是互相影响的，理想情况下肯定是做到两者都高，但是一般情况下准确率高、召回率就低，召回率低、准确率高，当然如果两者都低，那是什么地方出问题了 。</p><p>如果是做搜索，那就是保证召回的情况下提升准确率；如果做疾病监测、反垃圾，则是保准确率的条件下，提升召回</p><p>所以，在两者都要求高的情况下，可以用 F1 来衡量。</p><p>$$F1&#x3D;2 \times P\times R&#x2F;(P+R)$$<br>PR 曲线下的面积, 叫做 AP (average precision), N 个分类类别得到 N 条 PR 曲线得到 N 个 AP, 求平均得到 mAP (mean average precision).</p><p>具体计算过程: (目标检测为例)</p><p>先把所有 bbox 找出来 并加上 confidence<br>然后每一类根据 confidence 从大到小排列<br>每一类中每个 confidence 计算与 label 对应的 IOU, 根据设定的 IOU 阈值判断是否预测正确<br>每一类中每个 confidence 根据预测正误算出其 recall 和 precision 得到每一类的 PR 曲线, 曲线下的面积为对应该类的 average precision<br>所有类取 mean, 得到对应 IOU 阈值下的 mean average precision, 如 mAP50, mAP75 等等 (YOLO 论文中叫 AP50, AP75).</p><p>$$mAP&#x3D;\int_{0}^{1}P(R)dR$$</p><p>参考： <a href="https://blog.csdn.net/weixin_42561002/article/details/90409951">https://blog.csdn.net/weixin_42561002/article/details/90409951</a></p><p><a href="https://blog.csdn.net/qq_34690929/article/details/79970565">https://blog.csdn.net/qq_34690929/article/details/79970565</a></p><h2 id="Q：什么是棋盘效应（Checkerboard-Artifacts）？"><a href="#Q：什么是棋盘效应（Checkerboard-Artifacts）？" class="headerlink" title="Q：什么是棋盘效应（Checkerboard Artifacts）？"></a>Q：什么是棋盘效应（Checkerboard Artifacts）？</h2><p><strong>A:</strong></p><p>棋盘效应：主要体现在 GAN 中，指网络生成的图像放大后呈现深浅不一的样子和棋盘有点像。所以叫做棋盘效应。(相邻像素之间颜色相似但不相同（？）)<br>产生原因：使用反卷积 (deconvolution&#x2F;转置卷积)，deconvolution layer 可以允许模型通过每一个点进行绘制高分辨率图像上的一个方块，这种情况的产生与 deconvolution 的 stride、kernel size 有关。<br><strong>如何避免棋盘效应？</strong><br>第一种方法是用到的反卷积核的大小可被步长整除，从而避免重叠效应。与最近成功用于图像超分辨率的技术“子像素卷积”（sub-pixel convolution）等价。</p><p>另一种方法是从卷积操作中分离出对卷积后更高分辨率的特征图上采样来计算特征。例如，可以先缩放图像（最近邻插值或双线性插值），再卷积。貌似是个自然的方法。<br>（原文中说最近邻插值比双线性插值好）<br><strong>Code</strong><br>    Resize-convolution layers can be easily implemented in TensorFlow using <strong>tf. image. resize_images ()</strong>. For best results, use <strong>tf. pad ()</strong> before doing convolution with <strong>tf. nn. conv2d ()</strong> to avoid boundary artifacts.</p><p><a href="https://distill.pub/2016/deconv-checkerboard/">https://distill.pub/2016/deconv-checkerboard/</a>   <strong>best</strong></p><p><a href="https://www.cnblogs.com/hellcat/p/9707204.html">https://www.cnblogs.com/hellcat/p/9707204.html</a></p><h2 id="Q：Sub-pixel-Convolution-子像素卷积-？"><a href="#Q：Sub-pixel-Convolution-子像素卷积-？" class="headerlink" title="Q：Sub-pixel Convolution (子像素卷积)？"></a>Q：Sub-pixel Convolution (子像素卷积)？</h2><p><strong>A:</strong><br><a href="https://blog.csdn.net/leviopku/article/details/84975282">https://blog.csdn.net/leviopku/article/details/84975282</a></p><h2 id="Q-什么是-LR-HR-SR-图像超分辨率"><a href="#Q-什么是-LR-HR-SR-图像超分辨率" class="headerlink" title="Q: 什么是 LR, HR, SR (图像超分辨率)?"></a>Q: 什么是 LR, HR, SR (图像超分辨率)?</h2><p><strong>A:</strong><br>LR: 低分辨率（简称 LR）图像<br>HR: 高分辨率（简称 HR）图像</p><ul><li>高分辨率意味着图像中的像素密度高，能够提供更多的细节，而这些细节在许多实际应用中不可或缺。</li></ul><p>SR: 从多个可观察到的低分辨率（简称 LR）图像得到高分辨率图像，文献中将其称为：超分辨率（简称 SR 或者 HR）图像复原或者简单地叫做分辨率增强。</p><p>图像超分辨率的英文名称是 (Image Super Resolution)。图像超分辨率是指由一幅低分辨率图像或图像序列恢复出高分辨率图像。图像超分辨率技术分为超分辨率复原和超分辨率重建。目前， 图像超分辨率研究可分为 3 个主要范畴： 基于插值、 基于重建和基于学习的方法．<br>超分辨率 (Super-Resolution) 即通过硬件或软件的方法提高原有图像的分辨率，通过一系列低分辨率的图像来得到一幅高分辨率的图像过程就是超分辨率重建。超分辨率重建的核心思想就是用时间带宽 (获取同一场景的多帧图像序列) 换取空间分辨率, 实现时间分辨率向空间分辨率的转换。</p><p>参考：<br><a href="https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/1608635?fr=aladdin">https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/1608635?fr=aladdin</a>  （值得一看）</p><h2 id="Q-什么是-Embedding？"><a href="#Q-什么是-Embedding？" class="headerlink" title="Q: 什么是 Embedding？"></a>Q: 什么是 Embedding？</h2><p><strong>A：</strong><br>Embedding 是一个将离散变量转为连续向量表示的一个方式<br>embedding 就是用一个低维的向量表示一个物体，可以是一个词，或是一个商品，或是一个电影等等。这个 embedding 向量的性质是能使距离相近的向量对应的物体有相近的含义，比如 Embedding (复仇者联盟) 和 Embedding (钢铁侠) 之间的距离就会很接近，但 Embedding (复仇者联盟) 和 Embedding (乱世佳人) 的距离就会远一些。</p><p>除此之外 Embedding 甚至还具有数学运算的关系，比如 Embedding（马德里）-Embedding（西班牙）+Embedding (法国)≈Embedding (巴黎)<br>参考：<br><a href="https://towardsdatascience.com/neural-network-embeddings-explained-4d028e6f0526">https://towardsdatascience.com/neural-network-embeddings-explained-4d028e6f0526</a><br><a href="https://www.jiqizhixin.com/articles/2019-03-27-7">https://www.jiqizhixin.com/articles/2019-03-27-7</a><br><a href="https://www.zhihu.com/question/38002635">https://www.zhihu.com/question/38002635</a></p><h2 id="Q：什么是-Ensemble-Method（集成学习）"><a href="#Q：什么是-Ensemble-Method（集成学习）" class="headerlink" title="Q：什么是 Ensemble Method（集成学习）?"></a>Q：什么是 Ensemble Method（集成学习）?</h2><p><strong>A：</strong> 注意，ensemble 和 embedding 不是一个单词。</p><p>ensemble </p><ul><li>**n.**乐团；整体；全体；全套服装</li><li>合奏；重唱；系综</li></ul><p>embed </p><ul><li>**v.**把…牢牢地嵌入（或插入、埋入）；派遣（战地记者、摄影记者等）</li><li>使嵌入；内嵌；把…嵌入</li></ul><p>集成学习算法本身不算一种单独的机器学习算法，而是通过构建并结合多个机器学习器来完成学习任务。可以说是集百家之所长，能在机器学习算法中拥有较高的准确率，不足之处就是模型的训练过程可能比较复杂，效率不是很高。</p><h2 id="Q：什么是-OOF"><a href="#Q：什么是-OOF" class="headerlink" title="Q：什么是 OOF ?"></a>Q：什么是 OOF ?</h2><p>好像指的是交叉验证。</p><p><a href="https://blog.csdn.net/appleyuchi/article/details/100128835">https://blog.csdn.net/appleyuchi/article/details/100128835</a></p><h2 id="Q-什么是-Triplet-Loss？"><a href="#Q-什么是-Triplet-Loss？" class="headerlink" title="Q: 什么是 Triplet-Loss？"></a>Q: 什么是 Triplet-Loss？</h2><p><strong>参考：</strong><br><a href="https://blog.csdn.net/u013082989/article/details/83537370">https://blog.csdn.net/u013082989/article/details/83537370</a><br><a href="https://omoindrot.github.io/triplet-loss#offline-and-online-triplet-mining">https://omoindrot.github.io/triplet-loss#offline-and-online-triplet-mining</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习问答笔记</title>
    <link href="/2020/07/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>后面有机会会考虑整理一下。</p><h1 id="一些深度学习概念"><a href="#一些深度学习概念" class="headerlink" title="一些深度学习概念"></a>一些深度学习概念</h1><h2 id="一些应该懂的概念"><a href="#一些应该懂的概念" class="headerlink" title="一些应该懂的概念"></a>一些应该懂的概念</h2><h2 id="一些数学符号的意思"><a href="#一些数学符号的意思" class="headerlink" title="一些数学符号的意思"></a>一些数学符号的意思</h2><p>$~$ 符号在数学中是等价于意思，表示前后相等的意思</p><p>**△**是大写希腊字母Delta,在数学中常见用法的有：1、三角形2、二次函数根的判别式<br>3、表示变量的增量,如△x,△y<br>4、表示一个小量<br>5、表示差分<br>6、在Riemann定积分理论中表示一个区间的分割</p><p>▽读Nabla，奈不拉，也可以读作”Del”这是场论中的符号，是矢量微分算符。高等数学中的梯度，散度，旋度都会用到这个算符。其二阶导数中旋度的散度又称Laplace算符。</p><h3 id="IID独立同分布假设"><a href="#IID独立同分布假设" class="headerlink" title="IID独立同分布假设"></a>IID独立同分布假设</h3><p>机器学习领域有个很重要的假设：<strong>IID独立同分布假设</strong>，就是假设训练数据和测试数据是满足相同分布的，这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。</p><h3 id="正交"><a href="#正交" class="headerlink" title="正交"></a>正交</h3><p>若某空间（此空间为内积空间）中两向量的内积为0，则它们正交。类似地，若某空间（内积空间）中的向量v与子空间A中的每个向量都正交，那么这个向量和子空间A正交。若内积空间的子空间A和B满足一者中的每个向量都与另一者正交，那么它们互为正交子空间。</p><h3 id="Vert-的意思"><a href="#Vert-的意思" class="headerlink" title="$\Vert$ 的意思"></a>$\Vert$ 的意思</h3><p>x和y是向量，有时候会用双竖线，来和数的绝对值区分</p><p>两竖里面是未知数，表示范数</p><p>x和y是向量，有时候会用双竖线，来和数的绝对值区分，||X-Y||就是向量作差之后各分量的平方和的开根号。$\sqrt{(x-y)^{2}}$</p><p>一般的双竖线是指一个度量空间的元素X和Y之间的度量</p><h3 id="理解卷积神经网络各个层的作用"><a href="#理解卷积神经网络各个层的作用" class="headerlink" title="理解卷积神经网络各个层的作用"></a>理解卷积神经网络各个层的作用</h3><p>卷积层与池化层  <a href="https://blog.csdn.net/qq_30979017/article/details/79506593">https://blog.csdn.net/qq_30979017/article/details/79506593</a></p><p>激励层：<a href="https://www.zhihu.com/question/22334626">https://www.zhihu.com/question/22334626</a></p><p>全连接层：<a href="https://www.zhihu.com/question/41037974">https://www.zhihu.com/question/41037974</a></p><p>feature map 的数量就是channels</p><h3 id="卷积计算"><a href="#卷积计算" class="headerlink" title="卷积计算"></a>卷积计算</h3><p>squeue input,squeue kernel<br>$$ s&#x3D;strides,p&#x3D;padding,i&#x3D;input size,o&#x3D;output size,k&#x3D;kernel$$</p><h4 id="No-zero-padding-unit-strides"><a href="#No-zero-padding-unit-strides" class="headerlink" title="No zero padding, unit strides"></a>No zero padding, unit strides</h4><p>$$s&#x3D;1,p&#x3D;0时\<br>有o&#x3D;(i-k)+1$$</p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200531210100834.png" alt="image-20200531210100834"></p><h4 id="Zero-padding-unit-strides"><a href="#Zero-padding-unit-strides" class="headerlink" title="Zero padding, unit strides"></a>Zero padding, unit strides</h4><p>$$s&#x3D;1\<br>有o&#x3D;(i-k)+2p+1$$</p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200531211045714.png" alt="image-20200531211045714"></p><h4 id="Half-same-padding"><a href="#Half-same-padding" class="headerlink" title="Half (same) padding"></a>Half (same) padding</h4><p>$$any\ i\ and\ k&#x3D;2n+1,s&#x3D;1\ and p&#x3D;\lfloor k&#x2F;2 \rfloor&#x3D;n\<br>有o&#x3D;i+2\lfloor k&#x2F;2 \rfloor-(k-1)\<br>&#x3D;i+2n-2n\&#x3D;i$$<br><strong>可以使得output size&#x3D;&#x3D;input size</strong></p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200531205637329.png" alt="image-20200531205637329"></p><h4 id="full-padding"><a href="#full-padding" class="headerlink" title="full padding"></a>full padding</h4><p>$$any\ i\ and\ k,p&#x3D;k-1,s&#x3D;1\<br>有o&#x3D;i+2(k-1)-k+1\<br>&#x3D;i+(k-1)$$<br><strong>在此设置中，考虑了内核在输入要素图上可能的部分或全部叠加。</strong></p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200531211202283.png" alt="image-20200531211202283"></p><h4 id="No-zero-padding-non-unit-strides"><a href="#No-zero-padding-non-unit-strides" class="headerlink" title="No zero padding, non-unit strides"></a>No zero padding, non-unit strides</h4><p>$$any\ i,k,s,and\ p&#x3D;0\<br>o&#x3D;\lfloor\frac{i-k}{s} \rfloor+1$$</p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200531211255679.png" alt="image-20200531211255679"></p><h4 id="Zero-padding-non-unit-strides"><a href="#Zero-padding-non-unit-strides" class="headerlink" title="Zero padding, non-unit strides"></a>Zero padding, non-unit strides</h4><p>$$any\ i,k,p,s\<br>o&#x3D;\lfloor\frac{i+2p-k}{s}\rfloor+1$$<br><strong>在i+2p-k是s的倍数的情况下，对于input size j&#x3D;i+a,a属于{0,,,s-1}，将会有相同的output size</strong></p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200531211336023.png" alt="image-20200531211336023"></p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200531211401478.png" alt="image-20200531211401478"></p><h2 id="池化计算"><a href="#池化计算" class="headerlink" title="池化计算"></a>池化计算</h2><p>pooling没有zero padding属性，计算起来简单得多。<br>$$any\ i,k\ and s\<br>有o&#x3D;\lfloor\frac{i-k}{s}\rfloor+1$$</p><h2 id="反卷积（转置卷积）计算Transposed-convolution-arithmetic"><a href="#反卷积（转置卷积）计算Transposed-convolution-arithmetic" class="headerlink" title="反卷积（转置卷积）计算Transposed convolution arithmetic"></a>反卷积（转置卷积）计算Transposed convolution arithmetic</h2><p>转置卷积不是数学意义上的矩阵的逆。<br>置换的卷积并不能保证恢复输入本身，因为它不是定义为卷积的逆，而是返回一个具有相同宽度和高度的特征图</p><h3 id="No-zero-padding-unit-strides-transposed"><a href="#No-zero-padding-unit-strides-transposed" class="headerlink" title="No zero padding, unit strides, transposed"></a>No zero padding, unit strides, transposed</h3><p>$$一个s&#x3D;1,p&#x3D;0的卷积和一个k’&#x3D;k,s’&#x3D;s,p’&#x3D;k-1的转置卷积，\他们的output size为\<br>o’&#x3D;i’+(k-1)$$<br>和 fully padded convolution with unit strides的情况下的计算公式一样的。</p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200602210301346.png" alt="image-20200602210301346"></p><h3 id="Zero-padding-unit-strides-transposed"><a href="#Zero-padding-unit-strides-transposed" class="headerlink" title="Zero padding, unit strides, transposed"></a>Zero padding, unit strides, transposed</h3><p>$$卷积:s-1,k\ and\ p\ 随意，反卷积\ k’&#x3D;k,s’&#x3D;s\ and\ p’&#x3D;k-p-1\<br>o’&#x3D;i’+(k-1)-2p$$</p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200602210240089.png" alt="image-20200602210240089"></p><h3 id="Half-same-padding-transposed"><a href="#Half-same-padding-transposed" class="headerlink" title="Half (same) padding, transposed"></a>Half (same) padding, transposed</h3><p>$$卷积：k&#x3D;2n+1,s&#x3D;1,p&#x3D;\lfloor k&#x2F;2 \rfloor &#x3D;n,反卷积：k’&#x3D;k,s’&#x3D;s\ and\ p’&#x3D;p \<br>o’&#x3D;i’+(k-1)-2p\<br>&#x3D;i’$$</p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200602210220999.png" alt="image-20200602210220999"></p><h3 id="full-padding-transposed"><a href="#full-padding-transposed" class="headerlink" title="full padding, transposed"></a>full padding, transposed</h3><p>$$卷积：s&#x3D;1,k\ and\ p&#x3D;k-1,反卷积:k’&#x3D;k,s’&#x3D;s\ and p’&#x3D;0\<br>o’&#x3D;i’+(k-1)-2p\<br>&#x3D;i’-(k-1)$$</p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200602210139154.png" alt="image-20200602210139154"></p><h3 id="No-zero-padding-non-unit-strides-transposed"><a href="#No-zero-padding-non-unit-strides-transposed" class="headerlink" title="No zero padding, non-unit strides, transposed"></a>No zero padding, non-unit strides, transposed</h3><p>$$o’&#x3D;s(i’-1)+k$$</p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200602205723838.png" alt="image-20200602205723838"></p><h3 id="zero-padding-non-unit-strides-transposed"><a href="#zero-padding-non-unit-strides-transposed" class="headerlink" title="zero padding, non-unit strides, transposed"></a>zero padding, non-unit strides, transposed</h3><p>$$o’&#x3D;s(i’-1)+k-2p$$</p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200602205648363.png" alt="image-20200602205648363"></p><p>$$o’&#x3D;s(i’-1)+a+k-2p$$</p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/Image-20200602205609823.png" alt="image-20200602205609823"></p><h2 id="空洞卷积"><a href="#空洞卷积" class="headerlink" title="空洞卷积"></a>空洞卷积</h2><p>空洞卷积新增了d空洞率这个要素。<br>因此用有效内核大小来理解空洞卷积的内核大小<br>有效内核大小的计算如下：<br>$$k’&#x3D;k+(k-1)(d-1)$$<br>把k’带入公式6可以得到<br>$$o&#x3D;\lfloor \frac{i+2p-k-(k-1)(d-1)}{s}+1\rfloor$$</p><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%97%AE%E7%AD%94%E7%AC%94%E8%AE%B0/image-20200602204631600.png" alt="深度学习问答笔记&#x2F;image-20200602204631600"></p><h2 id="神经网络不收敛的原因"><a href="#神经网络不收敛的原因" class="headerlink" title="神经网络不收敛的原因"></a>神经网络不收敛的原因</h2><p>1、忘记对你的数据进行归一化<br>2、忘记检查输出结果<br>3、没有对数据进行预处理<br>4、没有使用任何的正则化方法<br>5、使用了一个太大的 batch size<br>6、使用一个错误的学习率<br>7、在最后一层使用错误的激活函数<br>8、网络包含坏的梯度<br>9、网络权重没有正确的初始化<br>10、使用了一个太深的神经网络<br>11、隐藏层神经元数量设置不正确<br><a href="https://zhuanlan.zhihu.com/p/369716572">https://zhuanlan.zhihu.com/p/369716572</a></p><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><h2 id="人脸"><a href="#人脸" class="headerlink" title="人脸"></a>人脸</h2><p>一个人脸数据集，标签是自己的txt和mat不过网上有好心人转成了voc</p><p><a href="http://shuoyang1213.me/WIDERFACE/">http://shuoyang1213.me/WIDERFACE/</a></p><h2 id="COCO"><a href="#COCO" class="headerlink" title="COCO"></a>COCO</h2><p>COCO简介<br><a href="https://arleyzhang.github.io/articles/e5b86f16/">https://arleyzhang.github.io/articles/e5b86f16/</a></p><h2 id="CASIA-B"><a href="#CASIA-B" class="headerlink" title="CASIA-B"></a>CASIA-B</h2><p>一个比较经典的步态数据集<br>GaitDatasetB-silh文件里面<br>第一层为001 002 。。。表示受试者</p><p>第二层里面 bg-01 nm-01 cl-01 分别表示正常（NM）（每个受试者6个序列）、带包（BG）（每个受试者2个序列）和穿外套（CL）（每个受试者2个序列），即每个受试者有11×（6+2+2）&#x3D;110个序列。</p><p>第三层 000 018 036 054 072 090 108 126 144 162 180 表示11个不同的拍摄角度。</p><h2 id="关于-Batch-Size"><a href="#关于-Batch-Size" class="headerlink" title="关于 Batch-Size"></a>关于 Batch-Size</h2><p><a href="https://www.cnblogs.com/WenaoMa/p/10041811.html">https://www.cnblogs.com/WenaoMa/p/10041811.html</a></p><p>一般来讲 BS 尽可能的多比较好，但我自己目前的经验是 BN 小一点比较好的样子<br>看具体情况，可能还是大一点的好。</p><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><p><a href="https://www.cnblogs.com/wangxiaocvpr/p/11656603.html">https://www.cnblogs.com/wangxiaocvpr/p/11656603.html</a></p><h1 id="网络系列"><a href="#网络系列" class="headerlink" title="网络系列"></a>网络系列</h1><h2 id="YOLOV3"><a href="#YOLOV3" class="headerlink" title="YOLOV3"></a>YOLOV3</h2><p>一个毕设 改进yolov3<br><a href="https://coreja.com/Schoolwork/2019/05/%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95YOLOv3%E7%9A%84%E6%94%B9%E8%BF%9B%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87/">https://coreja.com/Schoolwork/2019/05/%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95YOLOv3%E7%9A%84%E6%94%B9%E8%BF%9B%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87/</a></p><p><a href="https://blog.csdn.net/litt1e/article/details/88907542">https://blog.csdn.net/litt1e/article/details/88907542</a></p><p><a href="https://www.cnblogs.com/llfctt/p/9037677.html">https://www.cnblogs.com/llfctt/p/9037677.html</a></p><p><a href="https://blog.csdn.net/chandanyan8568/article/details/81089083">https://blog.csdn.net/chandanyan8568/article/details/81089083</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows安装pymouse</title>
    <link href="/2020/04/13/windows%E5%AE%89%E8%A3%85pymouse/"/>
    <url>/2020/04/13/windows%E5%AE%89%E8%A3%85pymouse/</url>
    
    <content type="html"><![CDATA[<h1 id="安装pymouse"><a href="#安装pymouse" class="headerlink" title="安装pymouse"></a>安装pymouse</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pymouse<br></code></pre></td></tr></table></figure><p>遇到报错</p><h2 id="ModuleNotFoundError-No-module-named-‘windows’"><a href="#ModuleNotFoundError-No-module-named-‘windows’" class="headerlink" title="ModuleNotFoundError: No module named ‘windows’"></a>ModuleNotFoundError: No module named ‘windows’</h2><p>此时需要下载一个叫 PyUserinput的包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install PyUserinput<br></code></pre></td></tr></table></figure><p>但是遭遇</p><h2 id="Could-not-find-a-version-that-satisfies-the-requirement-pyHook-from-PyUserinput-from-versions-No-matching-distribution-found-for-pyHook-from-PyUserinput"><a href="#Could-not-find-a-version-that-satisfies-the-requirement-pyHook-from-PyUserinput-from-versions-No-matching-distribution-found-for-pyHook-from-PyUserinput" class="headerlink" title="Could not find a version that satisfies the requirement pyHook (from PyUserinput) (from versions: )No matching distribution found for pyHook (from PyUserinput)"></a>Could not find a version that satisfies the requirement pyHook (from PyUserinput) (from versions: )No matching distribution found for pyHook (from PyUserinput)</h2><p><img src="https://img-blog.csdnimg.cn/20200413172042294.png" alt="在这里插入图片描述"></p><p>需要下载个pyHook ，不过明显不能通过pip直接下载了</p><p><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyhook">https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyhook</a></p><p>去这个网址里面找到pyHook，下载符合自己python版本的whl文件在电脑上</p><p><img src="https://img-blog.csdnimg.cn/20200413172248659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdWh1Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>然后cmd里面切换到该whl文件所在地方。</p><p>输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pyHook-<span class="hljs-number">1.5</span><span class="hljs-number">.1</span>-cp36-cp36m-win_amd64.whl<br>(因为我的python是<span class="hljs-number">3.6</span>版本的)<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200413172459656.png" alt="在这里插入图片描述"></p><p>就下载好了</p><p>这时再下载好PyUserinput就万事OK了</p><p>pymouse也就可以用了</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pymouse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows使用convert_torch转换模型</title>
    <link href="/2020/03/26/windows%E4%BD%BF%E7%94%A8convert_torch%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/03/26/windows%E4%BD%BF%E7%94%A8convert_torch%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想要使用<br><a href="https://github.com/clcarwin/convert_torch_to_pytorch">https://github.com/clcarwin/convert_torch_to_pytorch</a></p><p>但是必须要pytorch0.4.1的环境</p><p>打算创一个虚拟环境</p><h1 id="虚拟环境相关命令"><a href="#虚拟环境相关命令" class="headerlink" title="虚拟环境相关命令"></a>虚拟环境相关命令</h1><p>1、创建python虚拟环境。<br>  使用 conda create -n your_env_name python&#x3D;X.X（3.6等)命令创建python版本为X.X、名字为your_env_name的虚拟环境。your_env_name文件可以在Anaconda安装目录envs文件下找到。</p><p> 2、激活环境<br>  Linux:  source activate your_env_name(虚拟环境名称)<br>   Windows: activate your_env_name(虚拟环境名称)</p><p>3、关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)。</p><p>   使用如下命令即可。</p><p>   Linux: source deactivate</p><p>   Windows: deactivate</p><p>4、删除虚拟环境。</p><p>   使用命令conda remove -n your_env_name(虚拟环境名称) –all， 即可删除。</p><p>5、删除环境中的某个包。</p><p>   使用命令conda remove –name your_env_name  package_name 即可。</p><p><strong>参考</strong>： <a href="https://blog.csdn.net/lyy14011305/article/details/59500819">https://blog.csdn.net/lyy14011305/article/details/59500819</a></p><h1 id="安装pytorch-0-4-1"><a href="#安装pytorch-0-4-1" class="headerlink" title="安装pytorch 0.4.1"></a>安装pytorch 0.4.1</h1><p><a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a></p><p>找安装方法去官网是最好的 </p><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">conda install pytorch=<span class="hljs-number">0.4</span><span class="hljs-number">.1</span> cuda90 -c pytorch<br></code></pre></td></tr></table></figure><p>失败，cuda90的环境倒是安装成功，但是pytorch没有安装成功，应该是网络的问题，但是我本来就挂了梯子。。。</p><h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h2><p><img src="https://img-blog.csdnimg.cn/2020032523392094.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppdWh1Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在官网上下载whl文件后在本地安装。</p><p>下载好合适的whl文件后，切换到whl文件所在的文件夹，输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install xxx(文件名)<br></code></pre></td></tr></table></figure><p>就安装成功了</p><h3 id="遭遇问题"><a href="#遭遇问题" class="headerlink" title="遭遇问题"></a>遭遇问题</h3><h4 id="1、ERROR-torch-0-4-1-cp37-cp37m-win-amd64-whl-is-not-a-supported-wheel-on-this-platform"><a href="#1、ERROR-torch-0-4-1-cp37-cp37m-win-amd64-whl-is-not-a-supported-wheel-on-this-platform" class="headerlink" title="1、ERROR: torch-0.4.1-cp37-cp37m-win_amd64.whl is not a supported wheel on this platform."></a>1、ERROR: torch-0.4.1-cp37-cp37m-win_amd64.whl is not a supported wheel on this platform.</h4><p>解决：我的版本不对应，37是指python3.7版本，而我的虚拟环境是3.6版本</p><h4 id="2、在import-torch时遇到ImportError-numpy-core-multiarray-failed-to-import"><a href="#2、在import-torch时遇到ImportError-numpy-core-multiarray-failed-to-import" class="headerlink" title="2、在import torch时遇到ImportError: numpy.core.multiarray failed to import"></a>2、在import torch时遇到ImportError: numpy.core.multiarray failed to import</h4><p>解决：降低numpy版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install -U numpy==<span class="hljs-number">1.12</span><span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><h1 id="运行convert-torch-py"><a href="#运行convert-torch-py" class="headerlink" title="运行convert_torch.py"></a>运行convert_torch.py</h1><h2 id="遭遇问题："><a href="#遭遇问题：" class="headerlink" title="遭遇问题："></a>遭遇问题：</h2><h3 id="1、RuntimeError-cuda-runtime-error-30-unknown-error-at-aten-src-THC-THCGeneral-cpp-119"><a href="#1、RuntimeError-cuda-runtime-error-30-unknown-error-at-aten-src-THC-THCGeneral-cpp-119" class="headerlink" title="1、RuntimeError: cuda runtime error (30) : unknown error at ..\aten\src\THC\THCGeneral.cpp:119"></a>1、RuntimeError: cuda runtime error (30) : unknown error at ..\aten\src\THC\THCGeneral.cpp:119</h3><p>解决：在文件最前端加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ·python">torch.cuda.current_device()<br></code></pre></td></tr></table></figure><p><strong>参考</strong>：</p><p><a href="https://github.com/pytorch/pytorch/issues/17108">https://github.com/pytorch/pytorch/issues/17108</a></p><h3 id="2、torch-utils-serialization-read-lua-file-T7ReaderException-unknown-type-id-1008669213-The-file-may-be-corrupted"><a href="#2、torch-utils-serialization-read-lua-file-T7ReaderException-unknown-type-id-1008669213-The-file-may-be-corrupted" class="headerlink" title="2、torch.utils.serialization.read_lua_file.T7ReaderException: unknown type id 1008669213. The file may be corrupted."></a>2、torch.utils.serialization.read_lua_file.T7ReaderException: unknown type id 1008669213. The file may be corrupted.</h3><p>解决：把文件中的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = load_lua(t7_filename,unknown_classes=<span class="hljs-literal">True</span>) <br>改为<br>model = load_lua(t7_filename,unknown_classes=<span class="hljs-literal">True</span>,long_size=<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p><strong>参考</strong>：</p><p><a href="https://github.com/bobbens/sketch_simplification/issues/2">https://github.com/bobbens/sketch_simplification/issues/2</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指定目录打开jupyter notbook</title>
    <link href="/2020/03/18/%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E6%89%93%E5%BC%80jupyter%20notbook/"/>
    <url>/2020/03/18/%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E6%89%93%E5%BC%80jupyter%20notbook/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-comment">rem </span><br><span class="hljs-built_in">dir</span><br>jupyter notebook <br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><p>复制进.bat文件放进想要在jupyter里面打开的目录，双击bat文件，就可以打开了</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下opencv-python的安装</title>
    <link href="/2020/02/26/Ubuntu%E4%B8%8Bopencv-python%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2020/02/26/Ubuntu%E4%B8%8Bopencv-python%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="安装命令："><a href="#安装命令：" class="headerlink" title="安装命令："></a>安装命令：</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> opencv-python<br></code></pre></td></tr></table></figure><h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">   <span class="hljs-built_in">from</span> .cv2 import *<br>ImportError: libSM.so<span class="hljs-number">.6</span>: cannot <span class="hljs-built_in">open</span> shared object <span class="hljs-built_in">file</span>: No such <span class="hljs-built_in">file</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">directory</span><br></code></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install libsm6 libxrender1 libfontconfig1<br></code></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/47113029/importerror-libsm-so-6-cannot-open-shared-object-file-no-such-file-or-directo">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>深度学习</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode常用快捷键</title>
    <link href="/2019/10/27/vscode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2019/10/27/vscode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>Ctrl + Shift + P，打开命令面板</p><p>Ctrl + f    搜索</p><p>Ctrl + ` 打开终端</p><p>Ctrl + 放大</p><p>Ctrl - 缩小</p><p>Ctrl + ←→ 以单词为单位移动光标</p><p>Ctrl + Shift + \ 在括号间跳转<br>移动光标的同时按住shift，会把字符全部选中<br>Ctrl + shift + k 删除当前代码行</p><p>Ctrl + x 剪切当前代码行</p><p>Ctrl + enter 在当前行的下面新开始一行</p><p>Ctrl + shift + enter 在当前行的上面新开始一行</p><p>Alt + ↑↓     上下移动当前行</p><p>Ctrl +&#x2F;       注释代码</p><p><strong>Alt + Shift + F 对代码进行格式化</strong></p><p>Ctrl + u         撤销光标的移动和选择</p><p>Atl +鼠标点     多光标</p><p><strong>Cmd + D       第一次按下时，它会选中光标附近的单词；第二次按下时，它会找到这个单词第二次出现的位置，创建一个新的光标，并且选中它。</strong></p><p>Ctrl + P 打开最近使用的文件的列表</p><p>Ctrl + TAB 在已打开的文件中切换</p><p>Ctrl + enter 在选中要打开的文件后，按了之后文件就会在并列的窗口里面打开</p><p>Ctrl + g   进行行数跳转</p><p><strong>Ctrl + shift + o 可以看见文档里面所有的符号（在@后面加：可以看见变量的别类）</strong></p><p><strong>Ctrl + F12，跳转到函数实现的位置</strong></p><p>shift + F12 打开函数引用预览</p><p>单击鼠标左键可以把光标移动到相应的位置。双击鼠标左键，则会将当前光标下的单词选中。</p><p>连续三次按下鼠标左键，则会选中当前这一行代码。</p><p>连续四次按下鼠标左键，则会选中整个文档。</p><p>单击行号，就能够直接选中这一行。</p><p>如果在某个行号上按下鼠标，然后上下移动，则能够选中多行代码。</p><p>选中+拖拽 对当前行进行剪切加粘贴</p><p>选中+拖拽+Ctrl  对当前行进行复制加粘贴</p><p>Ctrl + 鼠标左键  打开超级链接，跳转到函数</p><p>Ctrl + 空格 调出补全窗口</p><p>Ctrl + .   调出快速修复的建议列表</p><p>F2    修改所有这个函数或者变量都会被修改</p><p>Ctrl +shift +[     折叠代码</p><p>Ctrl + shift + ]     展开代码</p><p>Ctrl +k Ctrl +0 折叠所有代码</p><p>Ctrl +k Ctrl +j   展开所有代码</p><p><img src="https://img-blog.csdnimg.cn/20191111235803790.png" alt="注意搜索栏旁边的按钮，以及前面的箭头"></p><p>Alt + C 打开大小写</p><p>Alt + W 全单词匹配</p><p>Alt + R 正则表达式</p><p><img src="https://img-blog.csdnimg.cn/20191112000150997.png" alt="箭头点开有替换功能"></p><p>editor minimap 和小地图有关的设置</p><p>editor cursor， 是跟光标渲染和多光标相关的设置；</p><p>editor find， 是与编辑器内搜索相关的设置；</p><p>editor font， 是与字体有关的设置；</p><p>editor format， 是代码格式化；</p><p>editor suggest， 是和自动补全、建议窗口等相关的配置。</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
