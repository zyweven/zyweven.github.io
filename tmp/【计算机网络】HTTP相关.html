

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/1.png">
  <link rel="icon" href="/img/1.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#6a598c">
  <meta name="author" content="even zhang">
  <meta name="keywords" content="">
  
    <meta name="description" content="状态码状态码 502，504 有什么区别？502 是网关错误，服务器本身没有问题，上游服务器发生了错误。电话打通没人接504 是网管超时，服务器本身没有问题，上游服务器发生了错误。电话打不通。 http 的 method？具体？HTTP 协议中定义了多种请求方法（Method），常见的有以下几种：  GET：用于获取资源，请求参数会附加在 URL 的后面。 POST：用于向服务器提交数据，请求参数">
<meta property="og:type" content="website">
<meta property="og:title" content="【计算机网络】HTTP相关">
<meta property="og:url" content="https://zyweven.github.io/tmp/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%9B%B8%E5%85%B3.html">
<meta property="og:site_name" content="Even">
<meta property="og:description" content="状态码状态码 502，504 有什么区别？502 是网关错误，服务器本身没有问题，上游服务器发生了错误。电话打通没人接504 是网管超时，服务器本身没有问题，上游服务器发生了错误。电话打不通。 http 的 method？具体？HTTP 协议中定义了多种请求方法（Method），常见的有以下几种：  GET：用于获取资源，请求参数会附加在 URL 的后面。 POST：用于向服务器提交数据，请求参数">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-06T14:05:00.000Z">
<meta property="article:modified_time" content="2023-03-06T14:10:03.835Z">
<meta property="article:author" content="even zhang">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【计算机网络】HTTP相关 - Even</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />





<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zyweven.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Even</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">【计算机网络】HTTP相关</span>
          
        </div>

        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      <div class="container nopadding-x-md">
        <div id="board"
          >
          
          <div class="container">
            <div class="row">
              <div class="col-12 col-md-10 m-auto">
                

<article class="page-content">
  <h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码 502，504 有什么区别？<br>502 是网关错误，服务器本身没有问题，上游服务器发生了错误。电话打通没人接<br>504 是网管超时，服务器本身没有问题，上游服务器发生了错误。电话打不通。</p>
<h2 id="http-的-method？具体？"><a href="#http-的-method？具体？" class="headerlink" title="http 的 method？具体？"></a>http 的 method？具体？</h2><p>HTTP 协议中定义了多种请求方法（Method），常见的有以下几种：</p>
<ol>
<li>GET：用于获取资源，请求参数会附加在 URL 的后面。</li>
<li>POST：用于向服务器提交数据，请求参数会包含在请求体中。</li>
<li>PUT：用于更新资源，请求参数会包含在请求体中。</li>
<li>DELETE：用于删除资源，请求参数会包含在请求体中。</li>
<li>HEAD：与 GET 类似，但只返回响应头部，不返回响应体。</li>
<li>OPTIONS：用于获取目标资源支持的 HTTP 请求方法。</li>
<li>TRACE：用于追踪请求-响应的传输路径。</li>
<li>CONNECT：用于建立与目标资源的双向通信隧道。</li>
</ol>
<p>常用：GET 用于获取数据，POST 用于提交数据，PUT 用于更新数据，DELETE 用于删除数据。</p>
<h2 id="Get-和-post-的区别"><a href="#Get-和-post-的区别" class="headerlink" title="Get 和 post 的区别"></a>Get 和 post 的区别</h2><p>GET 主要用于获取资源，POST 主要用于提交表单或进行数据处理操作。</p>
<ol>
<li>GET 请求会把参数放在 URL 的后面，而 POST 请求则放在请求的实体中。</li>
<li>GET 请求的参数有长度限制，一般不能超过 1024 字节，而 POST 请求的参数则没有限制。</li>
<li>GET 请求会在 URL 中暴露参数，因此不适合用来传输敏感信息，而 POST 请求则更加安全。</li>
<li>GET 请求可以通过浏览器地址栏来直接访问，而 POST 请求则需要在表单中进行提交或通过 JavaScript 等编程语言来提交。</li>
<li>GET 请求的参数可以被缓存，而 POST 请求的参数不会被缓存。<br>GET 请求通常用于获取数据，而 POST 请求通常用于提交数据。GET 请求的参数在 URL 中传递，而 POST 请求的参数则在请求体中传递。GET 请求的参数有长度限制，而 POST 请求的参数则没有。GET 请求可以被缓存，POST 请求则不会。GET 请求比 POST 请求更不安全，因为参数会暴露在 URL 中。</li>
</ol>
<h2 id="http-和-tcp-有什么关系？"><a href="#http-和-tcp-有什么关系？" class="headerlink" title="http 和 tcp 有什么关系？"></a>http 和 tcp 有什么关系？</h2><p>HTTP（超文本传输协议）和 TCP（传输控制协议）是两个不同的协议，但它们之间存在密切的关系。</p>
<p>HTTP 是一种应用层协议，用于定义客户端和服务器之间的通信格式。<br>TCP 是一种传输层协议，它为应用程序提供了可靠的、面向连接的数据传输服务。</p>
<p>在 HTTP 通信过程中，客户端通过 TCP 协议与服务器建立连接，并在这个连接上进行数据传输。TCP 协议提供了可靠的、有序的数据传输服务，保证了数据的完整性和可靠性。因此，HTTP 协议需要借助 TCP 协议来进行数据传输。</p>
<p>HTTP 协议依赖于 TCP 协议来进行数据传输。TCP 协议提供了 HTTP 协议所需要的可靠的、面向连接的数据传输服务。</p>
<h2 id="HTTPs-的全称"><a href="#HTTPs-的全称" class="headerlink" title="HTTPs 的全称"></a>HTTPs 的全称</h2><p>超文本传输安全协定<br><strong>Hypertext Transfer Protocol over Secure Socket Layer</strong></p>
<h2 id="http-和-https-的区别？"><a href="#http-和-https-的区别？" class="headerlink" title="http 和 https 的区别？"></a>http 和 https 的区别？</h2><p>http&#x2F;https 的区别（抠细节）</p>
<ol>
<li>HTTP 是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加入了 SSL&#x2F;TLS 安全协议，使得报⽂能够加密传输。</li>
<li>HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报⽂传输。而 HTTPS 在 TCP 三次握手之后，还需进⾏ SSL&#x2F;TLS 的握手过程，才可进⼊加密报文传输。</li>
</ol>
<h2 id="说下-https-的握手流程（对称加密、非对称加密）"><a href="#说下-https-的握手流程（对称加密、非对称加密）" class="headerlink" title="说下 https 的握手流程（对称加密、非对称加密）"></a>说下 https 的握手流程（对称加密、非对称加密）</h2><ol>
<li>客户端向服务器发送一个加密套件列表，包含了客户端支持的加密算法列表和其他参数。</li>
<li>服务器从加密套件列表中选择一个加密套件，并将自己的证书和公钥发送给客户端。</li>
<li>客户端使用服务器的公钥对证书进行验证，确认服务器身份的合法性。如果验证失败，则连接断开。</li>
<li>客户端生成一个随机的对称密钥，并使用服务器的公钥对其进行加密，然后将密文发送给服务器。</li>
<li>服务器使用自己的私钥对密文进行解密，得到对称密钥。</li>
<li>客户端和服务器都确认对称密钥已经建立，接下来的所有通信都将使用该对称密钥进行加密和解密。</li>
</ol>
<p>整个握手过程使用了非对称加密算法和对称加密算法。客户端和服务器通过非对称加密算法安全地交换对称密钥，而后续的通信都使用对称加密算法进行加密和解密。整个过程主要是为了建立安全的通信通道，防止信息被窃听和篡改。</p>
<h2 id="https-加密过程（详细）"><a href="#https-加密过程（详细）" class="headerlink" title="https 加密过程（详细）"></a>https 加密过程（详细）</h2><ol>
<li>首先，浏览器向服务器发送 HTTPS 请求，请求的 URL 以 <a target="_blank" rel="noopener" href="https://xn--%2Chttp-oi1h797dgtk8wpx54d//%E3%80%82">https:&#x2F;&#x2F;开头，而不是http:&#x2F;&#x2F;。</a></li>
<li>服务器将自己的公钥和证书发送给浏览器。证书是由权威机构颁发的，用于证明服务器身份的一种数字证书。</li>
<li>浏览器验证服务器证书的有效性。如果证书有效，则浏览器生成一个随机的对称密钥，并使用服务器的公钥加密这个对称密钥。</li>
<li>服务器使用自己的私钥对加密后的对称密钥进行解密。</li>
<li>服务器将加密后的 HTTP 响应和生成的对称密钥一起发送给浏览器。</li>
<li>浏览器使用对称密钥对 HTTP 响应进行解密，得到明文内容。</li>
</ol>
<p>在这个过程中，使用了非对称加密算法和对称加密算法。非对称加密算法用于安全地交换对称密钥，对称加密算法用于加密 HTTP 请求和响应的数据。由于对称加密算法的速度较快，因此 HTTPS 的安全性和速度都得到了很好的平衡。</p>
<h2 id="在-HTTPS-协议中，数字证书的单项认证和双向认证流程？"><a href="#在-HTTPS-协议中，数字证书的单项认证和双向认证流程？" class="headerlink" title="在 HTTPS 协议中，数字证书的单项认证和双向认证流程？"></a>在 HTTPS 协议中，数字证书的单项认证和双向认证流程？</h2><p>单向认证流程：</p>
<ol>
<li>客户端向服务器发起 HTTPS 请求。</li>
<li>服务器将自己的数字证书发送给客户端。</li>
<li>客户端验证服务器的数字证书是否合法。</li>
<li>如果数字证书合法，客户端会生成一个随机数，并使用服务器的公钥对随机数进行加密，然后发送给服务器。</li>
<li>服务器使用自己的私钥对加密后的随机数进行解密。</li>
<li>服务器使用客户端发送的随机数生成一个对称密钥，并使用对称密钥对通信数据进行加密。</li>
<li>服务器将加密后的通信数据发送给客户端。</li>
<li>客户端使用对称密钥对加密后的数据进行解密。</li>
</ol>
<p>双向认证流程：</p>
<ol>
<li>客户端向服务器发起 HTTPS 请求。</li>
<li>服务器将自己的数字证书发送给客户端。</li>
<li>客户端验证服务器的数字证书是否合法。</li>
<li>如果数字证书合法，客户端会生成一个随机数，并使用服务器的公钥对随机数进行加密，然后发送给服务器。</li>
<li>服务器使用自己的私钥对加密后的随机数进行解密。</li>
<li>服务器使用客户端发送的随机数和自己的私钥生成一个对称密钥，并使用对称密钥对通信数据进行加密。</li>
<li>服务器将加密后的通信数据和自己的数字证书发送给客户端。</li>
<li>客户端验证服务器的数字证书是否合法，并使用服务器的公钥对加密后的数据进行解密。</li>
<li>客户端使用服务器发送的随机数和客户端的私钥生成一个对称密钥，并使用对称密钥对通信数据进行加密。</li>
<li>客户端将加密后的通信数据和自己的数字证书发送给服务器。</li>
<li>服务器验证客户端的数字证书是否合法，并使用客户端的公钥对加密后的数据进行解密。</li>
<li>通信双方使用对称密钥对加密后的数据进行解密。</li>
</ol>
<h2 id="对称加密和非对称加密流程如何？"><a href="#对称加密和非对称加密流程如何？" class="headerlink" title="对称加密和非对称加密流程如何？"></a>对称加密和非对称加密流程如何？</h2><p>对称加密和非对称加密是常见的加密算法，两者的加密流程有一些不同。</p>
<p>对称加密的加密流程如下：</p>
<ol>
<li>首先需要有一个密钥，该密钥用于加密和解密数据。</li>
<li>发送方使用该密钥对要传输的数据进行加密。</li>
<li>接收方使用相同的密钥对加密后的数据进行解密。</li>
</ol>
<p>对称加密的优点是速度快，但缺点是密钥需要在发送方和接收方之间共享，容易被窃取。</p>
<p>非对称加密的加密流程如下：</p>
<ol>
<li>发送方生成一对密钥，即公钥和私钥。公钥可以公开，私钥必须保密。</li>
<li>发送方使用接收方的公钥对要传输的数据进行加密。</li>
<li>接收方使用自己的私钥对加密后的数据进行解密。</li>
</ol>
<p>非对称加密的优点是密钥不需要共享，安全性更高，但缺点是速度较慢。</p>
<p>实际应用中，通常采用混合加密的方式，即使用对称加密算法加密数据，然后使用非对称加密算法加密对称密钥，将加密后的对称密钥和加密后的数据一起传输。接收方使用自己的私钥解密对称密钥，再使用对称密钥解密数据。这样既保证了加密速度，又保证了安全性。</p>
<h2 id="CA-证书以及-CA-证书的运转过程。"><a href="#CA-证书以及-CA-证书的运转过程。" class="headerlink" title="CA 证书以及 CA 证书的运转过程。"></a>CA 证书以及 CA 证书的运转过程。</h2><h2 id="HTTP-2-与-HTTP-的区别"><a href="#HTTP-2-与-HTTP-的区别" class="headerlink" title="HTTP&#x2F;2 与 HTTP 的区别"></a>HTTP&#x2F;2 与 HTTP 的区别</h2><ol>
<li><p>二进制分帧：HTTP&#x2F;2 使用二进制格式分割数据成更小的帧，可以并行处理，减少延迟和提高效率。</p>
</li>
<li><p>多路复用：HTTP&#x2F;2 可以在一个 TCP 连接上同时传输多个请求和响应，避免了 HTTP1. x 中的“队头阻塞”问题，提高了并发性能。</p>
</li>
<li><p>首部压缩：HTTP&#x2F;2 使用 HPACK 算法对首部信息进行压缩，减少了数据传输的大小。</p>
</li>
<li><p>服务器推送：HTTP&#x2F;2 允许服务器在客户端请求之前就预先推送数据，提高了页面的加载速度。</p>
</li>
</ol>
<p>综上所述，HTTP&#x2F;2 相比于 HTTP1. x 在性能和效率上有了明显的提升，能够更好地应对现代 Web 应用的需求。</p>
<h2 id="cookie-和-session-有什么区别？"><a href="#cookie-和-session-有什么区别？" class="headerlink" title="cookie 和 session 有什么区别？"></a>cookie 和 session 有什么区别？</h2><p> Cookie 和 Session 是用于在 Web 应用程序中跟踪用户状态的两种常用技术，它们之间有以下区别：</p>
<ol>
<li><p>存储位置不同：Cookie 是存储在客户端浏览器中的小型文本文件，而 Session 是存储在服务器端的一种数据结构。</p>
</li>
<li><p>数据安全性不同：Cookie 中的数据可以被用户轻松地修改和篡改，因此在存储敏感信息时需要进行加密处理；而 Session 存储在服务器端，用户无法修改其中的数据。</p>
</li>
<li><p>存储容量不同：Cookie 的存储容量有限制，不同浏览器和不同版本的浏览器也有所差异，而 Session 的存储容量相对较大。</p>
</li>
<li><p>有效期不同：Cookie 可以设置一个过期时间，使其在一定时间后失效，而 Session 默认的失效时间是 30 分钟（可以通过配置进行修改）。</p>
</li>
<li><p>使用场景不同：Cookie 适用于存储少量的非敏感性数据，如用户 ID、用户名等信息；而 Session 适用于存储较多的敏感性数据，如用户的登录状态、权限等信息。</p>
</li>
</ol>
<p>Cookie 是一种在客户端（浏览器）保存用户信息的机制，服务器可以通过设置 HTTP 响应头中的 Set-Cookie 字段将数据保存在客户端的浏览器中，以后每次请求时，客户端会自动将 Cookie 数据发送给服务器，服务器就可以根据这些数据判断用户的身份并提供相应的服务。</p>
<p>Session 则是一种在服务器端维护用户状态的机制，服务器通过在内存或者磁盘中保存 Session 数据来维护用户的状态，客户端浏览器只会保存一个 Session ID 的 Cookie，而所有用户的数据都保存在服务器端的 Session 中。每次客户端请求时，服务器会根据 Session ID 来获取对应的 Session 数据，从而实现对用户状态的维护。</p>
<ol>
<li><p>实现方式：Cookie 是在客户端保存数据，而 Session 是在服务器端保存数据。</p>
</li>
<li><p>数据存储：Cookie 将数据以明文的方式存储在浏览器中，不安全，而 Session 数据保存在服务器端，相对安全。</p>
</li>
<li><p>扩展性：Cookie 比较容易扩展，可以支持多种数据格式，而 Session 则需要服务器端进行扩展。</p>
</li>
<li><p>跨域支持：Cookie 可以跨域共享，而 Session 只能在同一域名下共享。</p>
</li>
</ol>
<h2 id="RPC-与-HTTP"><a href="#RPC-与-HTTP" class="headerlink" title="RPC 与 HTTP"></a>RPC 与 HTTP</h2><p>RPC 和 HTTP 都是网络通信协议，不同之处在于它们的使用方式和目的。</p>
<p>HTTP 协议通常用于客户端和服务器之间的请求和响应通信，支持使用 GET、POST、PUT、DELETE 等方法进行数据传输。HTTP 协议的特点是简单易用，但是在处理大量请求时可能存在效率问题。</p>
<p>而 RPC (Remote Procedure Call) 协议是一种远程调用协议，它的目的是为了让不同的程序在网络中进行通信，实现远程过程调用。RPC 通过编程语言中的函数调用来实现通信，可以使分布式系统之间的通信变得更加简单高效。</p>
<p>HTTP 和 RPC 的区别在于，HTTP 更加通用，可用于不同类型的应用程序通信，而 RPC 通常用于处理更加复杂的分布式系统通信。另外，RPC 通常使用二进制协议进行数据传输，效率更高，但是对于开发人员来说需要处理更多的细节问题。</p>
<h2 id="grpc-底层的通信协议"><a href="#grpc-底层的通信协议" class="headerlink" title="grpc 底层的通信协议"></a>grpc 底层的通信协议</h2><p>gRPC 底层的通信协议是 HTTP&#x2F;2，它是 HTTP 协议的最新版本，与 HTTP&#x2F;1. x 相比有很多优势，如：</p>
<ol>
<li><p>多路复用：HTTP&#x2F;2 允许在一个 TCP 连接上并发发送多个请求和响应，避免了 HTTP&#x2F;1. x 中的队头阻塞问题，提高了网络利用率和性能。</p>
</li>
<li><p>二进制分帧：HTTP&#x2F;2 将请求和响应数据分割成多个二进制帧，在网络上发送，提高了传输效率和可靠性。</p>
</li>
<li><p>首部压缩：HTTP&#x2F;2 使用 HPACK 算法对 HTTP 首部进行压缩，减少了网络传输的数据量。</p>
</li>
<li><p>服务端推送：HTTP&#x2F;2 允许服务器在客户端请求前向客户端推送一些数据，提高了性能和用户体验。</p>
</li>
</ol>
<p>gRPC 底层使用 HTTP&#x2F;2 作为通信协议，不仅继承了 HTTP&#x2F;2 的优点，还加入了自己的序列化和反序列化协议，以支持多种编程语言和平台之间的通信，提高了跨语言和跨平台的互操作性和扩展性。</p>
<h2 id="grpc-相比于-http-优势在哪"><a href="#grpc-相比于-http-优势在哪" class="headerlink" title="grpc 相比于 http 优势在哪"></a>grpc 相比于 http 优势在哪</h2><ol>
<li><p>性能更高：gRPC 使用二进制协议，采用 Protocol Buffers 序列化数据，传输效率更高，速度更快。此外，gRPC 还支持流式数据传输，可以同时进行双向流数据传输，大幅提升了通信效率。</p>
</li>
<li><p>跨语言支持更好：gRPC 基于 IDL（接口定义语言）生成代码，支持多种编程语言，如 C++、Java、Python 等。这使得在不同编程语言之间进行通信变得更加容易和便捷。</p>
</li>
<li><p>更好的错误处理：gRPC 支持丰富的错误处理机制，可以在客户端和服务器端进行错误处理和异常处理，并提供了更加友好的错误提示信息，这使得开发人员更容易进行调试和定位错误。</p>
</li>
<li><p>更加灵活的流控和负载均衡：gRPC 支持多种流控算法和负载均衡策略，可以根据实际需求进行配置，提高系统的稳定性和可靠性。</p>
</li>
<li><p>更加易于扩展：gRPC 使用基于 HTTP&#x2F;2 协议的底层传输层，支持多路复用、头部压缩等特性，可以更加高效地使用网络资源，支持更大规模的系统扩展。</p>
</li>
</ol>
<p>综上所述，gRPC 相比于 HTTP 具有更高的性能、更好的跨语言支持、更好的错误处理、更加灵活的流控和负载均衡以及更加易于扩展等优势。适合于需要高效、可靠的服务间通信的场景。</p>


  

</article>



              </div>
            </div>
          </div>
        </div>
      </div>
    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
